yarn run v1.22.19
$ next build
info  - Loaded env from /home/ryoh96/product/tekrog/.env
info  - Skipping validation of types
info  - Skipping linting
info  - Creating an optimized production build...
info  - Compiled successfully
info  - Collecting page data...
info  - Generating static pages (0/59)
101010101010101010 {
  post: {
    content: '\n' +
      '<p>この記事では、React＋TypeScriptでstyled-componentsのThemeを利用する方法について解説します。Themeに型付けする方法等の説明していますが、型情報を無視すればJavaSciripterでも読めます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Theme"><span class="toc_number toc_depth_1">1</span> Themeとは</a></li><li><a href="#i"><span class="toc_number toc_depth_1">2</span> 最も基本的な使い方</a></li><li><a href="#Theme-2"><span class="toc_number toc_depth_1">3</span> Themeの型について</a></li><li><a href="#Theme-3"><span class="toc_number toc_depth_1">4</span> 関数テーマ～部分的にThemeを変える～</a></li><li><a href="#styled-componentsTheme"><span class="toc_number toc_depth_1">5</span> styled-components外でThemeを使う</a><ul><li><a href="#withTheme"><span class="toc_number toc_depth_2">5.1</span> withThemeでラップする高次のコンポーネント</a></li><li><a href="#useContext"><span class="toc_number toc_depth_2">5.2</span> useContextを使う</a></li><li><a href="#useTheme"><span class="toc_number toc_depth_2">5.3</span> useThemeを使う</a></li></ul></li><li><a href="#theme_props"><span class="toc_number toc_depth_1">6</span> theme propsで値のオーバーライド</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">7</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="Theme">Themeとは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">Themeを使うと、styled-componentsで利用する値を『共通の値』として色々なパーツで使いまわせます。</strong>themeで値を一元管理することで、デザインの一貫性を担保できたり修正に強いコンポーネントの作成が可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>なお、Theme以外のstyled-componentsの解説は次の記事で行っております。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/styled-components"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/styled-components</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/05/thumb-scs-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScriptでstyled-components〜基礎から発展的な使い方〜</div></div><div class="lkc-excerpt">この記事ではstyled-componentsをTypeScriptで利用する方法と代表的な機能をまとめています。変数、propsやattrsの使用方法、必要な型定義なども説明します。これら基本...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">最も基本的な使い方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは、テーマ(theme)をオブジェクトで記述します。<br>ここでは例として&#8221;main&#8221;と&#8221;sub&#8221;という値をthemeとして定義しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const theme = {\n' +
      '  main: "blue",\n' +
      '  sub: "purple"\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このようにthemeとして定義したmainとsubは、styled-componentsのpropsから自由にアクセスできるようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const Button1 = styled.button`\n' +
      '  background-color: ${props =&gt; props.theme.main};\n' +
      '  padding: 10px;\n' +
      '`\n' +
      '\n' +
      'const Button2 = styled.button`\n' +
      '  background-color: ${props =&gt; props.theme.sub};\n' +
      '  padding: 10px;\n' +
      '`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ただし、themeを使いたいコンポーネントはThemeProviderで囲む必要があります。この時、定義したthemeをpropsとして渡します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">&lt;ThemeProvider theme={theme}&gt;\n' +
      '  &lt;Button1&gt;Button1&lt;/Button1&gt;\n' +
      '  &lt;Button2&gt;Button2&lt;/Button2&gt;\n' +
      '&lt;/ThemeProvider&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/03/styled01.png" alt="" class="wp-image-2327" width="255" height="74" srcset="https://tekrog.com/wp-content/uploads/2023/03/styled01.png 510w, https://tekrog.com/wp-content/uploads/2023/03/styled01-300x86.png 300w" sizes="(max-width: 255px) 100vw, 255px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いて発展的な使い方を見ていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="Theme-2">Themeの型について</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>宣言のマージを利用して、Themeの型を型定義ファイル(d.ts)で宣言することができます。例えば、styled.d.tsを用意し、先ほどのThemeの型を宣言します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">import 'styled-components'\n` +
      "declare module 'styled-components' {\n" +
      '  export interface DefaultTheme {\n' +
      '    main: string\n' +
      '    sub: string\n' +
      '  }\n' +
      '}\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>DefaultThemeはもともと用意されている型ですが中身は空で、このようにThemeの型として拡張して利用することが可能です。あとはThemeの型が必要なところで、次のようにimportして使えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">import type { DefaultTheme } from 'styled-components'</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Theme-3">関数テーマ～部分的にThemeを変える～</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>『親ThemeProvider』の中に『子ThemeProvider』を定義し、子ThemeProviderの中だけでThemeの値を変更することが可能です。その際に利用するのが関数テーマ(function theme)です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、次の例のように、mainとsubの値を逆にする関数を考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const theme = {\n' +
      "  main: 'blue',\n" +
      "  sub: 'purple',\n" +
      '}\n' +
      '\n' +
      'const invertTheme = ({ main, sub }: DefaultTheme) =&gt; ({\n' +
      '  main: sub,\n' +
      '  sub: main,\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>親ThemeProviderにtheme, 子ThemeProviderにinvertThemeを与えると、子Themeの中だけでmainとsubの値が逆になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">&lt;ThemeProvider theme={theme}>\n' +
      '  &lt;Button1>Button1&lt;/Button1>\n' +
      '  &lt;Button2>Button2&lt;/Button2>\n' +
      '  &lt;Space />\n' +
      '  &lt;ThemeProvider theme={invertTheme}>\n' +
      '    &lt;Button1>Invert1&lt;/Button1>\n' +
      '    &lt;Button2>Invert2&lt;/Button2>\n' +
      '  &lt;/ThemeProvider>\n' +
      '&lt;/ThemeProvider></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/03/styled02.png" alt="" class="wp-image-2328" width="253" height="162" srcset="https://tekrog.com/wp-content/uploads/2023/03/styled02.png 506w, https://tekrog.com/wp-content/uploads/2023/03/styled02-300x192.png 300w" sizes="(max-width: 253px) 100vw, 253px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="styled-componentsTheme">styled-components外でThemeを使う</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>『styled.タグ』で定義したstyled-componentsではなく、通常のコンポーネントでThemeの値を利用する方法を3つ紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="withTheme">withThemeでラップする高次のコンポーネント</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コンポーネントをwithThemeでラップすると、themeにアクセスが可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">const Component = withTheme(({ theme }: { theme: DefaultTheme }) => {\n' +
      '  return &lt;>{console.log(theme.main)}&lt;/> //blueと表示される\n' +
      '})\n' +
      'const Wrapper = () => {\n' +
      '  return (\n' +
      '    &lt;ThemeProvider theme={theme}>\n' +
      '      &lt;Component />\n' +
      '    &lt;/ThemeProvider>\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useContext">useContextを使う</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>useContext(ThemeContext)でThemeの値にアクセスできるようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-tsx">import { useContext } from 'react'\n` +
      "import { ThemeContext } from 'styled-components'\n" +
      'const Component = () => {\n' +
      '  const themeContext = useContext(ThemeContext)\n' +
      '  return &lt;>{console.log(themeContext.main)}&lt;/> //blue\n' +
      '}\n' +
      'const Wrapper = () => {\n' +
      '  return (\n' +
      '    &lt;ThemeProvider theme={theme}>\n' +
      '      &lt;Component />\n' +
      '    &lt;/ThemeProvider>\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useTheme">useThemeを使う</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>もっとも簡単なのが、usetThemeカスタムフックを利用する方法です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-tsx">import { useTheme } from 'styled-components'\n` +
      'const Component = () => {\n' +
      '  const theme = useTheme()\n' +
      '  return &lt;>{console.log(theme.main)}&lt;/> //blue\n' +
      '}\n' +
      'const Wrapper = () => {\n' +
      '  return (\n' +
      '    &lt;ThemeProvider theme={theme}>\n' +
      '      &lt;Component />\n' +
      '    &lt;/ThemeProvider>\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="theme_props">theme propsで値のオーバーライド</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>styled-componentsのpropsにDefaultTheme型のthemeプロパティを渡すと、値がオーバーライドされます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">const theme = {\n' +
      "  main: 'blue',\n" +
      "  sub: 'purple',\n" +
      '}\n' +
      'const Button = styled.button`\n' +
      '  background-color: ${(props) => props.theme.main};\n' +
      '  border-color: ${(props) => props.theme.sub};\n' +
      '`\n' +
      'const Wrapper = () => {\n' +
      '  return (\n' +
      '    &lt;ThemeProvider theme={theme}>\n' +
      '      &lt;Button theme={{ main: "tomato", sub: "maroon" }}>Button&lt;/Button>\n' +
      '    &lt;/ThemeProvider>\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/03/styled03.png" alt="" class="wp-image-2332" width="90" height="45"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、styled-componentsのThemeに関連する解説をReact + TypeScriptで行いました。<br>その他のstyled-componentsの解説は次の記事で行っております。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/styled-components"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/styled-components</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/05/thumb-scs-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScriptでstyled-components〜基礎から発展的な使い方〜</div></div><div class="lkc-excerpt">この記事ではstyled-componentsをTypeScriptで利用する方法と代表的な機能をまとめています。変数、propsやattrsの使用方法、必要な型定義なども説明します。これら基本...</div></div><div class="clear"></div></div></a></div></div>\n',
    date: '2023-03-06T22:26:35',
    categories: { nodes: [Array] },
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    featuredImage: { node: [Object] },
    uri: '/styled-components-theme/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-2327
203 wp-image-2328
203 wp-image-2332
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
{ cursor: 'YXJyYXljb25uZWN0aW9uOjExODU=' }
101010101010101010 {
  post: {
    content: '\n' +
      '<p>GraphQL APIで目にするbefore、after、firstやlastといった変数、並びにnodesやedges、cursorやpageInfoの意味について分かりやすく解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#before_after_first_last"><span class="toc_number toc_depth_1">1</span> 【概要】before, after, first, lastとは</a></li><li><a href="#Relay_Cursor_Connections"><span class="toc_number toc_depth_1">2</span> Relay Cursor Connectionsって何？</a><ul><li><a href="#Relay"><span class="toc_number toc_depth_2">2.1</span> Relayとは</a></li><li><a href="#Cursor_Connections"><span class="toc_number toc_depth_2">2.2</span> Cursor Connectionsとは</a></li></ul></li><li><a href="#i"><span class="toc_number toc_depth_1">3</span> オフセット、カーソルによるページングの違い</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">4</span> 変数の意味を知る</a><ul><li><a href="#nodeedge"><span class="toc_number toc_depth_2">4.1</span> nodeとedge</a></li><li><a href="#connectionpageInfo"><span class="toc_number toc_depth_2">4.2</span> connectionとpageInfo</a></li><li><a href="#before_after_first_last-2"><span class="toc_number toc_depth_2">4.3</span> before, after, first, last</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">5</span> まとめ</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">6</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="before_after_first_last">【概要】before, after, first, lastとは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>before、after、firstやlast、nodesやedgesといった値は、GraphQLが元々備えている機能や仕様ではありません。<strong class="yellow-line">「Relay Cursor Connections」という、”ページング（ページ送り）”を効率的に行う方法に従って実装されたAPIだけが備えているもの</strong>です。GithubのGraphQL APIやWordPressのWPGraphQLがこれに当たります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>「Relay Cursor Connections」に従って実装されたAPIは、「ページ送り」や「必要な件数だけのデータの取得」が効率よく出来るようになります。自分で0から実装する場合も、この仕様に従って実装する必要があります。そしてこの「Relay Cursor Connections」でbeforeやafter、firstやnodesを使うように決められているのです。<br>ではbefore, after, first, lastやnodes, edgesはどういう意味なのでしょうか。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>順を追って説明していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>Relay Cursor Connectionsという仕様の概要について理解する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>カーソルを利用したページングについて理解する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>Relay Cursor Connectionsで使われている値について順次理解する<br>(①node/edge → ②connection/ pageInfo →　③ before/ after/ first/ last)</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Relay_Cursor_Connections">Relay Cursor Connectionsって何？</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Relay">Relayとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まず「Relay」とは、Facebookが開発したGraphQLのフレームワークです。その「Relay」で使われているページングの実装の仕様が「Relay Cursor Connections」です。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://relay.dev/docs/guides/graphql-server-specification/" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=relay.dev" alt="" width=16 height=16 /><div class="lkc-domain">relay.dev</div>&nbsp;<div class="lkc-url-info">https://relay.dev/docs/guides/graphql-server-specification/</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/pz-linkcard/cache/84c1aba7211244599cbc970ca8b0eaf20b0402ad90e444e3fa70d5d9928cb96a.jpeg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">GraphQL Server Specification | Relay</div></div><div class="lkc-excerpt">Relay GraphQL server specification guide</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Cursor_Connections">Cursor Connectionsとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ページングの方法は大きく分けて<strong>「①オフセットを利用する方法」</strong>と<strong>「②カーソルを利用する方法」</strong>の2つがあります。このうち、②の「カーソルを利用する方法」が表題の「Cursor Connections」にあたります。(オフセットとカーソルについては次節で説明します。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上から、「Relay Cursor Connections」とは、「Relay」というフレームワークで使われている「カーソルを利用したページング」に関する仕様ということになります。<strong class="yellow-line">この仕様に則ってフェッチされるデータは、実データにページング情報が付与されています。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いて、「オフセット」と「カーソル」について次節で軽く説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">オフセット、カーソルによるページングの違い</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①オフセットを利用したページング</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オフセットとは、「最初から数えて何番目か」を表す値です。オフセットを利用したページングではオフセットと取得件数を指定します。つまりオフセット(offset)がＮで取得件数(limit)がMのとき、「最初から数えてN+1番目の値から、M個データを持ってくる」ような実装となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/02/relay01-1-1024x845.png" alt="" class="wp-image-2188" width="512" height="423" srcset="https://tekrog.com/wp-content/uploads/2023/02/relay01-1-1024x845.png 1024w, https://tekrog.com/wp-content/uploads/2023/02/relay01-1-300x247.png 300w, https://tekrog.com/wp-content/uploads/2023/02/relay01-1-768x633.png 768w, https://tekrog.com/wp-content/uploads/2023/02/relay01-1.png 1301w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この方法は実装が楽ですが、データ取得時の通信が大きくなったり、データ更新時の整合性に少し問題があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②カーソルを利用したページング</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>カーソル(cursor)とは、それぞれのデータが持つポインタのようなものです。つまり、すべてのデータに「自分の住所、場所」を表す文字列をデータとともに持たせます。そしてcursorを利用したページングでは「カーソルAのデータの後ろのデータをM個持ってくる」ような実装となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/02/relay02-1024x845.png" alt="" class="wp-image-2189" width="512" height="423" srcset="https://tekrog.com/wp-content/uploads/2023/02/relay02-1024x845.png 1024w, https://tekrog.com/wp-content/uploads/2023/02/relay02-300x247.png 300w, https://tekrog.com/wp-content/uploads/2023/02/relay02-768x633.png 768w, https://tekrog.com/wp-content/uploads/2023/02/relay02.png 1301w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>GraphQLの公式ドキュメントでは、<strong>カーソルを利用したページングが最もパワフル</strong>だと紹介されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">変数の意味を知る</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="nodeedge">nodeとedge</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>node(ノード)とedge(エッジ)は数学のグラフ理論に基づいたもので、そもそもGraphQL自体がこのグラフに則ったものです。ここでグラフ理論の～と深堀するのではなく、Relay Cursor Connectionsの概要に必要な話に絞って解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>node</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>nodeは、typeで定義するデータのまとまりです。本来フェッチしたいデータを表します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell"># nodes\n' +
      'type User {\n' +
      '  id: ID!\n' +
      '  name: String!\n' +
      '  post: [Post]\n' +
      '}\n' +
      '\n' +
      '#nodes\n' +
      'type Post {\n' +
      '  id: ID!\n' +
      '  title: String!\n' +
      '  body: String!\n' +
      '  userId: ID!\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>edge</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>edgeはのnode(データ)とcursor(カーソル、住所)の2つからなります。<br>カーソルの実態はbase64でエンコードされたただの文字列で、それぞれのノードの住所を表現しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell"># edge\n' +
      'type UserEdge {\n' +
      '  node: User\n' +
      '  cursor: String!\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="connectionpageInfo">connectionとpageInfo</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いてconnectionとpageInfoの説明に入ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>connection</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>前節のedgeの集まりを配列edgesとし、これにページングの情報pageInfo(すぐ後で説明)を加えたものをconnectionといいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell"># connection\n' +
      'type UserConnection {\n' +
      '  edges: &#091;UserEdge]\n' +
      '  pageInfo: PageInfo!\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">このconnectionこそが、Relay Cursor Connectionsでフェッチしたときに返されるデータ一式となります。</strong><br>つまり、実データ(node)にカーソル(cursor)+ページング情報(pageInfo)が付与されたデータがフェッチされます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>pageInfo</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>pageInfoは現在のページの</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>①最初のデータのカーソル</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>②最後のデータのカーソル</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>③次のページへページング可能かのフラグ</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>④前のページへページング可能かのフラグ</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>の4つのプロパティを持ちます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell"># pageinfo\n' +
      'type PageInfo {\n' +
      '  startCursor: String #1\n' +
      '  endCursor: String #2\n' +
      '  hasNextPage: Boolean! #3\n' +
      '  hadPreviousPage: Boolean! #4\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ページが複数ある時、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1ページ目は、次ページがあり「hasNextPage: true」前ページがないので「hadPreviousPage: false」、<br>最後のページなら逆に「hasNextPage: false」「hadPreviousPage: true」、<br>途中のページならどちらもあるので「hasNextPage: true」「hadPreviousPage: true」<br>となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="before_after_first_last-2">before, after, first, last</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>before、afterはカーソル、firstとlastはデータの取得件数を表します。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これら4つの値はデータ取得時のクエリパラメータとして利用します。<br>このクエリパラメータでクエリを発行すると、前節のconnection(実データ＋カーソル＋ページング情報)が返ってきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">type Query {\n' +
      '  users(first: Int, after: String, last: Int, before: String): UserConnection!\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>しかし、この4つのパラメータを同時に使うことはありません。<br>クエリパラメータは、以下2パターンに分けて利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>①順方向(1ページ目→2ページ目等)のページングでは「afterとfirst」</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>②逆方向(3ページ目→2ページ目等)のページングでは「beforeとlast」</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いて詳しい使い方について説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①順方向のページング</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>afterで指定したカーソル位置の次のデータから、first個数のデータを取得するという意味になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">query UserQuery {\n' +
      '  users(first: 10, after: "rgainrgorao")\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/02/relay03-1024x845.png" alt="" class="wp-image-2191" width="512" height="423" srcset="https://tekrog.com/wp-content/uploads/2023/02/relay03-1024x845.png 1024w, https://tekrog.com/wp-content/uploads/2023/02/relay03-300x247.png 300w, https://tekrog.com/wp-content/uploads/2023/02/relay03-768x633.png 768w, https://tekrog.com/wp-content/uploads/2023/02/relay03.png 1301w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②逆方向のページング</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>beforeで指定したカーソル位置の前のデータから、last個のデータを取得するという意味です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">query UserQuery {\n' +
      '  users(last: 10, before: "agrinaornga")\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/02/relay04-1024x845.png" alt="" class="wp-image-2192" width="512" height="423" srcset="https://tekrog.com/wp-content/uploads/2023/02/relay04-1024x845.png 1024w, https://tekrog.com/wp-content/uploads/2023/02/relay04-300x247.png 300w, https://tekrog.com/wp-content/uploads'... 2664 more characters,
    date: '2023-02-27T10:52:21',
    categories: { nodes: [Array] },
    title: '【GraphQL】beforeやafter, first, edgeとは何か？',
    featuredImage: { node: [Object] },
    uri: '/graphql-relay-cursor/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
{ cursor: 'YXJyYXljb25uZWN0aW9uOjU1OA==' }
777777 true
777777 false
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-2188
203 wp-image-2189
203 wp-image-2191
203 wp-image-2192
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
101010101010101010 {
  post: {
    content: '\n' +
      '<p>JavaScript(TypeScript)のthenについて解説し、async/awaitとの違いを説明した後、使い分けや同時に使うケースなどを紹介します。この記事はTypeScriptで解説しますが、型情報を無視すればTypeScriptをご存じない方もJavaScriptコードとして読めます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#thenasyncawait"><span class="toc_number toc_depth_1">1</span> thenとasync/awaitはいつからある？</a></li><li><a href="#thenasyncawait-2"><span class="toc_number toc_depth_1">2</span> thenとasync/awaitの違い</a></li><li><a href="#then"><span class="toc_number toc_depth_1">3</span> thenについておさらい</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">3.1</span> 簡単な例</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">3.2</span> 非同期処理の例</a></li></ul></li><li><a href="#thenasync_await"><span class="toc_number toc_depth_1">4</span> thenをasync/ awaitで書き換える</a></li><li><a href="#thenawait"><span class="toc_number toc_depth_1">5</span> then句とawait句の使い分けについて</a></li><li><a href="#thenawait-2"><span class="toc_number toc_depth_1">6</span> then句とawait句を同時に使ってよりシンプルに</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">7</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="thenasyncawait">thenとasync/awaitはいつからある？</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まず初めにこれらの構文がJavaScriptに搭載された順番を知っておくといいでしょう。<br>PromiseとthenはES2015で採用され、async/awaitはそれよりも後のES2017で採用されました。<br><strong class="yellow-line">つまりthenのほうが昔からある構文になります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="thenasyncawait-2">thenとasync/awaitの違い</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">これらの2つの違いは書き方の違いくらいです。thenで書かれた処理はasync /awaitに置き換え可能です。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>書き換え可能なら新しい記述方法のasync / awaitの方が良いのでは？と思うかもしれませんが、<strong class="yellow-line">どちらが良いかは状況によります</strong>。また、<strong class="yellow-line">同時に利用することでコードが簡潔になる</strong>こともあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>使い分けや併用についてこの記事で解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="then">thenについておさらい</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">簡単な例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは以下のようなPromiseを例に考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const promise = new Promise(resolve =&gt; resolve(10))\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>単純に10を返すだけのPromiseです。これは下記のように簡単な式で書き換えられます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const promise = Promise.resolve(10)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>さて本題のthenですが、これはPromiseがresolveされた場合に実行されます。Promise型のオブジェクトからメソッドとして生やして利用します。<br>then句の中にはコールバック関数を記述し、その関数の引数にresolveの引数が代入されることになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const promise = Promise.resolve(10)\n' +
      'promise.then(data =&gt; console.log(data)) // 10と表示。dataには10が入る</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Promiseがrejectされた場合は、then句ではなくcatch句でエラーを捕捉します。<br>また、resolveされようがrejectされようが共通の処理を書きたい場合はfinally句を続けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const promise = Promise.reject("ERROR")\n' +
      'promise\n' +
      '  .then(() => console.log("正常な処理"))\n' +
      '  .catch(err => console.error(err)) // ERRORと表示\n' +
      '  .finally(() => console.log("いずれにしろ表示")) // ここも表示</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">非同期処理の例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>実際に非同期処理をthen句で書いてみます。非同期処理として、引数に渡した秒数待機する関数を例に挙げます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const timer = (sec: number): Promise&lt;string> =>\n' +
      '  new Promise((resolve) => setTimeout(() => resolve(`${sec}秒待機`), sec * 1000))\n' +
      'timer(2)\n' +
      '  .then((data) => {\n' +
      '    console.log(data)\n' +
      '    return timer(5)\n' +
      '  })\n' +
      '  .then((data) => {\n' +
      '    console.log(data)\n' +
      '    return timer(4)\n' +
      '  })\n' +
      '  .then((data) => {\n' +
      '    console.log(data)\n' +
      '    return timer(3)\n' +
      '  })\n' +
      '  .then(console.log)\n' +
      '// 出力\n' +
      '// 2秒待機\n' +
      '// 5秒待機\n' +
      '// 4秒待機\n' +
      '// 3秒待機</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このようにthen句の中で更にPromiseをreturnしてthen句をチェーンすることで、逐次タイマーが作動していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul>\n' +
      '<li class="point">最後のthen(console.log)のように、thenの中に関数名(この場合console.log)を直接書くと、thenの引数に渡されたパラメータを自動で関数に流します。</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="thenasync_await">thenをasync/ awaitで書き換える</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>async/ awaitとは何かという解説はこの記事では行っていないので、ご存じなかったり不安な方は次の記事を参照ください。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/learn-async-await-promise"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/learn-async-await-promise</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-async-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説</div></div><div class="lkc-excerpt">モダンなJavaScriptの開発ではPromiseやasync、awaitの利用が欠かせません。今回はこれらの意味について極限まで簡単にして説明します。10分程度で理解できる内容です。...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>さて、先ほどのタイマーの例をasync/ awaitで書き直してみます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const timer = (sec: number): Promise&lt;string> =>\n' +
      '  new Promise((resolve) => setTimeout(() => resolve(`${sec}秒待機`), sec * 1000))\n' +
      ';(async () => {\n' +
      '  let data = await timer(2)\n' +
      '  console.log(data)\n' +
      '  data = await timer(5)\n' +
      '  console.log(data)\n' +
      '  data = await timer(4)\n' +
      '  console.log(data)\n' +
      '  data = await timer(3)\n' +
      '  console.log(data)\n' +
      '})()\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>then句の時よりもシンプルで、より従来のコードに近くて分かりやすくなります。<br>ただし、awaitはasync関数で囲む必要があるため、上の例ではasyncの即時関数として実行しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">ES2022からはトップレベルでawaitを使う場合はasync関数で囲む必要がなくなりました。関数の中で使うには従来通りasyncが必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>※参考</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/recent-ecmascipt"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/recent-ecmascipt</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022-150x150.png" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】</div></div><div class="lkc-excerpt">ここ数年で追加されたJavaScrip(ECMAScript)tの新機能を遡ってまとめてざっと振り返る記事です。機能と使い方の要点を簡潔にまとめておさらいするような記事なので、よ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="thenawait">then句とawait句の使い分けについて</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>さて、今回の例を見てthen句とawait句のどちらがいいでしょうか。<br>正直、プロジェクトのルールがあるならそれに従って、でないのであれば好みで使って構わないと思います。<br>この例ですと個人的にawait句のほうがコードが少なくてすっきりとしてて読みやすいです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>コードをシンプルに書ける方を採用する、という観点も使い分ける際に重要だと思います。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>逆にthen句を使った方がシンプルになる例も載せます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// then句の方がシンプルな例\n' +
      'fetch("/api/hoge").then(setData)\n' +
      '// ↑と同じ処理をawait句で\n' +
      '(async () => {\n' +
      '  const data = await fetch("/api/hoge")\n' +
      '  setData(data)\n' +
      '})()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="thenawait-2">then句とawait句を同時に使ってよりシンプルに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>then句とawait句は同時に使えます。<br>そして、<strong class="yellow-line">同時に使った方がシンプルに書けることもあります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>先ほどのタイマーのawait句の例で考えます。<br>まずは先ほどのコードを再掲します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const timer = (sec: number): Promise&lt;string> =>\n' +
      '  new Promise((resolve) => setTimeout(() => resolve(`${sec}秒待機`), sec * 1000))\n' +
      ';(async () => {\n' +
      '  let data = await timer(2)\n' +
      '  console.log(data)\n' +
      '  data = await timer(5)\n' +
      '  console.log(data)\n' +
      '  data = await timer(4)\n' +
      '  console.log(data)\n' +
      '  data = await timer(3)\n' +
      '  console.log(data)\n' +
      '})()\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードはawait句とthen句を利用して、より少ない行数で書き直すことが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const timer = (sec: number): Promise&lt;string> =>\n' +
      '  new Promise((resolve) => setTimeout(() => resolve(`${sec}秒待機`), sec * 1000))\n' +
      ';(async () => {\n' +
      '  await timer(2).then(console.log)\n' +
      '  await timer(5).then(console.log)\n' +
      '  await timer(4).then(console.log)\n' +
      '  await timer(3).then(console.log)\n' +
      '})()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>行数が半分になったうえ、dataという変数すらいらなくなりました</strong>！</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>timerはPromise型なのでthen句が使えますし、Promise.then()もPromise型なのでawait句も使えるのです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>then句とasync/await句の違いや使い分け、併用方法について解説しました。Promiseの処理はthenの後に登場したasync / await句に完全に取って代わられたわけでなく、それぞれ使い分けたり併用することで、コードをよりシンプルに分かりやすく書くことが可能となります。</p>\n',
    date: '2023-02-15T15:09:31',
    categories: { nodes: [Array] },
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    featuredImage: { node: [Object] },
    uri: '/difference-between-then-and-await/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>TypeScript/ JavaScriptのPromiseの並列処理メソッド『all, race, allSetteled, any』について、実際のコードと図を用いて分かりやすく解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Promise"><span class="toc_number toc_depth_1">1</span> Promiseの並列処理基礎</a><ul><li><a href="#all_race_allSetteled_any"><span class="toc_number toc_depth_2">1.1</span> all, race, allSetteled, anyとは</a></li><li><a href="#all_race_allSetteled_any-2"><span class="toc_number toc_depth_2">1.2</span> all, race, allSetteled, anyの大別</a></li><li><a href="#i"><span class="toc_number toc_depth_2">1.3</span> 基本的な文法</a></li></ul></li><li><a href="#4"><span class="toc_number toc_depth_1">2</span> 4つの並列処理の使い方と意味</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">2.1</span> 解説にあたって</a></li><li><a href="#all"><span class="toc_number toc_depth_2">2.2</span> all</a></li><li><a href="#allSettled"><span class="toc_number toc_depth_2">2.3</span> allSettled</a></li><li><a href="#race"><span class="toc_number toc_depth_2">2.4</span> race</a></li><li><a href="#any"><span class="toc_number toc_depth_2">2.5</span> any</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="Promise">Promiseの並列処理基礎</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="all_race_allSetteled_any">all, race, allSetteled, anyとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Promise型をawaitするコードは、非同期処理を1つずつ待ってから順番に実行する『直列型』の処理でした。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/03/promise-all-01.png" alt="" class="wp-image-2276" width="510" height="289" srcset="https://tekrog.com/wp-content/uploads/2023/03/promise-all-01.png 1020w, https://tekrog.com/wp-content/uploads/2023/03/promise-all-01-300x170.png 300w, https://tekrog.com/wp-content/uploads/2023/03/promise-all-01-768x434.png 768w" sizes="(max-width: 510px) 100vw, 510px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それに対して『all, race, allSetteled, any』は<strong class="yellow-line">非同期処理を同時に、複数実行するためのメソッドです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2023/03/promise-all-03.png" alt="" class="wp-image-2279" width="510" height="272" srcset="https://tekrog.com/wp-content/uploads/2023/03/promise-all-03.png 1020w, https://tekrog.com/wp-content/uploads/2023/03/promise-all-03-300x160.png 300w, https://tekrog.com/wp-content/uploads/2023/03/promise-all-03-768x410.png 768w" sizes="(max-width: 510px) 100vw, 510px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>公式ドキュメントには『Promiseの並列処理メソッド』と説明されています。ですので、この記事でも『並列処理』のメソッドとして説明します。allやraceは前からありますが、allSetteledやanyは割と最近追加されました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">シングルスレッド上の処理なので厳密に言うと並列処理ではありませんが、小難しいことは最初は気にしなくてかまいません。気になる方は『JavaScript 並列処理 マルチスレッド』などで検索してみてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事を読むにあたり、基本的なPromise型やasync, awaitの使い方やresolve, rejectについてご存じのない方は次の記事を参考にしてください。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/learn-async-await-promise"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/learn-async-await-promise</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-async-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説</div></div><div class="lkc-excerpt">モダンなJavaScriptの開発ではPromiseやasync、awaitの利用が欠かせません。今回はこれらの意味について極限まで簡単にして説明します。10分程度で理解できる内容です。...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="all_race_allSetteled_any-2">all, race, allSetteled, anyの大別</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>『all, race, allSetteled, any』は次の２種類に分けられます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>①同時に実行する非同期処理の全ての結果が欲しい場合: <strong>『all/ allSettled』</strong></li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>②同時に実行する非同期処理のうち１番早く終わった結果だけ欲しい場合:<strong>『any/ race』</strong></li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えばA, B, Cの非同期処理を同時に走らせ、終わる順番がC→A→Bだとします。<br>①のメソッド(all/ allSettled)は終わる順番に関わらずA, B, Cすべての結果を取得しますが、②のメソッド(any/ race)は一番早く終わるCの結果しか取得しません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、①, ②にそれぞれ2つずつメソッドがありますが、その違いは『エラー発生時』の挙動の違いにあります。このことに関しては以下で詳しく解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">基本的な文法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>どのメソッドも、同時に実行したい非同期処理(Promise型)を配列にして引数に渡します。ここでは非同期処理を3つ並列に実行することを考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">Promise.all(&#091;非同期処理1, 非同期処理2, 非同期処理3])\n' +
      'Promise.allSettled(&#091;非同期処理1, 非同期処理2, 非同期処理3])\n' +
      'Promise.any(&#091;非同期処理1, 非同期処理2, 非同期処理3])\n' +
      'Promise.race(&#091;非同期処理1, 非同期処理2, 非同期処理3])</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>all, allSetteldの場合は非同期処理1,2,3の『全ての結果』が欲しいので、<strong class="yellow-line">各結果に対応する要素を配列のデストラクチャリングで用意</strong>する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const &#091;result1, result2, result3] \n' +
      '  = await Promise.all(&#091;非同期処理1, 非同期処理2, 非同期処理3])\n' +
      'const &#091;result1, result2, result3] \n' +
      '  = await Promise.allSettled(&#091;非同期処理1, 非同期処理2, 非同期処理3])</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>どのメソッドもPromise型を返すので、await句をつける必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>一方、any, raceの場合は非同期処理のうち『1つの結果』のみが欲しいので、<strong class="yellow-line">配列ではなく単独の値を用意</strong>します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const result = await Promise.any(&#091;非同期処理1, 非同期処理2, 非同期処理3])\n' +
      'const result = await Promise.race(&#091;非同期処理1, 非同期処理2, 非同期処理3])</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>基本的な文法が分かったところで、それぞれの使い方と意味について順番に解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="4">4つの並列処理の使い方と意味</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">解説にあたって</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>非同期処理の具体的なコードとして、次節の解説からsetTimeoutを用いたPromiseを扱います。Promiseがresolveするのかrejectするのか区別しやすくするため、次のように、『setTimeoutで待つ秒数』と、『resolveするかrejectするかを選択するモード』を引数で渡せる関数を作成して、それを例に説明していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、3秒でresolveする関数,2秒でrejectする関数は次のように使えます。 </p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">promise(3, "resolve") // 3秒でresolve\n' +
      'promise(2, "reject") // 2秒でreject</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この関数の具体的な実装は次の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">/**\n' +
      ' * setTimeoutでresolveかrejectを選択できる関数\n' +
      ' * @param sec setTimeoutで待つ秒数\n' +
      ' * @param mode resolveするかrejectするかを文字列リテラルで指定\n' +
      ' * @returns Promise型の値\n' +
      ' */\n' +
      "const promise = (sec: number, mode: 'resolve' | 'reject') \n" +
      '  => new Promise&lt;string>((resolve, reject) => {\n' +
      '  setTimeout(() => {\n' +
      "      mode === 'resolve' ? resolve(`resolved: ${sec}`) : reject(`Rejected: ${sec}`)\n" +
      '  }, sec * 1000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次のようにtry&#8230;catch分を使って、rejectされた場合にもきちんとメッセージが表示されるようにします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">;(async () => {\n' +
      '  try {\n' +
      "    const result1 = await promise(3, 'resolve')\n" +
      '    console.log(result1)\n' +
      "    const result2 = await promise(2, 'reject')\n" +
      '  } catch (err) {\n' +
      '    console.error(err)\n' +
      '  }\n' +
      '})()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">&#091;LOG]: "resolved: 3" \n' +
      '&#091;ERR]: "Rejected: 2" </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは実際に並列処理を行うメソッドについて見ていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="all">all</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>allは、同時に実行する複数の非同期処理の『全ての結果』が欲しい場合に利用しますが、<strong class="yellow-line">複数の非同期処理のうち1つでもrejectされると全体がreject</strong>になりエラーとなります。以下の2つのケースが考えられます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>ケース１：全部resolveされる場合</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>同時に実行した非同期処理が、それぞれきちんとresolveされて値を返します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const all = async () => {\n' +
      '    try {\n' +
      '        const &#091;p1, p2, p3] = await Promise.all(&#091;\n' +
      "            promise(2, 'resolve'), //A\n" +
      "            promise(1, 'resolve'), //B\n" +
      "            promise(5, 'resolve') //C\n" +
      '        ])\n' +
      '        console.log(p1, p2, p3)\n' +
      '    } catch (err) {\n' +
      '       console.error(err)\n' +
      '    } \n' +
      '}\n' +
      '\n' +
      'all()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>出力</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">&#091;LOG]: "resolved: 2",  "resolved: 1",  "resolved: 5" </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>値が返されるタイミングは、最も時間がかかった非同期処理がresolveされた時点です。上のコードのpromise最も時間がかかるのはCの5秒なので、このallが終わるのは5秒後です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>ケース２：どれか1つがrejectされる場合</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>allは複数の処理のうち、どれか１つがrejectされた瞬間に全体がrejectされエラーとなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>先ほどのコードで、2秒待つ非同期処理(Aのpromise)をrejectに変えてみます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const all = async () => {\n' +
      '    try {\n' +
      '        const &#091;p1, p2, p3] = await Promise.all(&#091;\n' +
      "            promise(2, 'reject'), //A\n" +
      "            promise(1, 'resolve'), //B\n" +
      "            promise(5, 'resolve') //C\n" +
      '        ])\n' +
      '        console.log(p1, p2, p3)\n' +
      '    } catch (err) {\n' +
      '       console.error(err)\n' +
      '    } \n' +
      '}\n' +
      '\n' +
      'all()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>出力</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">&#091;ERR]: "Rejected: 2"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この処理結果を時系列順に考えます。実行から1秒後にBのpromiseがresolveされます。しかし2秒後にAのpromiseがrejectされ、その瞬間にエラーとなりcatch文に移行します。5秒後に実行予定だったCのpromiseは実行されません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="allSettled">allSettled</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>allSettledはallと似てますが、<strong class="yellow-line">途中でrejectされても、最後まで非同期処理を実行します。その代わり、返される各値は、『成功したか、失敗したか』のステータス情報が付与された、PromiseSettledResult型の値になります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>実際のコードと実行結果を見るのが早いでしょう。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const allSettled = async () => {\n' +
      '    try {\n' +
      '        const &#091;p1, p2, p3] = await Promise.allSettled(&#091;\n' +
      "            promise(2, 'reject'),\n" +
      "            promise(1, 'resolve'),\n" +
      "            promise(5, 'resolve')\n" +
      '        ])\n' +
      '        console.log(p1, p2, p3)\n' +
      '    } catch (err) {\n' +
      '       console.error("error")\n' +
      '    } \n' +
      '}\n' +
      '\n' +
      'allSettled()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>結果</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">&#091;LOG]: {\n' +
      '  "status": "rejected",\n' +
      '  "reason": "Rejected: 2"\n' +
      '},  {\n' +
      '  "status": "fulfilled",\n' +
      '  "value": "resolved: 1"\n' +
      '},  {\n' +
      '  "status": "fulfilled",\n' +
      '  "value": "resolved: 5"\n' +
      '} </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このように、各logには<strong>statusプロパティで『resolveかrejectか』</strong>の情報が付与され、<strong>resolveの場合は『value』</strong>プロパティにresolveの結果が、<strong>rejectの場合は『reason』</strong>にエラーメッセージが表示されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>すべてが最後まで実行されるのでこのコードの実行時間は５秒で、エラーが発生しないのでtry&#8230;catch文で囲む必要もありません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="race">race</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>raceは、非同期処理のうち、<strong class="yellow-line">1番最初にresolveかrejectされる値を1つ返します。つまりresolveかrejectかに関係なく、最も早く終わった結果のみを返します'... 3329 more characters,
    date: '2023-03-04T16:49:13',
    categories: { nodes: [Array] },
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    featuredImage: { node: [Object] },
    uri: '/typescript-promise-cocurrency/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【GraphQL】beforeやafter, first, edgeとは何か？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-relay.png'
  },
  {
    title: '【Thunderbird】メッセージ送信ダイアログが消えない時の解決法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/thundrbird-dialog.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  }
]
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
203 lkc-favicon
203 wp-image-2276
203 wp-image-2279
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-thumbnail-img
203 wp-image-1895
203 wp-image-1896
203 wp-image-1897
203 wp-image-1898
203 wp-image-1899
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1975
203 wp-image-1976
203 wp-image-1977
203 wp-image-1978
203 wp-image-1980
203 wp-image-1981
203 wp-image-1983
203 wp-image-1985
203 wp-image-1986
203 wp-image-1988
203 wp-image-1990
203 wp-image-1991
203 wp-image-1992
203 wp-image-1994
203 wp-image-1995
203 wp-image-1996
203 wp-image-1997
203 wp-image-1998
203 wp-image-2000
203 wp-image-2001
203 wp-image-2002
203 wp-image-2003
203 wp-image-2004
203 wp-image-2006
203 lkc-favicon
203 lkc-thumbnail-img
101010101010101010 {
  post: {
    content: '\n' +
      '<p>ここ数年で追加されたJavaScrip(ECMAScript)tの新機能を遡ってまとめてざっと振り返る記事です。<br>機能と使い方の要点を簡潔にまとめておさらいするような記事なので、より詳しい使用方法などは適宜リンクなどをたどって下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#ES2022ES13"><span class="toc_number toc_depth_1">1</span> ES2022(ES13)</a><ul><li><a href="#awaitasync"><span class="toc_number toc_depth_2">1.1</span> トップレベルならawaitを使うのにasyncが不要</a></li><li><a href="#i"><span class="toc_number toc_depth_2">1.2</span> クラスにプライベートなメンバが宣言可能に</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">1.3</span> クラスに静的メンバが宣言可能に</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">1.4</span> クラスに静的初期化ブロックが宣言可能に</a></li><li><a href="#in"><span class="toc_number toc_depth_2">1.5</span> in演算子によるブランドチェック</a></li><li><a href="#at"><span class="toc_number toc_depth_2">1.6</span> at演算子で配列の後ろからのアクセスが簡単に</a></li><li><a href="#hasOwnPropertyhasOwn"><span class="toc_number toc_depth_2">1.7</span> hasOwnPropertyを改良したhasOwn</a></li><li><a href="#cause"><span class="toc_number toc_depth_2">1.8</span> causeプロパティによるエラーのチェーン</a></li><li><a href="#d"><span class="toc_number toc_depth_2">1.9</span> 正規表現にdフラグの追加</a></li></ul></li><li><a href="#ES2021ES12"><span class="toc_number toc_depth_1">2</span> ES2021(ES12)</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">2.1</span> 大きい数字を区切って人間が見やすくする</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">2.2</span> 論理代入演算子</a></li><li><a href="#replaceAll"><span class="toc_number toc_depth_2">2.3</span> replaceAll()メソッドによる文字列の一括置換</a></li><li><a href="#Promiseanyresolve"><span class="toc_number toc_depth_2">2.4</span> Promise.any()で一番早くresolveした処理を採用</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">2.5</span> 弱参照の追加</a></li></ul></li><li><a href="#ES2020ES11"><span class="toc_number toc_depth_1">3</span> ES2020(ES11)</a><ul><li><a href="#BigInt"><span class="toc_number toc_depth_2">3.1</span> 非常に大きな数値を扱えるBigInt型</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">3.2</span> オプショナルチェーン(?.)で安全にチェーン</a></li><li><a href="#null"><span class="toc_number toc_depth_2">3.3</span> null合体演算子(??)</a></li><li><a href="#i-8"><span class="toc_number toc_depth_2">3.4</span> 動的インポート</a></li><li><a href="#importexport"><span class="toc_number toc_depth_2">3.5</span> importしたものをそのままexportする</a></li><li><a href="#i-9"><span class="toc_number toc_depth_2">3.6</span> モジュールのメタ情報を得る</a></li><li><a href="#PromiseallSettled"><span class="toc_number toc_depth_2">3.7</span> Promise.allSettledによる非同期処理</a></li><li><a href="#NodejsglobalThis"><span class="toc_number toc_depth_2">3.8</span> ブラウザとNode.js共通のグローバルオブジェクト(globalThis)</a></li><li><a href="#matchAll"><span class="toc_number toc_depth_2">3.9</span> 正規表現でマッチした文字列をイテレータで返す(matchAll)</a></li><li><a href="#for-in"><span class="toc_number toc_depth_2">3.10</span> for-in文の順番が保証される</a></li></ul></li><li><a href="#ES2019ES10"><span class="toc_number toc_depth_1">4</span> ES2019(ES10)</a><ul><li><a href="#trimStart_trimEnd"><span class="toc_number toc_depth_2">4.1</span> 文字列の片側だけ空白をトリミング(trimStart, trimEnd)</a></li><li><a href="#2ObjectfronEntries"><span class="toc_number toc_depth_2">4.2</span> 2要素の配列からオブジェクトを作る(Object.fronEntries)</a></li><li><a href="#flat_flatMap"><span class="toc_number toc_depth_2">4.3</span> 配列の平坦化(flat, flatMap)</a></li><li><a href="#ECMAScriptJSON"><span class="toc_number toc_depth_2">4.4</span> ECMAScriptとJSONにおける区切り文字の統一</a></li><li><a href="#catch"><span class="toc_number toc_depth_2">4.5</span> catch句の引数の記述を省略可能</a></li><li><a href="#toString"><span class="toc_number toc_depth_2">4.6</span> 関数にtoString()を使用したときコメントも文字列となる</a></li><li><a href="#Symbol"><span class="toc_number toc_depth_2">4.7</span> Symbolの引数を返す</a></li></ul></li><li><a href="#i-10"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="ES2022ES13">ES2022(ES13)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="awaitasync">トップレベルならawaitを使うのにasyncが不要</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードのトップレベルならば、わざわざasyncで関数を作らずにawait句を直接かけます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">// トップレベル\n' +
      'const hoge = await fetch(`https://jsonplaceholder.typicode.com/todos/1`)\n' +
      '                    .then(res =&gt; res.json())\n' +
      'console.log(hoge)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>あくまでトップレベルでの話なので、関数の中では従来通りasync句が必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">// 関数の中はasync句が必須\n' +
      'const func = async () => {\n' +
      '  const hoge = await fetch(`https://jsonplaceholder.typicode.com/todos/1`)\n' +
      '                      .then(res => res.json())\n' +
      '  console.log(hoge)\n' +
      '}\n' +
      'func()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>利点</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>書き捨てでawait句のコードが書ける</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>非同期処理をエクスポートできる</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>２番目の項目が重要で、<strong class="yellow-line">importしたモジュールがトップレベルawaitを持っていた場合の処理順などに影響します</strong>。<br>静的importか動的importかによって処理順が変わるのですが、詳しい解説がこちらに乗っているのでリンクさせていただきます。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://qiita.com/uhyo/items/0e2e9eaa30ec2ff05260" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=qiita.com" alt="" width=16 height=16 /><div class="lkc-domain">Qiita</div>&nbsp;<div class="lkc-url-info">https://qiita.com/uhyo/items/0e2e9eaa30ec2ff05260</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="https://s.wordpress.com/mshots/v1/https%3A%2F%2Fqiita.com%2Fuhyo%2Fitems%2F0e2e9eaa30ec2ff05260?w=200" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">top-level awaitがどのようにES Modulesに影響するのか完全に理解する - Qiita</div></div><div class="lkc-excerpt">先日、TypeScript 3.8 RCが公開されました。TypeScript 3.8はクラスのprivateフィールド（#nameみたいなやつ）を始めとして、ECMAScriptの新機能のサポートがいくつか追...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">クラスにプライベートなメンバが宣言可能に</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>クラスのメンバの前に#をつけることでprivateにできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">class MyClass {\n' +
      '  #name = "taro"\n' +
      '  age = 10\n' +
      '  showName() {\n' +
      '    console.log(this.#name)\n' +
      '  }\n' +
      '  #showAge() {\n' +
      '    console.log(thie.age)\n' +
      '  }\n' +
      '}\n' +
      'const c = new MyClass\n' +
      'c.age = 20\n' +
      'console.log(c.age)\n' +
      '// c.#name = 40 //エラー\n' +
      'c.showName()\n' +
      '// c.#showAge() //エラー</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">クラスに静的メンバが宣言可能に</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>static句で静的メンバが使えるようになりました。静的メンバとは、クラスをインスタンス化せずとも利用できるメンバのことです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">class MyClass {\n' +
      '  static #name = "taro"\n' +
      '  static age = 10\n' +
      '  static showName() {\n' +
      '    console.log(this.#name)\n' +
      '  }\n' +
      '  static #showAge() {\n' +
      '    console.log(thie.age)\n' +
      '  }\n' +
      '}\n' +
      'console.log(MyClass.age)\n' +
      '// console.log(MyClass.#name) //エラー\n' +
      'MyClass.showName()\n' +
      '// MYClass.#showAge() //エラー</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">クラスに静的初期化ブロックが宣言可能に</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>クラス内でstaticブロックが利用できます。<strong class="language-js">staticブロックはインスタンス宣言時よりも前のクラス評価時に実行されます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>staticメンバ自身、あるいはそれを利用した初期化処理等に利用できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">class MyClass {\n' +
      '  static name = "taro"\n' +
      '  static age\n' +
      '  static {\n' +
      '    MyClass.age = 10\n' +
      '  }\n' +
      '}\n' +
      'console.log(MyClass.age) //10</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="in">in演算子によるブランドチェック</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>あるクラスのインスタンスかどうか判定するのに instanceof演算子が利用できますが、setPrototypeOf() を使用すると、あるクラスのインスタンスでないのにtrueを返してしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">class MyClass {}\n' +
      'class YourClass {}\n' +
      'const my = new MyClass\n' +
      'const your = new YourClass\n' +
      'Object.setPrototypeOf(my, your)\n' +
      'console.log(my instanceof YourClass) //true</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>プライベートメンバとそれに使えるin演算子によって、以下のように厳密にインスタンス判定が可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">class MyClass {\n' +
      '  #brand\n' +
      '  static isMyClass(instance) {\n' +
      '    return #brand in instance\n' +
      '  }\n' +
      '}\n' +
      'class YourClass {\n' +
      '  #brand\n' +
      '  static isYourClass(instance) {\n' +
      '    return #brand in instance\n' +
      '  }\n' +
      '}\n' +
      'const my = new MyClass\n' +
      'const your = new YourClass\n' +
      'Object.setPrototypeOf(my, your)\n' +
      'console.log(YourClass.isYourClass(my))//false</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="at">at演算子で配列の後ろからのアクセスが簡単に</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列や文字列で従来のブラケット[]アクセスの他に、at演算子でアクセスが可能となります。<br><strong class="yellow-line">このatの便利な点は、負のインデックスを使用することで配列の後ろからアクセスが可能になることです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>つまり後ろから数えて何番目かを簡単に指定できます。python等では従来からある機能ですね。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const hoge = &#091;"foo", "bar", "piyo"]\n' +
      'console.log(hoge.at(1)) // "bar"\n' +
      'console.log(hoge.at(-1)) // "piyo"\n' +
      'console.log(hoge.at(-2)) // "bar"\n' +
      '//従来はhoge&#091;hoge.length - 1]としてアクセスしてた</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="hasOwnPropertyhasOwn">hasOwnPropertyを改良したhasOwn</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>あるオブジェクトがあるプロパティを持つかどうか判定するために、Obejct.property.hasOwnPropertyが利用されてきました。(Object.hasPropertyはプロパティ汚染があるため非推奨)。Obejct.property.hasOwnPropertyという記述はとても長いため、そのショートハンドとして、Object.hasOwnが利用化できるようになりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const obj = {\n' +
      '  hoge: 2\n' +
      '}\n' +
      'console.log(Object.hasOwn(obj, "hoge")) // true</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="cause">causeプロパティによるエラーのチェーン</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次のようなコードでは、従来はエラーがチェーンしていてもどこでエラーが発生しているか伝えるのが困難でした。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">function A() {\n' +
      '  try {\n' +
      '    B();\n' +
      '    a\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error A");\n' +
      '  }\n' +
      '}\n' +
      'function B() {\n' +
      '  try {\n' +
      '    C();\n' +
      '    b\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error B");\n' +
      '  }\n' +
      '}\n' +
      'function C() {\n' +
      '  try {\n' +
      '    c;\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error C");\n' +
      '  }\n' +
      '}\n' +
      'try {\n' +
      '  A();\n' +
      '} catch (e) {\n' +
      '  console.log(e); \n' +
      '  // A,B,Cのどの関数でエラーが発生していようがError A\n' +
      '}\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>新しく追加されたcauseプロパティを利用すると、エラーが発生したところから親をたどれます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">function A() {\n' +
      '  try {\n' +
      '    B();\n' +
      '    a\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error A", {\n' +
      '      cause: e,\n' +
      '    });\n' +
      '  }\n' +
      '}\n' +
      'function B() {\n' +
      '  try {\n' +
      '    C();\n' +
      '    b\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error B", {\n' +
      '      cause: e,\n' +
      '    });\n' +
      '  }\n' +
      '}\n' +
      'function C() {\n' +
      '  try {\n' +
      '    c\n' +
      '  } catch (e) {\n' +
      '    throw new Error("Error C", {\n' +
      '      cause: e,\n' +
      '    });'... 13963 more characters,
    date: '2023-02-15T15:05:27',
    categories: { nodes: [Array] },
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    featuredImage: { node: [Object] },
    uri: '/recent-ecmascipt/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
777777 false
777777 false
777777 false
777777 false
777777 true
777777 false
777777 false
777777 false
777777 false
777777 false
777777 false
777777 false
777777 true
{ cursor: 'YXJyYXljb25uZWN0aW9uOjE4OTI=' }
101010101010101010 {
  post: {
    content: '\n' +
      '<p>TypeScript4.9からTypeScript4.6に遡って新機能をまとめています。4.5以前の内容は<a href="https://tekrog.com/new-features-in-typescript4/" target="_blank" rel="noreferrer noopener">別記事にまとめています</a>。まとめてある内容は文法レベルの新機能で、細かい改良及び仕様変更についてはまとめていません。ざっと新機能だけを確認するのが目的です。記事の後ろに行けば行くほど古いバージョンについて書いているため、知っているバージョンまでスクロールする必要はありません。各見出しの後には、公式ドキュメント(英語)に対応する項目を記載しております。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>※この記事は逐次更新します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Typescript45_40"><span class="toc_number toc_depth_1">1</span> Typescript4.5 ~ 4.0について</a></li><li><a href="#TypeScript_49"><span class="toc_number toc_depth_1">2</span> TypeScript 4.9</a><ul><li><a href="#satisfies"><span class="toc_number toc_depth_2">2.1</span> satisfies演算子によるオブジェクトの型推論の改善</a></li><li><a href="#i"><span class="toc_number toc_depth_2">2.2</span> クラスのオートアクセッサー</a></li><li><a href="#NaN"><span class="toc_number toc_depth_2">2.3</span> NaNを比較演算子と用いるとエラーが出るようになった</a></li></ul></li><li><a href="#TypeScript48"><span class="toc_number toc_depth_1">3</span> TypeScript4.8</a><ul><li><a href="#infer"><span class="toc_number toc_depth_2">3.1</span> テンプレート文字列型とinferの型推論改善</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">3.2</span> 配列やオブジェクトのリテラルを比較するとエラー</a></li></ul></li><li><a href="#TypeSciprt47"><span class="toc_number toc_depth_1">4</span> TypeSciprt4.7</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">4.1</span> ブラケットで囲まれた要素へのアクセスに対する制御フロー解析</a></li><li><a href="#inferextends"><span class="toc_number toc_depth_2">4.2</span> infer~extendsでより柔軟な記述が可能に</a></li></ul></li><li><a href="#TypeScript_46"><span class="toc_number toc_depth_1">5</span> TypeScript 4.6</a><ul><li><a href="#super"><span class="toc_number toc_depth_2">5.1</span> super()の前に処理を書いてもエラーにならない</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">6</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="Typescript45_40">Typescript4.5 ~ 4.0について</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>こちらの記事でまとめております。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/new-features-in-typescript4"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/new-features-in-typescript4</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/01/thumb-ts-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScript4.5~4.0の新機能まとめ</div></div><div class="lkc-excerpt">最新のTypeScript4.5から、TypeScript4.0に遡って新機能をまとめています。まとめてある内容は文法レベルの新機能で、細かい仕様変更についてはまとめていません。ざっ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript_49">TypeScript 4.9</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="satisfies">satisfies演算子によるオブジェクトの型推論の改善</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名：『The satisfies operator』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>satisfied演算子というものが導入されました。<br>これを用いると、オブジェクトの『プロパティのスペルミスのチェック』と『プロパティの型推論』が同時にスマートに行われます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下のように、Color型をキーに、string | [number, number, number]型を値にもつオブジェクトpaletteを考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">type Colors = "red" | "green" | "blue";\n' +
      'type RGB = &#091;red: number, green: number, blue: number];\n' +
      '\n' +
      'const palette = {\n' +
      '    red: &#091;255, 0, 0],\n' +
      '    green: "#00ff00",\n' +
      '    bleu: &#091;0, 0, 255]\n' +
      '//  ~~~~ 1.blueと打ちたかったけどタイプミスした\n' +
      '//  型アノテーションしてないのでエラーは出ない\n' +
      '}\n' +
      '\n' +
      '// 2. 以下の時点でredはnumber&#091;]型と推論される\n' +
      'palette.red</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>型のアノテーションをしてないので、<br>①bleuとタイプミスしたプロパティにエラーは出ませんし、<br>②paltteは型推論により</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">{\n' +
      '    red: number&#091;];\n' +
      '    green: string;\n' +
      '    bleu: number&#091;];\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>となるので、それぞれのプロパティ値が絞り込まれています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①のプロパティのスペルミスをなくすために次のようにアノテーションをすると、今度は②の型推論でプロパティの型が絞り込まれなくなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">type Colors = "red" | "green" | "blue";\n' +
      'type RGB = &#091;red: number, green: number, blue: number];\n' +
      '\n' +
      'const palette: Record&lt;Colors, string | RGB> = {\n' +
      '    red: &#091;255, 0, 0],\n' +
      '    green: "#00ff00",\n' +
      '    blue: "hoge"\n' +
      '    // bleu: &#091;0, 0, 255]\n' +
      '//  ~~~~ 1.blueというタイプミスは検出される\n' +
      '};\n' +
      '\n' +
      '// 2. 以下はstring | RGBとなり型が絞り込まれない\n' +
      '// ので型推論が聞かない\n' +
      'palette.blue</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>型のアノテーションをしたので、<br>①bleuとタイプミスしたプロパティにエラー検出でき、<br>②paltteはstring | RGB型となる</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>よって、オブジェクトのプロパティにアクセスしても型が絞り込まれません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これらの問題を解決するのが『satisfied演算子』です。<br>以下のように使います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">const palette = {\n' +
      '    red: &#091;255, 0, 0],\n' +
      '    green: "#00ff00",\n' +
      '    blue: &#091;0, 0, 255]\n' +
      '//  ~~~~ 1.タイプミスは検出される\n' +
      '} satisfies Record&lt;Colors, string | RGB&gt;\n' +
      '\n' +
      '//2.型の絞り込みも行われる\n' +
      '// &#091;number, number, number]型になる\n' +
      'palette.red</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オブジェクトのキーはsatisfiesで指定した型を最低限満たす必要があるので、<br>①Colors型にないキーはエラーとなります。<br>また、②型の絞り込みもスマートに行われています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>他の例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">const foo = {\n' +
      '    hoge: "hogehoge",\n' +
      '    fuga: "fugafuga",\n' +
      '    piyo: "piyopiyo",\n' +
      '    // bar: 4 //エラー\n' +
      '} satisfies Record&lt;string, string&gt;\n' +
      '\n' +
      '//　上のオブジェクトはRecord&lt;string, string&gt;を満たしたうえで次のような型になる\n' +
      '{\n' +
      '    hoge: string\n' +
      '    fuga: string,\n' +
      '    piyo: string\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">クラスのオートアクセッサー</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名:『Auto-Accessors in Classes』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ECMAScriptの次期機能であるオートアクセッサーをサポートしています。クラスのプロパティに『accessor』をつけることで、次ようにクラスを省略して記述できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">class Person {\n' +
      '    accessor name: string;\n' +
      '    constructor(name: string) {\n' +
      '        this.name = name;\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      '// このクラスは上クラスと同じ\n' +
      'class Person {\n' +
      '    #__name: string;\n' +
      '    get name() {\n' +
      '        return this.#__name;\n' +
      '    }\n' +
      '    set name(value: string) {\n' +
      '        this.#__name = name;\n' +
      '    }\n' +
      '    constructor(name: string) {\n' +
      '        this.name = name;\n' +
      '    }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="NaN">NaNを比較演算子と用いるとエラーが出るようになった</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名:『Checks For Equality on NaN』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下の式はすべてエラーになります。NaNに対するチェックは、Number.isNaNを用いるようにします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">NaN === NaN\n' +
      'NaN !== NaN\n' +
      'NaN === 0\n' +
      'NaN !== 0\n' +
      '\n' +
      'let someValue = 3\n' +
      'someValue === NaN\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="TypeScript48">TypeScript4.8</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="infer">テンプレート文字列型とinferの型推論改善</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名: 『Improved Inference for infer Types in Template String Types』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>テンプレート文字列型のinfer~extendsにおいて、リテラル型がきちんと推論されるようになりました。<br>なお、infer句をextendsと組み合わせる構文はTypeScript4.7で追加されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">type Num&lt;T&gt; = T extends `${infer U extends number}` ? U : never;\n' +
      '\n' +
      "type hoge = Num&lt;'10'&gt; //リテラルの10型。今まではnumber型。</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">配列やオブジェクトのリテラルを比較するとエラー</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名:『Errors When Comparing Object and Array Literals』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列、オブジェクトのリテラルを比較するとエラーが出ます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">let hoge: number&#091;] = &#091;]\n' +
      'if (hoge === &#091;]) {} //エラー</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Javascriptでは配列やオブジェクトの比較は値ではなく参照が等しいかどうかを見ているので、値同士を比較していると勘違いした人によるバグを防止します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeSciprt47">TypeSciprt4.7</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">ブラケットで囲まれた要素へのアクセスに対する制御フロー解析</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名:『Control-Flow Analysis for Bracketed Element Access』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オブジェクトのキーがリテラル型かシンボルである場合、要素の型の絞り込みが可能となりました。<br>具体例を示します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">const key = Symbol();\n' +
      '\n' +
      'const numberOrString = Math.random() &lt; 0.5 ? 42 : "hello";\n' +
      '\n' +
      'const obj = {\n' +
      '    &#091;key]: numberOrString,\n' +
      '};\n' +
      '\n' +
      'if (typeof obj&#091;key] === "string") {\n' +
      '    // obj&#091;key] はstring型に絞り込まれているのでtoUpperCase()が使える。\n' +
      '    // 以前はstring | number型から絞り込めなかった\n' +
      '    let str = obj&#091;key].toUpperCase();\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この改善によって、コンストラクタでプロパティが初期化されていないとエラーを吐くコードが書けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">const key = Symbol();\n' +
      '\n' +
      'class C {\n' +
      '    &#091;key]: string;\n' +
      '\n' +
      '    constructor(str: string) {\n' +
      '        // &#091;key]の初期化をしていないのでエラー\n' +
      '    }\n' +
      '\n' +
      '    screamString() {\n' +
      '        return this&#091;key].toUpperCase();\n' +
      '    }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="inferextends">infer~extendsでより柔軟な記述が可能に</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名:『extends Constraints on infer Type Variables』</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>下記のように、infer句とextendsを組み合わせることで柔軟な型の記述が可能となりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">type FirstIfString&lt;T&gt; =\n' +
      '    T extends &#091;infer S extends string, ...unknown&#091;]]\n' +
      '        ? S\n' +
      '        : never;\n' +
      '\n' +
      '// string\n' +
      'type A = FirstIfString&lt;&#091;string, number, number]&gt;;\n' +
      '\n' +
      '// "hello"\n' +
      'type B = FirstIfString&lt;&#091;"hello", number, number]&gt;;\n' +
      '\n' +
      '// "hello" | "world"\n' +
      'type C = FirstIfString&lt;&#091;"hello" | "world", boolean]&gt;;\n' +
      '\n' +
      '// never\n' +
      'type D = FirstIfString&lt;&#091;boolean, number, string]&gt;;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript_46">TypeScript 4.6</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="super">super()の前に処理を書いてもエラーにならない</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下のコードは4.5以前だとエラーになっていました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">declare function doSomething(): void\n' +
      'class Hoge {}\n' +
      'class Fuga extends Hoge {\n' +
      '    private piyo = 0\n' +
      '    public constructor(){\n' +
      '        doSomething() // 4.6より前だとエラー\n' +
      '        super()\n' +
      '    }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote">\n' +
      '<p>公式ドキュメント</p>\n' +
      '<cite><a href="https://www.typescriptlang.org/docs/handbook/release-notes/overview.html" target="_blank" rel="'... 129 more characters,
    date: '2023-01-08T14:24:08',
    categories: { nodes: [Array] },
    title: 'TypeScript4.9~4.6の新機能まとめ',
    featuredImage: { node: [Object] },
    uri: '/new-features-in-typescript4-2/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
{ cursor: 'YXJyYXljb25uZWN0aW9uOjE2OTc=' }
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vueにおいてコンポーネントの階層が深くなったとき、浅い階層から深い階層へデータを渡すためにバケツリレー(props drilling)が発生することがあります。そのために、データを一元管理するVuexやPiniaなどの外部ライブラリを使うことが一般的です。しかしアプリの規模が小さい場合や外部ライブラリがオーバースペックになる場合は、Vueに備えられているProvideとInjectを利用する手もあります。この記事ではVue3におけるProvideとInjectをComposition APIとTypeScriptで解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#ProvideInject"><span class="toc_number toc_depth_1">1</span> ProvideとInjectで出来ること</a></li><li><a href="#provideinject"><span class="toc_number toc_depth_1">2</span> provideとinjectの基本</a><ul><li><a href="#Composition_API"><span class="toc_number toc_depth_2">2.1</span> Composition APIでの使い方</a></li><li><a href="#TypeScript"><span class="toc_number toc_depth_2">2.2</span> TypeScriptでの記述方法</a></li></ul></li><li><a href="#i"><span class="toc_number toc_depth_1">3</span> 文字列キーを使用する方法</a><ul><li><a href="#provide"><span class="toc_number toc_depth_2">3.1</span> 文字列キーを使用した場合のprovide</a></li><li><a href="#inject"><span class="toc_number toc_depth_2">3.2</span> 文字列キーを使用した場合のinject</a></li></ul></li><li><a href="#InjectionKey"><span class="toc_number toc_depth_1">4</span> InjectionKeyを使用する方法</a><ul><li><a href="#InjectionKeyprovide"><span class="toc_number toc_depth_2">4.1</span> InjectionKeyを使用した場合のprovide</a></li><li><a href="#InjectionKeyinject"><span class="toc_number toc_depth_2">4.2</span> InjectionKeyを使用した場合のinject</a></li></ul></li><li><a href="#i-2"><span class="toc_number toc_depth_1">5</span> どちらのキーを利用すれば良いか</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">6</span> 使い方について補足</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">6.1</span> リアクティブなデータは子孫コンポーネントで変更しない</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">7</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="ProvideInject">ProvideとInjectで出来ること</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>出来ることはとてもシンプルで、<strong class="yellow-line">親で定義したデータを&#8221;バケツリレー(props drilling)しないで&#8221;子孫コンポーネントに直接渡せます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/provide-inject-1024x519.png" alt="" class="wp-image-2036" width="512" height="260" srcset="https://tekrog.com/wp-content/uploads/2022/05/provide-inject-1024x519.png 1024w, https://tekrog.com/wp-content/uploads/2022/05/provide-inject-300x152.png 300w, https://tekrog.com/wp-content/uploads/2022/05/provide-inject-768x389.png 768w, https://tekrog.com/wp-content/uploads/2022/05/provide-inject-1536x779.png 1536w, https://tekrog.com/wp-content/uploads/2022/05/provide-inject.png 1862w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>VuexやPiniaなどの状態管理用の外部ライブラリほど複雑なことは出来ません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="provideinject">provideとinjectの基本</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Composition_API">Composition APIでの使い方</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">親コンポーネントにおいて、子孫に供給したいデータをprovide関数に渡します。</strong><br>その際に、データを一意に識別するキーを第1引数に指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts">\n' +
      'import { provide } from "vue"\n' +
      '\n' +
      'provide(キー, 渡したいデータ)\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">供給されたデータを使いたい子孫コンポーネントは、inject関数でデータを受け取ります。</strong><br>その際に親で指定したキーを引数に渡します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts">\n' +
      'import { inject } from "vue"\n' +
      '\n' +
      'const useData = inject(キー)\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>キーに対応するデータがない場合に備えて、injectの第２引数にはデフォルト値を渡すことも可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">inject(キー, デフォルト値)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="TypeScript">TypeScriptでの記述方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TypeScriptを用いた場合、<strong class="yellow-line">キーの指定方法は2パターン</strong>あります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>① 文字列キーを使用</li><li>② InjectionKeyを使用</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>の2パターンです。どちらを使うかによって型指定やデータの受け取り方が異なるので、順番に解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">文字列キーを使用する方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="provide">文字列キーを使用した場合のprovide</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>文字列キーとは、文字通り「string型のキー」を使用する方法です。<br>次のようにして使います。キーの名前は任意です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//"key1"という文字列キーにnumber型の30を渡す\n' +
      'provide("key1", 30)\n' +
      '\n' +
      '//"key2"という文字列キーにstring型の"hoge"を渡す\n' +
      'provide("key2", "hoge")</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>provideに渡すデータの型を明示的に指定していませんが、この時点でTypeScriptによって自動的に型推論が行われています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>推論される型よりも詳細に型を指定したい場合など、明示的に型を指定したい場合はジェネリックで渡します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// string | number型のデータ\n' +
      'provide&lt;string | number>("fuag", hoge)\n' +
      '\n' +
      '// number&#91;]型のデータ\n' +
      'provide&lt;number&#91;]>("fuga", fuga)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>データを供給する親コンポーネント側は以上です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="inject">文字列キーを使用した場合のinject</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>データを受け取るにはinject関数では、ジェネリックで明示的に型の指定をする必要があります。<br>明示しないとunknown型になってしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const useKey1 = inject&lt;number>("key1")\n' +
      'const useKey2 = inject&lt;string>("key2")</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="InjectionKey">InjectionKeyを使用する方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="InjectionKeyprovide">InjectionKeyを使用した場合のprovide</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>InjectionKeyというものをimportすることで、キー自体に型の定義を含めることが可能です。<br>次のように定義して利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">import { InjectionKey } from "vue"\n' +
      'const key: InjectionKey&lt;渡したいデータの型> = Symbol()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードの通り、InjectionKeyの正体はSymbol型です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>キーにデータの型が含まれているので、provideには型指定がいりません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">provide(key, hoge)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>InjectionKeyはSymbol型なので、このキーは唯一無二です。<br>つまり、別ファイルで同じコードを記述したところで別のものとなってしまいます。<br>よって、InjectionKeyを定義したファイルからexportして利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>script setup構文を用いている場合、exportが使えないので次のように分割して記述する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts">\n' +
      'import { InjectionKey } from "vue";\n' +
      'export const key: InjectionKey&lt;string> = Symbol()\n' +
      '&lt;/script>\n' +
      '\n' +
      '&lt;script setup lang="ts">\n' +
      'import { provide } from "vue"\n' +
      'provide(key, "hoge")\n' +
      '&lt;/script</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="InjectionKeyinject">InjectionKeyを使用した場合のinject</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>データを受け取るコンポーネントでは、親でexportしたキーをimportしてinject関数に渡すだけです。<br>キーに型定義が含まれているので、inject関数で型を定義する必要はありません。<br>よって、シンプルに次のようにして記述します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const useKey = inject(key)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">どちらのキーを利用すれば良いか</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">文字列キーよりもInjectionKeyを利用したほうがTypeScriptの恩恵を受けることができますし、バグの少ないコードが書けます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>というのも、文字列キーを利用した場合は次の点が問題になるからです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>同名のキーをすでに指定していもエラーは出ずに上書きされる</li><li>injectでキーを利用するとき、親で指定したキー名を開発者がタイプミスしても気づかない</li><li>injectで渡されるデータの型を、開発者が知る必要がある。</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>InjectionKeyを利用すれば、キーはimportして利用するので(エディタの機能によって)キーのタイプミスに気づくことが可能です。<br>また、キー自体に型の定義が含まれているので、injectを利用する側は型の定義を予め知る必要がありません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">使い方について補足</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">リアクティブなデータは子孫コンポーネントで変更しない</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>マストではありませんが、<strong class="yellow-line">極力変更しないことが推奨されています。</strong><br>どうしても変更する必要がある場合、次のように、リアクティブなデータを変更する責務を持つメソッドを親から提供します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>親コンポーネント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">// Component A\n' +
      '&lt;script lang="ts">\n' +
      'import { InjectionKey, Ref } from "vue";\n' +
      "export const numKey: InjectionKey&lt;Ref&lt;number>> = Symbol('num')\n" +
      "export const updateNumKey: InjectionKey&lt;(n: number) => void> = Symbol('updateNum')\n" +
      '&lt;/script>\n' +
      '\n' +
      '&lt;script setup lang="ts">\n' +
      'import ComponentB from "./ComponentB.vue"\n' +
      'import { provide, ref } from "vue"\n' +
      '\n' +
      '//リアクティブデータ\n' +
      'const num = ref(0)\n' +
      '\n' +
      '//リアクティブデータの更新メソッド\n' +
      'const updateNum = (n: number) => num.value = n\n' +
      '\n' +
      'provide(numKey, num) // リアクティブデータのprovide\n' +
      'provide(updateNumKey, updateNum) //メソッド自体をprovide\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>子孫コンポーネント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">// Component B\n' +
      '&lt;script setup lang="ts">\n' +
      'import { numKey, updateNumKey }  from "./ComponentA.vue"\n' +
      'import { inject } from "vue"\n' +
      '\n' +
      'const useNum = inject(numKey)\n' +
      'const useUpdateKey = inject(updateNumKey)\n' +
      '\n' +
      '// 何らかのイベントでリアクティブデータの変更\n' +
      'const onClick = () => useUpdateKey?.(2)\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、子孫での変更を防ぐために、provideする際にはreadonlyをつけることが推奨されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">import { readonly, provide } from "vue" \n' +
      'provide(key, readonly(hoge))</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue3において、ProvideとInjectをComposition APIとTypeScriptで解説しました。また、provideでのキー指定の方法は2種類あり、InjectionKeyを利用したほうがよりTypeScriptの恩恵を受けて記述できることも説明しました。このようにProvideとInjectでpropsのバケツリレーを簡単に防ぐことが可能です。かといって多様は禁物で、きちんとコンポーネントや状態管理の設計をして、コンポーネントの責務を考えた上で利用すべきです。</p>\n',
    date: '2022-05-22T04:19:10',
    categories: { nodes: [Array] },
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    featuredImage: { node: [Object] },
    uri: '/use-provide-and-inject-with-composition-api-and-typescript/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-2036
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
777777 false
777777 false
777777 true
777777 false
777777 false
777777 false
777777 false
777777 true
777777 false
777777 false
777777 false
777777 false
777777 false
info  - Generating static pages (14/59)
777777 false
777777 false
777777 false
777777 true
777777 false
777777 false
777777 false
101010101010101010 {
  post: {
    content: '\n' +
      '<p>PHPの列挙型について解説します。PHPの列挙型はメソッドを持つことが出来たり、インターフェースの実装、トレイトの利用も可能で様々な表現ができます。本記事は公式ドキュメントをもとに解説しますが、要点のみを抑えて簡潔な表現を心がけたり、具体例を増やすことによって分かりやすさに重点を置いています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 列挙型の概要</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 列挙型のインスタンス</a></li><li><a href="#Pure_EnumBacked_Enum"><span class="toc_number toc_depth_1">3</span> Pure EnumとBacked Enum</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">4</span> 列挙型とメソッド</a></li><li><a href="#interface"><span class="toc_number toc_depth_1">5</span> 列挙型とinterface</a></li><li><a href="#static"><span class="toc_number toc_depth_1">6</span> 列挙型とstaticメソッド</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">7</span> 列挙型と定数</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">8</span> 列挙型とトレイト</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">9</span> クラスとの違い</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">10</span> 値のリスト</a></li><li><a href="#i-8"><span class="toc_number toc_depth_1">11</span> 応用例</a></li><li><a href="#i-9"><span class="toc_number toc_depth_1">12</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">列挙型の概要</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>列挙型は、開発者が独自に定義した値のみを取る型です。enumで宣言します。<br>以下に具体例を挙げます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">&lt;?php\n' +
      'enum Size\n' +
      '{\n' +
      '    case Small;\n' +
      '    case Medium;\n' +
      '    case Large;\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Sizeというenumを宣言しました。<br>このときSizeは、caseで指定した3つの値(Small, Medium, Large)のみを取ります。<br>caseは0個以上、好きなだけ定義することが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次のようにして::演算子でアクセスします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::Small;\n' +
      '$b = Size::Large;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これが一体何の役に立つかというと、例えば、関数の引数の値を限定できて型安全になります。<br>次のコードはSizeで定義された3つのcaseのみを受け取ることが保証されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">function hoge (Size $size)\n' +
      '{\n' +
      '    var_dump($size);\n' +
      '}\n' +
      '\n' +
      'hoge(Size::Small); //OK\n' +
      '//hoge(3); //NG</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>概要を押さえたところで、PHPの列挙型について詳しく取り上げていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>(参考) 列挙型はPHP8.1からの新機能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHP8.1には他にも多くの新機能があります。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/difference-between-php7-and-php8"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/difference-between-php7-and-php8</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/php8x-thumb-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【PHP8.x】PHP8.1の新機能！PHP7との違いまとめ</div></div><div class="lkc-excerpt">PHP8.1がリリースされました。PHP7からできることが非常に増えており、PHPがますます便利になっています。この記事ではPHP7とPHP8.xの違いを、主要な新機能についてまと...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">列挙型のインスタンス</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>列挙型はクラスに似ています。::演算子で参照されたcase値は、列挙型のインスタンスとなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::Small;\n' +
      'var_dump($a instanceof Size); //bool(true)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、このインスタンスはシングルトンです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::Small;\n' +
      '$b = Size::Small;\n' +
      'var_dump($a === $b); //bool(true)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それぞれのインスタンスは読み取り専用のnameプロパティを持ちます。caseで定義した名前そのものを返します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::Small;\n' +
      '$b = Size::Medium;\n' +
      'var_dump($a->name); //string(5) "Small"\n' +
      'var_dump($b->name); //string(6) "Medium"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="Pure_EnumBacked_Enum">Pure EnumとBacked Enum</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>列挙型にはPure EnumとBacked Enumがあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>前章のように定義された列挙型をPure Enumと言います。<br>再掲します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">enum Size\n' +
      '{\n' +
      '    case Small;\n' +
      '    case Medium;\n' +
      '    case Large;\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>もう一方で、次のように定義したEnumをBacked Enumと言います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">enum Size: string\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>その特徴は、case式が右辺にスカラー値を持たせることが可能なことです。<br>int型かstring型のみを持つことができ、その型を列挙型名の後ろの：の後に記述します。<br>ただし、スカラー値はすべてユニークにする必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>valueプロパティを使うことで、定義したスカラー値を参照することが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::Small;\n' +
      '$b = Size::Medium;\n' +
      'var_dump($a->value); //string(1) "s"\n' +
      'var_dump($b->value); //string(1) "m"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、fromメソッドを用いることでスカラー値からcase名を取得することも可能です。<br>これには2つのメソッドがあり、該当case名がない場合にエラーを投げる from()メソッドと、null値を返すtryFrom()があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$a = Size::from("s");\n' +
      'var_dump($a); //enum(Size::Small)\n' +
      '\n' +
      '$b = Size::tryFrom("hoge") ?? Size::Large;\n' +
      'var_dump($b); //enum(Size::Large)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">列挙型とメソッド</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>列挙型はメソッドを持つことが可能で、インスタンスからアクセスできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      'enum Size: string\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '    \n' +
      '    //$thisで自身のcaseを返す\n' +
      '    public function thisCase(): Size\n' +
      '    {\n' +
      '        return $this;\n' +
      '    }\n' +
      '    \n' +
      '    //どのcaseでも一律に文字列を返す\n' +
      '    public function hoge(): string\n' +
      '    {\n' +
      '        return "hoge";\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      '$a = Size::Small;\n' +
      '$b = Size::Large;\n' +
      'var_dump($a->thisCase()); //enum(Size::Small)\n' +
      'var_dump($b->hoge()); //string(4) "hoge"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここで、メソッドにpublic修飾子をつけていることからわかるように、アクセス修飾子の指定が可能です。<br>しかし、<strong class="yellow-line">列挙型は継承できない</strong>ため、protectedもprivateも同じものとなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>メソッド内の$thisで自身のcaseを返すので、例えばmatch式と組み合わせてcaseによって条件分岐するメソッドの実装も可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '\n' +
      'enum Size: string\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '    \n' +
      '    //$thisで自身のcaseを返す\n' +
      '    public function price(): int\n' +
      '    {\n' +
      '        return match($this) {\n' +
      '            Size::Small => 10,\n' +
      '            Size::Medium => 100,\n' +
      '            Size::Large => 1000\n' +
      '            \n' +
      '        };\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      '\n' +
      '$a = Size::Small;\n' +
      '$b = Size::Large;\n' +
      'var_dump($a->price()); //int(10)\n' +
      'var_dump($b->price()); //int(1000)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上の例ではBacked Enumにメソッドを定義しましたが、Pure Enumでも同様のことが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="interface">列挙型とinterface</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>列挙型はinterfaceを実装することも可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '\n' +
      'interface ISize\n' +
      '{\n' +
      '    public function price(): int;\n' +
      '}\n' +
      '\n' +
      'enum Size: string implements ISize\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '    \n' +
      '    //$thisで自身のcaseを返す\n' +
      '    public function price(): int\n' +
      '    {\n' +
      '        return match($this) {\n' +
      '            Size::Small => 10,\n' +
      '            Size::Medium => 100,\n' +
      '            Size::Large => 1000\n' +
      '            \n' +
      '        };\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      '$a = Size::Small;\n' +
      '\n' +
      'function hoge(ISize $size): int\n' +
      '{\n' +
      '    return $size->price();\n' +
      '}\n' +
      '\n' +
      'var_dump(hoge($a)); //int(10)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Sizeはインターフェースを実装しており、関数hogeではポリモーフィズムがきちんと働いています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="static">列挙型とstaticメソッド</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>staticメソッドの定義もできます。<br><strong class="yellow-line">列挙型ではコンストラクタが使えない</strong>ため、代用としてstaticメソッドが使えます、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '\n' +
      'enum Size: string\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '    \n' +
      '    public static function fromPrice(int $price): static\n' +
      '    {\n' +
      '        return match(true) {\n' +
      '            $price &lt; 10 => static::Small,\n' +
      '            $price &lt; 100 => static::Medium,\n' +
      '            default => statoc.Large\n' +
      '        };\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      'var_dump(Size::fromPrice(50)); //enum(Size::Medium)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">列挙型と定数</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>constで定数の定義も可能です。自身のcaseも代入可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '\n' +
      'enum Size: string\n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '    \n' +
      '    public const Hoge = "hoge";\n' +
      '    public const Fuga = self::Small;\n' +
      '}\n' +
      '\n' +
      'var_dump(Size::Hoge); //string(4) "hoge"\n' +
      'var_dump(Size::Fuga); //enum(Size::Small)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">列挙型とトレイト</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>トレイトの利用も可能です。<br>ただし列挙型でuseされるトレイトは、プロパティを含めるとエラーが出るので注意が必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '\n' +
      'interface ISize\n' +
      '{\n' +
      '    public function price(): int;\n' +
      '}\n' +
      '\n' +
      'trait SizeTrait\n' +
      '{\n' +
      '    public function price(): int\n' +
      '    {\n' +
      '        return match($this) {\n' +
      '            Size::Small => 10,\n' +
      '            Size::Medium => 100,\n' +
      '            default => 1000\n' +
      '        };\n' +
      '    }\n' +
      '}\n' +
      '\n' +
      '\n' +
      'enum Size: string\n' +
      '{\n' +
      '    use SizeTrait;\n' +
      '    \n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '}\n' +
      '\n' +
      '$a = Size::Small;\n' +
      'var_dump($a->price()); //int(10)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-6">クラスとの違い</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今まで何度か出てきたものを含めて、クラスとの違いについて改めてまとめます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>コンストラクタ、デストラクタは禁止</li><li>継承は無い。よってprotectedもprivateも同じ。</li><li>staticまたはプロパティは禁止</li><li>シングルトンなのでcloneできない</li><li>マジックメソッドは一部のみ利用可能(__call, __callStatic, __invoke)</li><li>newでインスタンス化できない</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-7">値のリスト</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>cases()メソッドでcaseのリストを取得できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">enum Size: string \n' +
      '{\n' +
      '    case Small = "s";\n' +
      '    case Medium = "m";\n' +
      '    case Large = "l";\n' +
      '}\n' +
      '\n' +
      'var_dump(Size::cases()); \n' +
      '/**\n' +
      ' * array(3) {\n' +
      ' * &#091;0]=>\n' +
      ' *enum(Size::Small)\n' +
      ' * &#091;1]=>\n' +
      ' * enum(Size::Medium)\n' +
      ' * &#091;2]=>\n' +
      ' * enum(Size::Large)\n' +
      ' *}\n' +
      ' */</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-8">応用例</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>最後に、公式ドキュメントで紹介されている応用例を紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      'enum UserStatus: string\n' +
      '{\n' +
      "    case Pending = 'P';\n" +
      '    case Active = '... 882 more characters,
    date: '2022-05-21T04:23:33',
    categories: { nodes: [Array] },
    title: '【PHP8.1】列挙型(Enum)について徹底解説',
    featuredImage: { node: [Object] },
    uri: '/how-to-use-enum-in-php8-1/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>TypeScript、あるいはJavaScriptで簡単に画像処理を行う方法を紹介します。<strong>画像処理の知識も不要でライブラリも使いません。</strong>そのためにCSSを利用し、プロパティ値をスクリプトから利用することになります。<br>それでは解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#TypeScriptJavaScript"><span class="toc_number toc_depth_1">1</span> TypeScript、JavaScriptで画像処理</a></li><li><a href="#CSS"><span class="toc_number toc_depth_1">2</span> CSSフィルタについて</a><ul><li><a href="#CSS-2"><span class="toc_number toc_depth_2">2.1</span> CSSフィルタとは</a></li><li><a href="#CSS-3"><span class="toc_number toc_depth_2">2.2</span> CSSフィルタのコードの例</a></li><li><a href="#i"><span class="toc_number toc_depth_2">2.3</span> スクリプトで書く意味</a></li></ul></li><li><a href="#CSS-4"><span class="toc_number toc_depth_1">3</span> 使えるCSSフィルタの種類</a><ul><li><a href="#CSS-5"><span class="toc_number toc_depth_2">3.1</span> CSSフィルタ一覧</a></li></ul></li><li><a href="#CSS-6"><span class="toc_number toc_depth_1">4</span> CSSフィルタの使用例</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">4.1</span> 基本的な使用例</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">4.2</span> 応用例</a></li></ul></li><li><a href="#mix-blend-mode"><span class="toc_number toc_depth_1">5</span> mix-blend-modeについて</a><ul><li><a href="#mix-blend-mode-2"><span class="toc_number toc_depth_2">5.1</span> mix-blend-modeとは</a></li><li><a href="#mix-blend-mode-3"><span class="toc_number toc_depth_2">5.2</span> mix-blend-modeのコード例</a></li></ul></li><li><a href="#mix-blend-mode-4"><span class="toc_number toc_depth_1">6</span> mix-blend-modeの種類</a></li><li><a href="#mix-blend-mode-5"><span class="toc_number toc_depth_1">7</span> mix-blend-modeの使用例</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">8</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="TypeScriptJavaScript">TypeScript、JavaScriptで画像処理</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以前、<a href="https://tekrog.com/image-processing-by-ts/">TypeScriptでバリバリ画像処理</a>を行う方法を紹介しましたが、簡単なフィルタの処理だけであればそこまでする必要はありません。スクリプト側からCSSのプロパティを利用するだけで事足ります。この方法ではたったの数行で画像処理のコードが書けてしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li><strong>①CSSフィルタを利用する方法</strong></li><li><strong>②mix-blend-modeを利用する方法</strong></li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>の2つを紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>なお、この記事で紹介する方法だけでは行いたい処理ができないならば、<strong>ライブラリの導入を検討してみてください。</strong>ライブラリならば、使い方さえ知れば様々な画像処理が可能です。<br><strong class="yellow-line">次の記事では、Jimpというライブラリで画像処理を行う方法を解説しています。</strong></p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/jimp-with-typescript-on-browser"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/jimp-with-typescript-on-browser</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/05/thumb-ijimp-with-typescript-on-browser-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【Jimp】TypeScriptでブラウザ上の画像処理【ライブラリ使用】</div></div><div class="lkc-excerpt">JavaScriptの画像処理ライブラリ「Jimp」をTypeScriptで使い、ブラウザ上で画像処理を行う方法を説明します。Jimpは画像処理のアルゴリズムを知らない人も簡単に画像処...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="CSS">CSSフィルタについて</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="CSS-2">CSSフィルタとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>CSSのfilterプロパティで指定できるフィルタのことです。10種類近く用意されており、img要素に適用することができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="CSS-3">CSSフィルタのコードの例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、画像をグレースケール(白黒)に変換するコードは次のように2行で書けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">const image = document.querySelector&lt;HTMLImageElement&gt;('.input-image')! //imgのDOM取得\n` +
      'image.style.filter = `grayscale(100%)` //filterプロパティの変更</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">imgタグのDOMを取得して、styleのfilterの値を変更するだけです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">スクリプトで書く意味</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これだけの処理なら、はじめからCSSファイルでfilterプロパティを指定するのと変わりません。<br>ではなぜスクリプトで書くのか？それは、<strong>フィルターの種類やパラメータを後から動的に変更することが可能になり、結果を見ながらマウス操作だけ(あるいはタッチ操作だけ)で画像処理が可能になるからです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="CSS-4">使えるCSSフィルタの種類</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="CSS-5">CSSフィルタ一覧</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>使えるフィルタの一覧を紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>blur</th><td>ぼかし</td></tr><tr><th>brightness</th><td>明度(明るさ)を変更</td></tr><tr><th>contrast</th><td>コントラストを変更</td></tr><tr><th>drop-shadow</th><td>画像に影を落とす</td></tr><tr><th>grayscale</th><td>グレースケールに変換</td></tr><tr><th>hue-rotate</th><td>色相を変更</td></tr><tr><th>invert</th><td>ネガポジ反転</td></tr><tr><th>opacity</th><td>透明度の変更</td></tr><tr><th>saturate</th><td>彩度(鮮やかさ)の変更</td></tr><tr><th>sepia</th><td>セピア色に変更</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それぞれのフィルタの使用例と結果を見ていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="CSS-6">CSSフィルタの使用例</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">基本的な使用例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>blur</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>0~任意の数字をピクセル値で指定します。指定したピクセル分ぼかします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `blur(5px)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/blur-goma-1024x509.jpg" alt="" class="wp-image-1921" width="512" height="255" srcset="https://tekrog.com/wp-content/uploads/2022/04/blur-goma-1024x509.jpg 1024w, https://tekrog.com/wp-content/uploads/2022/04/blur-goma-300x149.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/blur-goma-768x382.jpg 768w, https://tekrog.com/wp-content/uploads/2022/04/blur-goma-1536x763.jpg 1536w, https://tekrog.com/wp-content/uploads/2022/04/blur-goma.jpg 1662w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>brightness</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>0~任意の数値で指定します。指定した数値の倍率だけ明るくします。<br>ですので、1未満だと暗く、1以上で明るくなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `brightness(2)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/brightness-goma-1024x509.jpg" alt="" class="wp-image-1922" width="512" height="255" srcset="https://tekrog.com/wp-content/uploads/2022/04/brightness-goma-1024x509.jpg 1024w, https://tekrog.com/wp-content/uploads/2022/04/brightness-goma-300x149.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/brightness-goma-768x382.jpg 768w, https://tekrog.com/wp-content/uploads/2022/04/brightness-goma-1536x763.jpg 1536w, https://tekrog.com/wp-content/uploads/2022/04/brightness-goma.jpg 1662w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>contrast</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>0~任意の数値で指定します。指定した数値の倍率だけコントラストを強めます。<br>ですので、1未満だとコントラストが下がることになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `contrast(1.5)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/contrast-goma-1024x509.jpg" alt="" class="wp-image-1923" width="512" height="255" srcset="https://tekrog.com/wp-content/uploads/2022/04/contrast-goma-1024x509.jpg 1024w, https://tekrog.com/wp-content/uploads/2022/04/contrast-goma-300x149.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/contrast-goma-768x382.jpg 768w, https://tekrog.com/wp-content/uploads/2022/04/contrast-goma-1536x763.jpg 1536w, https://tekrog.com/wp-content/uploads/2022/04/contrast-goma.jpg 1662w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>drop-shadow</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>drop-shadow(x方向のずれ  y方向のずれ  ぼかし半径)で影を落とします。<br>3つのそれぞれのパラメータはピクセル値で指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `drop-shadow(30px 30px 20px)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma-1024x557.jpg" alt="" class="wp-image-1924" width="512" height="279" srcset="https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma-1024x557.jpg 1024w, https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma-300x163.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma-768x418.jpg 768w, https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma-1536x836.jpg 1536w, https://tekrog.com/wp-content/uploads/2022/04/drop-shadow-goma.jpg 1734w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>grayscale</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>0~1でグレースケールの度合いを決めます。<br>0は元画像、1は完全にグレースケールとなります。0~1の間で、1になるにつれて彩度が下がります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `grayscale(1)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma-1024x509.jpg" alt="" class="wp-image-1925" width="512" height="255" srcset="https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma-1024x509.jpg 1024w, https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma-300x149.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma-768x382.jpg 768w, https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma-1536x763.jpg 1536w, https://tekrog.com/wp-content/uploads/2022/04/grayscale-goma.jpg 1662w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>hue-rotate</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>0~360degで色相を変更します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.style.filter = `hue-rotate(240deg)`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/hue-rotate-goma-1024x509.jpg" alt="" '... 9268 more characters,
    date: '2022-04-06T02:58:27',
    categories: { nodes: [Array] },
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    featuredImage: { node: [Object] },
    uri: '/easy-image-processing-by-ts/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Redux ToolKitで提供されているSliceを用いると、Reduxを使う際、ActionとReducerを1つにまとめて記述できます。また、ステートの更新の際にイミュータブルでない書き方をしても値の更新がされます。そんな何かと便利なSliceの使い方について、最小限の構成でシンプルに紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Redux_ToolKit"><span class="toc_number toc_depth_1">1</span> Redux ToolKitの準備</a></li><li><a href="#Slice"><span class="toc_number toc_depth_1">2</span> Sliceファイルの定義</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">2.1</span> ステートの例</a></li><li><a href="#Slice-2"><span class="toc_number toc_depth_2">2.2</span> Sliceの書き方</a></li></ul></li><li><a href="#Store"><span class="toc_number toc_depth_1">3</span> Storeファイル</a></li><li><a href="#Component"><span class="toc_number toc_depth_1">4</span> Componentファイル</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="Redux_ToolKit">Redux ToolKitの準備</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Sliceを使うにはRedux ToolKitが必要です。コンソールから追加します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm install @reduxjs/toolkit</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Slice">Sliceファイルの定義</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>冒頭でも述べましたが、<strong class="yellow-line">SliceとはReducerとActionを組み合わせたものです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">ステートの例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次の「string型のname」と「number型のage」のステートを更新する処理を考え、Sliceの具体的な使用方法について解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">interface PersonState {\n' +
      '  name: string\n' +
      '  age: number\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>初期値を適当に決めます。なお、後から別ファイルで利用するためexportしておきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">export const initialState: PersonState = {\n' +
      "  name: 'taro',\n" +
      '  age: 20\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このstateに対して2つのactionを定義します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>① ageを+1する</li><li>② 名前を入力された値に変える</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Slice-2">Sliceの書き方</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上記2つの操作に対するSliceは次のように記述します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">const PersonSlice = createSlice({\n' +
      "  name: 'person',\n" +
      '  initialState,\n' +
      '  reducers: { //リデューサ＋アクション\n' +
      '    incrementAge(state) {\n' +
      '      state.age++\n' +
      '    },\n' +
      '    changeName: (state, action: PayloadAction&lt;string>) =>{\n' +
      '      state.name = action.payload\n' +
      '    }\n' +
      '  }\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>nameにこのスライスの名前、<br>initialStateで初期値を設定し、<br>reducersでリデューサとアクションを同時に記述しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>1つめの incrementAgeはageを+1する処理です。</li><li>2つめのchangeNameは、nameをdispatchされた値に変更する処理です。</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードのように、第一引数にはstate、第二引数にはactionを指定します。actionはPayloadAction&lt;payloadの型&gt;で型付けしています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そして、コードのように<strong class="yellow-line">イミュータブルな値の操作でstateの更新が可能</strong>となっています。これは内部的にImmerという「イミュータブルな操作をミュータブルな操作に変換する」ライブラリを使っているので可能となっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>最後にこのSliceからリデューサとアクションを切り離します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-tsx">//アクションの切り出し\n' +
      'export const { incrementAge, changeName } = PersonSlice.actions\n' +
      '\n' +
      '//リデューサの切り出し\n' +
      'export const PersonReducer = PersonSlice.reducer</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上をまとめると、Sliceのファイルは次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-tsx">import { createSlice, PayloadAction } from '@reduxjs/toolkit'\n` +
      '\n' +
      'interface PersonState {\n' +
      '  name: string\n' +
      '  age: number\n' +
      '}\n' +
      '\n' +
      '//初期値\n' +
      'export const initialState: PersonState = {\n' +
      "  name: 'taro',\n" +
      '  age: 20\n' +
      '}\n' +
      '\n' +
      '//スライス\n' +
      'const PersonSlice = createSlice({\n' +
      "  name: 'person',\n" +
      '  initialState,\n' +
      '  reducers: { //リデューサ＋アクション\n' +
      '    incrementAge(state) {\n' +
      '      state.age++\n' +
      '    },\n' +
      '    changeName: (state, action: PayloadAction&lt;string>) =>{\n' +
      '      state.name = action.payload\n' +
      '    }\n' +
      '  }\n' +
      '})\n' +
      '\n' +
      '//アクションの切り出し\n' +
      'export const { incrementAge, changeName } = PersonSlice.actions\n' +
      '\n' +
      '//リデューサの切り出し\n' +
      'export const PersonReducer = PersonSlice.reducer</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>たったこれだけでReducerとActionに相当する処理の記述が終わりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="Store">Storeファイル</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Redux ToolKitのconfigureStoreを使うと簡単に記述できます。<br>使用方法を次のコードに示します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">import { configureStore } from "@reduxjs/toolkit"\n' +
      'import { initialState as personInitialState, PersonReducer } from "./PersonSlice"\n' +
      '\n' +
      'export class RootState {\n' +
      '  person = personInitialState\n' +
      '}\n' +
      '\n' +
      '//リデューサ\n' +
      'const reducer = {\n' +
      '  person: PersonReducer\n' +
      '}\n' +
      '\n' +
      '//ストア\n' +
      'const store = configureStore({\n' +
      '  reducer\n' +
      '})\n' +
      '\n' +
      'export default store</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Component">Componentファイル</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このSliceを利用するコンポーネントの例を記載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-tsx">import { FC, useState } from 'react'\n` +
      "import { useSelector, useDispatch } from 'react-redux'\n" +
      'import { incrementAge, changeName } from "./PersonSlice"\n' +
      'import { RootState } from "./Store"\n' +
      '\n' +
      'const App: FC = () =&gt; {\n' +
      '  // ストアからstate取得\n' +
      '  const person = useSelector((state: RootState) =&gt; state.person )\n' +
      '  // dispatch\n' +
      '  const dispatch = useDispatch()\n' +
      '\n' +
      '  //フォームの入力値\n' +
      '  const [name, setName] = useState(person.name)\n' +
      '\n' +
      '  //dispatchはJSX内で行っている\n' +
      '  return (\n' +
      '    &lt;&gt;\n' +
      '      &lt;p&gt;name: {person.name}&lt;/p&gt;\n' +
      '      &lt;p&gt;age: {person.age}&lt;/p&gt;\n' +
      '\n' +
      '      {/* incrementAgeのdispatch */}\n' +
      '      &lt;button onClick={() =&gt; dispatch(incrementAge())}&gt;age + 1&lt;/button&gt;\n' +
      '\n' +
      '      {/* changeNameのdispatch */}\n' +
      '      &lt;input  value={name} onChange={e =&gt; setName(e.target.value)}/&gt;\n' +
      '      &lt;button onClick={() =&gt; dispatch(changeName(name))}&gt;change name&lt;/button&gt;\n' +
      '    &lt;/&gt;\n' +
      '  )\n' +
      '}\n' +
      '\n' +
      'export default App</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上がSliceを使う単純な例になります。このようにとてもシンプルに分かりやすい記述ができます。<br>実際は他のステートを利用したりより複雑な記述が必要になるかと思いますが、この基本さえ抑えておけば応用が利きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>より複雑な使い方は、公式ドキュメントを参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://redux-toolkit.js.org/api/createSlice" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=redux-toolkit.js.org" alt="" width=16 height=16 /><div class="lkc-domain">redux-toolkit.js.org</div>&nbsp;<div class="lkc-url-info">https://redux-toolkit.js.org/api/createSlice</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/pz-linkcard/cache/3eb7d47a2c77304c216702f6ca587ef4dbcc858fb78e5c7822507561d0fad420.jpeg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">createSlice | Redux Toolkit</div></div><div class="lkc-excerpt"> </div></div><div class="clear"></div></div></a></div></div>\n',
    date: '2022-03-28T06:59:50',
    categories: { nodes: [Array] },
    title: '【React】Sliceを用いたReduxの簡単な実装方法',
    featuredImage: { node: [Object] },
    uri: '/how-to-use-slice/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1921
203 wp-image-1922
203 wp-image-1923
203 wp-image-1924
203 wp-image-1925
203 wp-image-1926
203 wp-image-1927
203 wp-image-1929
203 wp-image-1930
203 wp-image-1931
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1932
203 wp-image-1934
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
[
  {
    title: '【React】Sliceを用いたReduxの簡単な実装方法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-redux-slice.png'
  },
  {
    title: '【解決方法】エラー Cannot read properties of undefined (reading ‘transformFie’)【React Native】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thunm-react-native-error.png'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>React Nativeの環境構築周りで起こったエラーとその対処法を備忘録として残します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>扱うエラー</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>Metro has encountered an error: Cannot read properties of undefined (reading &#8216;transformFie&#8217;)</li><li>シュミレータが新しいアプリのファイルを参照しない。前に作ったアプリのファイルを参照している。</li><li>Metro Bundlerの強制終了</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Metro_has_encountered_an_error_Cannot_read_properties_of_undefined_reading_8216transformFie8217"><span class="toc_number toc_depth_1">1</span> Metro has encountered an error: Cannot read properties of undefined (reading &#8216;transformFie&#8217;)</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">1.1</span> 原因</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">1.2</span> ダウングレード方法</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">2</span> シュミレータが新しいアプリのファイルを参照しない。昔作ったファイルを参照している。</a></li><li><a href="#Metro_Bundler"><span class="toc_number toc_depth_1">3</span> Metro Bundlerの強制終了</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="Metro_has_encountered_an_error_Cannot_read_properties_of_undefined_reading_8216transformFie8217">Metro has encountered an error: Cannot read properties of undefined (reading &#8216;transformFie&#8217;)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">原因</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>nodeのバージョンによるエラーです。<br>エラーが出たバージョンはv17.xで、v16.13.0にダウングレードすることによって問題が解決しました。(2022年3月28日時点)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">ダウングレード方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Macユーザの方は、nodebrewを使えばnodeのバージョンを簡単に変更できます</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>nodebrewを使ったダウングレード方法</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>nodebrewが無い人はインストールしましょう。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">brew uninstall --force node\n' +
      'brew install nodebrew</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いてパスを通します。<br>シェルはbashを使ってるなら~/.bash_profileに、zshを使ってるなら~/.zprofileに</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-shell">echo 'export PATH=$HOME/.nodebrew/current/bin:$PATH' >> ~/.bash_profile\n` +
      'nodebrew setup\n' +
      'source ~/.bash_profile</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>シェルの種類は、$が表示されていればbash、%が表示されていればzshを使用しています</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>v16.13.0をインストールします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">nodebrew install-binary v16.13.0\n' +
      'nodebrew use v10.15.0</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>バージョン確認をしてv16.13.0ならOK</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">node -v</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>参考:</strong></p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://qiita.com/mame_daifuku/items/373daf5f49ee585ea498" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=qiita.com" alt="" width=16 height=16 /><div class="lkc-domain">Qiita</div>&nbsp;<div class="lkc-url-info">https://qiita.com/mame_daifuku/items/373daf5f49ee585ea498</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="https://s.wordpress.com/mshots/v1/https%3A%2F%2Fqiita.com%2Fmame_daifuku%2Fitems%2F373daf5f49ee585ea498?w=200" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">NodebrewでNodeをインストールする - Qiita</div></div><div class="lkc-excerpt">参考リンク公式：GitHub - hokaccha/nodebrew: Node.js version managernodebrewで複数バージョンのnodeを一元管理する。 | ParsetreenodebrewでN...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">シュミレータが新しいアプリのファイルを参照しない。昔作ったファイルを参照している。</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>キャッシュの問題です。キャッシュを一通りクリアします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>参考:</strong></p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://qiita.com/krile136/items/3f74ea94bac009bb8b27" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=qiita.com" alt="" width=16 height=16 /><div class="lkc-domain">Qiita</div>&nbsp;<div class="lkc-url-info">https://qiita.com/krile136/items/3f74ea94bac009bb8b27</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="https://s.wordpress.com/mshots/v1/https%3A%2F%2Fqiita.com%2Fkrile136%2Fitems%2F3f74ea94bac009bb8b27?w=200" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">React Nativeでキャッシュをクリアしよう - Qiita</div></div><div class="lkc-excerpt">はじめにReact Nativeで開発をしていて、アプリが複雑になってくるとキャッシュが悪さをして思い通りの動きをしないことがあります。そこで「キャッシュをクリアしてビ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="Metro_Bundler">Metro Bundlerの強制終了</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>前節の通りキャッシュをクリアしようとしてもMetro Bundlerがどこかで起動しているために、エラーが出てキャッシュをクリア出来ない場合があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>その際、コンソールにはエラー「listen EADDRINUSE: address already in use :::8081」と、Metro Bundlerが使用中のポート番号が表示されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これはReact Nativeに限った話ではなくUNIXコマンドの話ですが、参考までにこのポートを利用しているプロセスの強制終了の方法を載せます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずはポート番号を使っているプロセスのIDを調べます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">lsof -i -P | grep ポート番号</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そして、そのプロセスIDを強制終了します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">kill -9 プロセスID</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これでMetro Bundlerをリフレッシュできるはずです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>React Nativeで出るエラー「Metro has encountered an error: Cannot read properties of undefined (reading &#8216;transformFie&#8217;)」から解決に向けて、一連の解決方法を紹介しました。</p>\n',
    date: '2022-03-28T06:54:37',
    categories: { nodes: [Array] },
    title: '【解決方法】エラー Cannot read properties of undefined (reading ‘transformFie’)【React Native】',
    featuredImage: { node: [Object] },
    uri: '/react-native-error-resolution/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
[
  {
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php7-8.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>この記事ではstyled-componentsをTypeScriptで利用する方法と代表的な機能をまとめています。変数、propsやattrsの使用方法、必要な型定義なども説明します。これら基本機能を利用すれば、プログラマブルに、条件分岐等を利用して動的にスタイリングを変更する記述も可能で、拡張性の高いコンポーネントが作成できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> インストール</a></li><li><a href="#HTML"><span class="toc_number toc_depth_1">2</span> 基本的な使い方〜HTMLタグを元にスタイリング〜</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">3</span> 外部の変数を参照する</a></li><li><a href="#props"><span class="toc_number toc_depth_1">4</span> propsを受け取る</a></li><li><a href="#styled-component"><span class="toc_number toc_depth_1">5</span> styled-componentの継承(拡張)</a></li><li><a href="#asHTML"><span class="toc_number toc_depth_1">6</span> 【as】HTMLタグの種類を変更</a></li><li><a href="#styled"><span class="toc_number toc_depth_1">7</span> カスタムコンポーネントのstyled</a><ul><li><a href="#className"><span class="toc_number toc_depth_2">7.1</span> classNameの型定義に注意</a></li></ul></li><li><a href="#styled-componentsprops"><span class="toc_number toc_depth_1">8</span> styled-componentsに渡せるpropsの種類</a></li><li><a href="#attrsstyled-components"><span class="toc_number toc_depth_1">9</span> 【attrs】styled-componentsでプロパティを定義</a></li><li><a href="#keyframes"><span class="toc_number toc_depth_1">10</span> 【keyframes】アニメーション</a></li><li><a href="#css8220css"><span class="toc_number toc_depth_1">11</span> 【css&#8220;】独立したcssブロック</a><ul><li><a href="#propscss"><span class="toc_number toc_depth_2">11.1</span> propsとcssを使用した条件分岐によるスタイリング</a></li></ul></li><li><a href="#createGlobalStyle"><span class="toc_number toc_depth_1">12</span> 【createGlobalStyle】グローバルスタイルの定義</a></li><li><a href="#styled-components"><span class="toc_number toc_depth_1">13</span> 他のstyled-componentsを参照</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">14</span> テーマ</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">15</span> まとめ</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">16</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="i">インストール</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>npmでのインストール：</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm install --save styled-components @types/styled-components</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Typescriptで利用する場合は@types/styled-componentsも必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="HTML">基本的な使い方〜HTMLタグを元にスタイリング〜</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>もっとも基本的な使い方は、レンダリングするHTMLタグを指定してスタイルを記述する方法です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>レンダリングするコンポーネントの外側で定義することに注意が必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">// &lt;h1&gt;タグをレンダリングする&lt;Title&gt;コンポーネント\n' +
      'const Title = styled.h1`\n' +
      '  font-size: 26px;\n' +
      '  color: red;\n' +
      '  /* このようにCSSを記述していく */\n' +
      '`\n' +
      '\n' +
      '// &lt;section&gt;タグをレンダリングする&lt;Wrapper&gt;コンポーネント\n' +
      'const Wrapper = styled.section`\n' +
      '  /* スタイリング */\n' +
      '`\n' +
      '\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Wrapper&gt;\n' +
      '      &lt;Title&gt;Hoge&lt;/Title&gt;\n' +
      '    &lt;/Wrapper&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次のようにSCSSライクに記述することも出来ます。&amp;が使えるのでhoverなども楽にかけます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">const Link = styled.a`\n' +
      '  font-weight: bold;\n' +
      '  margin: 10px;\n' +
      '  span {\n' +
      '    color: red;    \n' +
      '  }\n' +
      '  &amp;:hover {\n' +
      '    text-decoration: underline;\n' +
      '  }\n' +
      '`</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-2">外部の変数を参照する</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>外部で定義されている変数を利用することが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">const linkColor = "green"\n' +
      '// linkColorを参照\n' +
      'const Link = styled.a`\n' +
      '  color: ${linkColor}\n' +
      '`\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Link&gt;link&lt;/Link&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/44d24a980fb4b32911e534d170ea8f36.png" alt="" class="wp-image-2074" width="66" height="35"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="props">propsを受け取る</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>styled-componentはpropsを受け取ることが可能で、propsの値によってスタイリングを変更することが可能です。<br>その際、TypeScriptではpropsの型をジェネリックで渡します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">// styled-componentのprops\n' +
      'type ButtonProps = {\n' +
      '  primary?: boolean\n' +
      '}\n' +
      '// propsを受け取るstyled-component\n' +
      'const Button = styled.button&lt;ButtonProps&gt;`\n' +
      "  background-color: ${({ primary }) =&gt; primary ? 'blue' : 'yellow'} ;\n" +
      "  color:  ${({ primary }) =&gt; primary ? 'white' : 'black'} ;\n" +
      '`\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Wrapper&gt;\n' +
      '      &lt;Button&gt;Normal&lt;/Button&gt;\n' +
      '      &lt;Button primary&gt;Primary&lt;/Button&gt;\n' +
      '    &lt;/Wrapper&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/6254e4dfa24abcbde229672554af7196.png" alt="" class="wp-image-2050" width="434" height="113" srcset="https://tekrog.com/wp-content/uploads/2022/05/6254e4dfa24abcbde229672554af7196.png 868w, https://tekrog.com/wp-content/uploads/2022/05/6254e4dfa24abcbde229672554af7196-300x78.png 300w, https://tekrog.com/wp-content/uploads/2022/05/6254e4dfa24abcbde229672554af7196-768x200.png 768w" sizes="(max-width: 434px) 100vw, 434px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="styled-component">styled-componentの継承(拡張)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>すでにあるコンポーネントを継承、拡張することが可能です。<br>新しいスタイルを追加したり、既存スタイルのオーバーライドも可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">const Button = styled.button`\n' +
      '  color: white;\n' +
      '  background-color: red;\n' +
      '`\n' +
      '\n' +
      '// Buttonの拡張\n' +
      'const ExtendedButton = styled(Button)`\n' +
      '  color: #000;\n' +
      '  background-color: #fff; \n' +
      '  border-radius: 0;\n' +
      '`\n' +
      '\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Wrapper&gt;\n' +
      '      &lt;Button&gt;Button&lt;/Button&gt;\n' +
      '      &lt;Extendedbutton&gt;Extended&lt;/Extendedbutton&gt;\n' +
      '    &lt;/Wrapper&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/1c9b2300b61ef7ebd9742a5fb1a3692f.png" alt="" class="wp-image-2051" width="421" height="98" srcset="https://tekrog.com/wp-content/uploads/2022/05/1c9b2300b61ef7ebd9742a5fb1a3692f.png 842w, https://tekrog.com/wp-content/uploads/2022/05/1c9b2300b61ef7ebd9742a5fb1a3692f-300x70.png 300w, https://tekrog.com/wp-content/uploads/2022/05/1c9b2300b61ef7ebd9742a5fb1a3692f-768x179.png 768w" sizes="(max-width: 421px) 100vw, 421px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="asHTML">【as】HTMLタグの種類を変更</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>asプロパティでHTMLタグを指定すると、レンダリングされるHTMLタグが変わります。<br>上記の例は&lt;button&gt;タグでレンダリングされていましたが、これを&lt;span&gt;や&lt;a&gt;タグ等に変換することが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">// &lt;Button&gt;は &lt;span&gt;でレンダリングされる\n' +
      '// &lt;ExtendedButton&gt;は &lt;a&gt;でレンダリングされる\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Wrapper&gt;\n' +
      '      &lt;Button as="span"&gt;Button&lt;/Button&gt; \n' +
      '      &lt;ExtendedButton as="a"&gt;Extended&lt;/ExtendedButton&gt;\n' +
      '    &lt;/Wrapper&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>自作のコンポーネントに変更することも可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">type Props = {\n' +
      '  children: string\n' +
      '}\n' +
      'const UpperdButton: FC&lt;Props&gt; = ({\n' +
      '  children\n' +
      '}) =&gt; (\n' +
      '  &lt;Button children={children.toUpperCase()} /&gt;\n' +
      ')\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;Wrapper&gt;\n' +
      '      &lt;Button&gt;Button&lt;/Button&gt; \n' +
      '      &lt;Button as={UpperdButton}&gt;Button&lt;/Button&gt;\n' +
      '    &lt;/Wrapper&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/f86560f99218bc6bccc611002df30de2.png" alt="" class="wp-image-2053" width="415" height="96" srcset="https://tekrog.com/wp-content/uploads/2022/05/f86560f99218bc6bccc611002df30de2.png 830w, https://tekrog.com/wp-content/uploads/2022/05/f86560f99218bc6bccc611002df30de2-300x69.png 300w, https://tekrog.com/wp-content/uploads/2022/05/f86560f99218bc6bccc611002df30de2-768x178.png 768w" sizes="(max-width: 415px) 100vw, 415px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="styled">カスタムコンポーネントのstyled</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="className">classNameの型定義に注意</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>作ったコンポーネントにスタイルを当てることも可能です。<br>その際、<strong>スタイルを当てるコンポーネントはstring?型のclassNameプロパティを受け取れるようにする必要があります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">// className?と?をつけることに注意\n' +
      'type Props = {\n' +
      '  className?: string\n' +
      '  children: string\n' +
      '}\n' +
      '// スタイルをあてるコンポーネント\n' +
      'const Link: FC&lt;Props&gt; = ({\n' +
      '  className,\n' +
      '  children\n' +
      '}) =&gt; (\n' +
      '  &lt;a className={className}&gt;\n' +
      '    { children }\n' +
      '  &lt;/a&gt;\n' +
      ')\n' +
      '// スタイリングされたコンポーネント\n' +
      'const StyledLink = styled(Link)`\n' +
      '  color: red;\n' +
      '  font-weight: bold;\n' +
      '`\n' +
      'export const App: FC = () =&gt;  {\n' +
      '  return (\n' +
      '    &lt;StyledLink&gt;\n' +
      '      styled link\n' +
      '    &lt;/StyledLink&gt;\n' +
      '  )\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/05/e9f2e6bb32fbc1c4efd14c833d7af64c.png" alt="" class="wp-image-2070" width="163" height="38" srcset="https://tekrog.com/wp-content/uploads/2022/05/e9f2e6bb32fbc1c4efd14c833d7af64c.png 326w, https://tekrog.com/wp-content/uploads/2022/05/e9f2e6bb32fbc1c4efd14c833d7af64c-300x70.png 300w" sizes="(max-width: 163px) 100vw, 163px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="styled-componentsprops">styled-componentsに渡せるpropsの種類</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>styledの対象がHTML要素ならば、そのHTML要素がそもそも受け取るプロパティはstyled-componentsになっても受け取ることが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、styled.inputはinputが受け取ることが出来る「type」や「placeholder」などのプロパティを受け取ることが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-tsx">const StyledInput = styled.input`\n' +
      '  padding: 0.5em 1em;\n' +
      '  margin: 0;\n' +
      '  border: 1px solid #ccc'... 9846 more characters,
    date: '2022-05-23T07:07:10',
    categories: { nodes: [Array] },
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    featuredImage: { node: [Object] },
    uri: '/styled-components/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【React】Sliceを用いたReduxの簡単な実装方法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-redux-slice.png'
  },
  {
    title: '【解決方法】エラー Cannot read properties of undefined (reading ‘transformFie’)【React Native】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thunm-react-native-error.png'
  }
]
203 wp-image-2074
203 wp-image-2050
203 wp-image-2051
203 wp-image-2053
203 wp-image-2070
203 wp-image-2069
203 wp-image-2052
203 wp-image-2072
203 wp-image-2073
203 wp-image-2075
203 wp-image-2086
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue3、Laravel、Pythonを用いてWebスクレイピングを行う簡単なSPAを試作しました。その時の備忘録です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 構成</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> 構成と説明</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">1.2</span> なぜこの構成か？</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">2</span> 作成するもの</a><ul><li><a href="#i-5"><span class="toc_number toc_depth_2">2.1</span> 作成するアプリの説明</a></li></ul></li><li><a href="#i-6"><span class="toc_number toc_depth_1">3</span> 表示画面とコード</a><ul><li><a href="#i-7"><span class="toc_number toc_depth_2">3.1</span> 画面表示</a></li><li><a href="#i-8"><span class="toc_number toc_depth_2">3.2</span> コード</a></li></ul></li><li><a href="#i-9"><span class="toc_number toc_depth_1">4</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="i">構成</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">構成と説明</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/03/vue-lara-py-1024x378.png" alt="" class="wp-image-1807" width="512" height="189" srcset="https://tekrog.com/wp-content/uploads/2022/03/vue-lara-py-1024x378.png 1024w, https://tekrog.com/wp-content/uploads/2022/03/vue-lara-py-300x111.png 300w, https://tekrog.com/wp-content/uploads/2022/03/vue-lara-py-768x283.png 768w, https://tekrog.com/wp-content/uploads/2022/03/vue-lara-py.png 1295w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol class="ulOnly"><li>①VueからLaravelサーバにGETリクエスト</li><li>②LaravelがPythonを実行</li><li>③Pythonでスクレイピング</li><li>④LaravelがPythonの出力をJSONにしてVueへ返す</li><li>⑤Vueで結果を表示</li></ol>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">なぜこの構成か？</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>将来的にこの構成で機械学習のWebアプリを作りたい。そのためのテストを兼ねている。</li><li>サーバにPythonを用いてないのは、学習コストとLaravelの需要。</li><li>Vue、Laravel、Pythonそれぞれのスキルアップを図りたい。</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">作成するもの</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">作成するアプリの説明</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このブログの任意の記事のURLを入力してサーバにリクエストすると、サブタイトルの一覧を返却するSPA。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-6">表示画面とコード</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-7">画面表示</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/03/scraping-image.png" alt="" class="wp-image-1808" width="507" height="481" srcset="https://tekrog.com/wp-content/uploads/2022/03/scraping-image.png 676w, https://tekrog.com/wp-content/uploads/2022/03/scraping-image-300x284.png 300w" sizes="(max-width: 507px) 100vw, 507px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-8">コード</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要件を満たす最低限のコードのみ実装。<br>ディレクトリ階層も適当。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Vue3</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>出力はローディング画面と得られた結果のみ。<br>エラーハンドリングはなし。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>script</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup>\n' +
      "import axios from 'axios';\n" +
      "import { ref } from 'vue';\n" +
      '\n' +
      "const text = ref('https://tekrog.com/vue3-ts-quickmanual/')\n" +
      'const data = ref&lt;string&#091;]>()\n' +
      'const isLoading = ref(false)\n' +
      '\n' +
      'const onclick = async () => {\n' +
      '  isLoading.value = true\n' +
      '  const response = await axios.get&lt;string&#091;]>(`http://localhost:8000/api/titles/?url=${text.value}`)\n' +
      '  isLoading.value = false\n' +
      '  data.value = response.data\n' +
      '}\n' +
      '&lt;/script>\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>temlate</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template>\n' +
      '  &lt;h1>スクレイピング&lt;/h1>\n' +
      '  &lt;p>\n' +
      '    &lt;label>\n' +
      '      URL :\n' +
      `      &lt;input type="text" v-model="text" :style="{width: '400px'}"/>\n` +
      '    &lt;/label>\n' +
      '  &lt;/p>\n' +
      '  &lt;button @click="onclick">スクレイピング&lt;/button>\n' +
      '  &lt;div>\n' +
      '    &lt;p>出力&lt;/p>\n' +
      '    &lt;div v-if="isLoading">Loading...&lt;/div>\n' +
      '    &lt;div v-else>\n' +
      '      &lt;ul>\n' +
      '        &lt;li v-for="(h2, i) in data" key="i">{{ h2 }}&lt;/li>\n' +
      '      &lt;/ul>\n' +
      '    &lt;/div>\n' +
      '  &lt;/div>\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Laravel</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ルーティング：/routes/api.php</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">&lt;?php\n' +
      '\n' +
      'use Illuminate\\Support\\Facades\\Route;\n' +
      "Route::get('/titles', 'App\\Http\\Controllers\\ScrapingController@create');</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>コントローラ：</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">&lt;?php\n' +
      '\n' +
      'namespace App\\Http\\Controllers;\n' +
      '\n' +
      'use Illuminate\\Http\\Request;\n' +
      '\n' +
      'class ScrapingController extends Controller\n' +
      '{\n' +
      '    public function index()\n' +
      '    {\n' +
      '        return view("index");\n' +
      '    }\n' +
      '\n' +
      '    public function create(Request $request)\n' +
      '    {\n' +
      '        $url = $request->url;\n' +
      '        $command = "python3 scraping.py {$url}";\n' +
      '        exec($command, $outputs);\n' +
      '        return $outputs;\n' +
      '    }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Python</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>/publicに配置。<br>コントローラで実行するコマンドにおいて、<br>ファイルパスを指定しないと、このディレクトリのファイルを参照するため。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-python">import sys\n' +
      'import requests\n' +
      'from bs4 import BeautifulSoup\n' +
      '\n' +
      'args = sys.argv\n' +
      'url =  args&#091;1]\n' +
      'res = requests.get(url)\n' +
      "soup = BeautifulSoup(res.text, 'html.parser')\n" +
      '\n' +
      "for h2 in soup.select('.single-content > h2'):\n" +
      '  print(h2.text)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-9">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・環境構築</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://qiita.com/tronicboy/items/64a477f8b434f185f9f3" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=qiita.com" alt="" width=16 height=16 /><div class="lkc-domain">Qiita</div>&nbsp;<div class="lkc-url-info">https://qiita.com/tronicboy/items/64a477f8b434f185f9f3</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="https://s.wordpress.com/mshots/v1/https%3A%2F%2Fqiita.com%2Ftronicboy%2Fitems%2F64a477f8b434f185f9f3?w=200" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">LaravelでTypeScript + Vue 3を導入する方法 - Qiita</div></div><div class="lkc-excerpt">目的LaravelでVueを導入する場合、従来だとlaravel/ui → php artisan ui vueで立ち上げる流れですが、このパッケージがてVue 2をデフォルトで入れてくるので、Vue 3のCo...</div></div><div class="clear"></div></div></a></div></div>\n',
    date: '2022-03-19T17:52:37',
    categories: { nodes: [Array] },
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    featuredImage: { node: [Object] },
    uri: '/scraping-by-vue-laravel-python/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
203 wp-image-1807
203 wp-image-1808
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue3.2の時点でwatch系の関数はwatch / watchEffect / watchPostEffect / watchSyncEffectの4種類あります。<br>それぞれの意味と違いをご存知でしょうか。今回はこの4種類のwatchについて解説していきます。<br>また、複数の値を監視するwatchやネストされた値の監視、watchの実行タイミングについても解説しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#watch"><span class="toc_number toc_depth_1">1</span> watch関数の種類</a><ul><li><a href="#watch4"><span class="toc_number toc_depth_2">1.1</span> watch系の関数は4種類ある</a></li><li><a href="#watchwatchEffect2"><span class="toc_number toc_depth_2">1.2</span> watchとwatchEffect系の2つに分類できる</a></li></ul></li><li><a href="#watchEffect"><span class="toc_number toc_depth_1">2</span> watchEffectの使い方</a><ul><li><a href="#watchEffect-2"><span class="toc_number toc_depth_2">2.1</span> watchEffectとは</a></li><li><a href="#watchEffect-3"><span class="toc_number toc_depth_2">2.2</span> watchEffectの実行タイミング</a></li></ul></li><li><a href="#watchSyncEffectwatchPostEffect"><span class="toc_number toc_depth_1">3</span> watchSyncEffectとwatchPostEffectの使い方</a></li><li><a href="#watch-2"><span class="toc_number toc_depth_1">4</span> watchの使い方</a><ul><li><a href="#watchwatchEffect"><span class="toc_number toc_depth_2">4.1</span> watchとwatchEffectの違い</a></li><li><a href="#watch-3"><span class="toc_number toc_depth_2">4.2</span> watchの使い方(プリミティブ・配列・オブジェクトの監視)</a></li><li><a href="#watch-4"><span class="toc_number toc_depth_2">4.3</span> watchで複数の値を監視する</a></li><li><a href="#deep_true"><span class="toc_number toc_depth_2">4.4</span> ネストされたオブジェクトの監視(deep: true)</a></li><li><a href="#createdimmidiate_true"><span class="toc_number toc_depth_2">4.5</span> コンポーネントcreated時に即実行(immidiate: true)</a></li><li><a href="#flush"><span class="toc_number toc_depth_2">4.6</span> 実行タイミング(flush)</a></li></ul></li><li><a href="#i"><span class="toc_number toc_depth_1">5</span> まとめ</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">6</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="watch">watch関数の種類</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watch4">watch系の関数は4種類ある</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watch系の関数は全部で以下の4種類存在します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>① watch</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>② watchEffect</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>③ watchPostEffect</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>④ watchSyncEffect</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では、上記4つのwatchについて解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watchwatchEffect2">watchとwatchEffect系の2つに分類できる</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>4つのwatchを挙げましたが、<strong class="yellow-line">大きく分けると watch と watchEffect系の2種類</strong>に分類されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p><strong>残りのwatchPostEffect、watchSyncEffectの2つは 、watchEffectのオプションに</strong><br><code class="language-ts">{ flush: 'post'}</code> 、<code class="language-ts">{ flush: 'sync' }</code><br>という<strong>オプションを付けた<strong class="pink-line">単なるエイリアス(別名)です</strong></strong>。<br>つまり、watchEffectだけで書き換えることが可能です。これらのオプションの意味についても追って解説します。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>それではまず、watchEffectから解説します。<br>※<a href="#how-to-use-watch">watchの使い方だけ知りたい方はこちらをクリック。</a></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="watchEffect">watchEffectの使い方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watchEffect-2">watchEffectとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配下のコールバック関数内で参照している変数の、<strong>いずれかが変化する度に実行される関数</strong>です。<br><strong>つまり、複数の値を監視しています。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・基本構文</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">watchEffect(() =&gt; {\n' +
      '  //変数A\n' +
      '  //変数B\n' +
      '  //このコールバック内に書いてある変数は全て監視の対象\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上のコードでは変数Aと変数Bを配下に置いています。<br>それぞれの変数は監視されており、どちらか一方にでも変化があれば、watchEffectが実行されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次のコードでは、クリックイベントが発生する度に変数numが加算され、<br>それを監視しているwatchEffectも実行される例です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const num = ref(0)\n' +
      'const onClick = () => num.value++ //クリックアクション\n' +
      'watchEffect(() => {\n' +
      '  console.log(num.value) //onClickが呼ばれるたびに呼び出される\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watchEffect-3">watchEffectの実行タイミング</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watchEffectの実行タイミング(フラッシュ)は3種類のうちから指定して制御できます。<br>①<strong class="yellow-line">pre、②sync、③postの3種類</strong>があります。<br>これをwatchEffectの第２引数のflushプロパティに指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">watchEffect(() => {\n' +
      '  //\n' +
      '},{\n' +
      '  flush: "sync" //or "post" or "pre"\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それぞれの実行タイミングについて詳しく解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>① pre</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デフォルト値です。<strong>コンポーネント更新前</strong>に<strong>非同期</strong>で呼ばれます。<br>つまり、ライフサイクルの中では、beforeUpdate前に呼び出されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>② sync</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>コンポーネント更新前</strong>、すなわちbeforeUpdate前に、<strong>同期的</strong>に、すぐさま呼び出します。<br><strong>ただし、watchEffectを同期的に呼び出すのは効率が悪い</strong>ので、あまりおすすめされません。<br>大体はpreよりも先に呼び出されることになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>③ post</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>コンポーネント更新後</strong>に呼び出されます。 beforeUpdate〜updatedのタイミングです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ライフサイクルフックとの実行順序の関係をまとめると、次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="ulOnly"><strong>sync </strong>→ <strong>pre</strong> → onBeforeUpdate → <strong>post</strong> → onUpdated</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="watchSyncEffectwatchPostEffect">watchSyncEffectとwatchPostEffectの使い方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>これら2つは、前節で紹介したflushのタイミングを、sync、postに設定しただけのwatchEffectの別名に過ぎません</strong>。ですので、効果は全く同じです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="how-to-use-watch"><span id="watch-2">watchの使い方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watchwatchEffect">watchとwatchEffectの違い</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watchも値を監視する関数ですが、次の点でwatchEffectとは異なります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>監視する値を指定する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>監視している値の変更前後の値が取得できる</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>監視している値の変更前後の値が取得できる</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watch-3">watchの使い方(プリミティブ・配列・オブジェクトの監視)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">watch(監視対象, (次の状態, 前の状態) => {\n' +
      '  //\n' +
      '} )</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>監視対象には監視したいプリミティブ型や配列等を指定しますが、種類によって記述方法を変える必要があります。<br>次の状態、前の状態には監視している値の変更前後の値が渡されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下に、監視対象のデータ型の違いによる記述の方法を説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>① プリミティブ型のref</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>値をそのまま代入すれば大丈夫です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const num = ref(0)\n' +
      'watch(num, (next, prev) =&gt; {\n' +
      '  //\n' +
      '} )</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>② 配列のref</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列のコピーを返す関数を代入します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const ary = ref&lt;number[]&gt;([])\n' +
      'watch(() =&gt; [...ary.value], (next, prev) =&gt; {\n' +
      '  //\n' +
      '} )</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>③ reactiveなオブジェクト</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オブジェクトのコピーを返す関数を代入します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const state = reactive({count : 0, age: 0})\n' +
      'watch(() =&gt; ({...state}), (next, prev) =&gt; {\n' +
      '  //\n' +
      '} )</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="watch-4">watchで複数の値を監視する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列でまとめて複数要素を渡せば、複数要素の監視ができます。<br>ただし注意点が1つあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列で渡した要素のうちいずれか1つが変更されればwatchが発火しますが、<strong class="yellow-line">同時に変更されても発火は1回しか起こりません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//同時に変更\n' +
      'const onClick = () =&gt; {\n' +
      '  ++num1.value\n' +
      '  ++num2.value\n' +
      '}\n' +
      '\n' +
      '//発火は1回\n' +
      'watch([num1, num2], ([nextNum1, nextNum2], [prevNum1, prevNum2]) =&gt; {\n' +
      '  //\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この場合は、nextTickを用いて次のtickを待てば良いです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//同時に変更\n' +
      'const onClick = async () => {\n' +
      '  ++num1.value\n' +
      '  await nextTick()\n' +
      '  ++num2.value\n' +
      '}\n' +
      '\n' +
      '//それぞれ1回ずつ計2回発火\n' +
      'watch(&#091;num1, num2], ([nextNum1, nextNum2], [prevNum1, prevNum2]) => {\n' +
      '  //\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="deep_true">ネストされたオブジェクトの監視(deep: true)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>deep: trueプロパティをつければ、ネストが深いオブジェクトに対してもwatchが働きます。<br>リアクティブなオブジェクトをそのまま代入することも可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const state = reactive({\n' +
      '  age: 0,\n' +
      '  type: {\n' +
      '    hoge: 0\n' +
      '  }\n' +
      '})\n' +
      'watch(() => state, (next, prev) => {\n' +
      '  //\n' +
      '},\n' +
      '{\n' +
      '    deep: true\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="createdimmidiate_true">コンポーネントcreated時に即実行(immidiate: true)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>immidiate: trueプロパティをつければコンポーネント作成時にもwatchが実行されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="flush">実行タイミング(flush)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watchEffect同様、①<strong class="yellow-line">pre、②sync、③postの3種類</strong>をflushプロパティで指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>4種類のwatchについて解説しました。そのうちwatchSyncEffectとwatchPostEffectはwatchEffectの単なるエイリアスなので、基本的にはwatchとwatchEffectさえおさえておけば良いでしょう。これらの違いは実行タイミングのみです。watchはwatchEffectよりも多機能な分記述も長くなるので、使い分けが大事です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-external-wrap"><a class="lkc-link no_icon" href="https://v3.ja.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect" target="_blank" rel="external noopener"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=v3.ja.vuejs.org" alt="" width=16 height=16 /><div class="lkc-domain">v3.ja.vuejs.org</div>&nbsp;<div class="lkc-url-info">https://v3.ja.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/pz-linkcard/cache/9fe7fb2e6c6862c6d0926a8e0d74c86c89897e0389f3dd9ad4da885eaac40c80.jpeg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">算出プロパティとウォッチ | Vue.js</div></div><div class="lkc-excerpt">Vue.js - The Progressive JavaScript Framework</div></div><div class="clear"></div></div></a></div></div>\n',
    date: '2022-03-20T03:24:03',
    categories: { nodes: [Array] },
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    featuredImage: { node: [Object] },
    uri: '/vue3-watch/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>JavaScriptの画像処理ライブラリ「Jimp」をTypeScriptで使い、ブラウザ上で画像処理を行う方法を説明します。Jimpは画像処理のアルゴリズムを知らない人も簡単に画像処理ができますし、独自でカーネルを定義できたりピクセル単位の操作が簡単に行えるので、ある程度のカスタマイズができて拡張性があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> この記事で説明すること</a></li><li><a href="#TypeScript"><span class="toc_number toc_depth_1">2</span> (前置き)TypeScriptで画像処理</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">2.1</span> ライブラリを使わない画像処理</a></li><li><a href="#Jimp"><span class="toc_number toc_depth_2">2.2</span> Jimpは初心者から上級者まで使える</a></li></ul></li><li><a href="#TypeScriptJimp"><span class="toc_number toc_depth_1">3</span> ブラウザ上＆TypeScriptでJimpを使う準備</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">3.1</span> インストールからインポートまで</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">3.2</span> ブラウザ上で画像処理を行うコード</a></li></ul></li><li><a href="#Jimp-2"><span class="toc_number toc_depth_1">4</span> Jimpの書式</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 基本的なフィルターの説明</a><ul><li><a href="#i-6"><span class="toc_number toc_depth_2">5.1</span> リサイズ</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">5.2</span> クロップ</a></li><li><a href="#2"><span class="toc_number toc_depth_2">5.3</span> 2枚の画像を重ねた処理(重ねて表示、ブレンド、マスク)</a></li><li><a href="#i-8"><span class="toc_number toc_depth_2">5.4</span> 変形(反転、回転)</a></li><li><a href="#i-9"><span class="toc_number toc_depth_2">5.5</span> 色変換(明度、コントラスト、ディザリング、グレースケール、ネガポジ反転、正規化)</a></li><li><a href="#i-10"><span class="toc_number toc_depth_2">5.6</span> 透明度変換</a></li><li><a href="#i-11"><span class="toc_number toc_depth_2">5.7</span> ぼかし</a></li><li><a href="#i-12"><span class="toc_number toc_depth_2">5.8</span> エフェクト(ポスタリゼーション、セピア、モザイク)</a></li><li><a href="#i-13"><span class="toc_number toc_depth_2">5.9</span> 画質の操作</a></li></ul></li><li><a href="#i-14"><span class="toc_number toc_depth_1">6</span> 様々な色変換を詳細に行う</a><ul><li><a href="#i-15"><span class="toc_number toc_depth_2">6.1</span> ① 色相の回転</a></li><li><a href="#i-16"><span class="toc_number toc_depth_2">6.2</span> ② 彩度の変更</a></li><li><a href="#_RGB"><span class="toc_number toc_depth_2">6.3</span> ③ RGB成分を強く</a></li></ul></li><li><a href="#i-17"><span class="toc_number toc_depth_1">7</span> 空間フィルタリング(畳み込み)</a><ul><li><a href="#i-18"><span class="toc_number toc_depth_2">7.1</span> ① シャープ</a></li><li><a href="#i-19"><span class="toc_number toc_depth_2">7.2</span> ② エンボス</a></li></ul></li><li><a href="#i-20"><span class="toc_number toc_depth_1">8</span> ピクセル値の操作</a></li><li><a href="#i-21"><span class="toc_number toc_depth_1">9</span> その他のトピック</a></li><li><a href="#i-22"><span class="toc_number toc_depth_1">10</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">この記事で説明すること</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>TypeScript ＆ Jimpをブラウザで使うためのセットアップの方法</li><li>Jimpの基本的な使い方の紹介(用意されているフィルタの説明)</li><li>Jimpの発展的な使い方の紹介</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Jimpの使い方について、TypeScriptのコードと実際の画像処理結果を共に記載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript">(前置き)TypeScriptで画像処理</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>前置きなので使用方法だけが知りたい方は次の章へ飛ばして下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">ライブラリを使わない画像処理</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以前「TypeScriptを用いたブラウザ上の画像処理【ライブラリ不使用】」ということで、ライブラリを使わないで画像処理を行う記事を作成しました。興味のある方はご参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/image-processing-by-ts"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/image-processing-by-ts</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/02/thumb-image-processing-on-browser-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScriptを用いたブラウザ上の画像処理【ライブラリ不使用】</div></div><div class="lkc-excerpt">この記事では、ライブラリを一切用いず、TypeScriptを用いてブラウザ上で画像処理をする方法を紹介します。また、画像処理をする方法を解説するだけでなく、実際にコー...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>画像を1次元配列として操作する必要があったり、入力出力周りが面倒だったり、正直かなり画像処理が行いにくい言語です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Jimp">Jimpは初心者から上級者まで使える</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、画像処理は大学数学レベルの内容になってくるので、初心者がとっつきにくい分野でもあると思います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そこでJimpです。<strong class="yellow-line">行いたい画像処理を関数名で呼び出してパラメータを調整する、という直感的な操作</strong>ができます。<br><strong class="yellow-line">用意されているフィルターより複雑な処理をしたくなったら、カーネルを定義したりピクセル単位で操作を行えるので、ある程度カスタマイズも出来ます</strong>。また、画像の類似度を計算する機能等もあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>有名なライブラリであるOpenCVほど複雑な処理はできませんが、画像の簡単な加工や変換だけの用途ならJimpのほうが楽です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="TypeScriptJimp">ブラウザ上＆TypeScriptでJimpを使う準備</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">インストールからインポートまで</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>なにはともあれ、まずはnpmでJimpをインストールします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm install --save jimp</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TSファイルでimportしますが、<strong class="yellow-line">ブラウザ上で画像処理が行いたい場合は次のimport先にします。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">import Jimp from "jimp/browser/lib/jimp"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">ブラウザ上で画像処理を行うコード</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回は、inputフォームで選択したファイルに対してブラウザ上で画像処理を行うことにします。<br>入力も出力もimgタグとします。<br>このあたりの決まりはそれぞれでカスタマイズして下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-html">&lt;input type="file" id="file">\n' +
      '&lt;img src="" alt="入力画像" class="inputImage">\n' +
      '&lt;img src="" alt="出力" class="outputImage"></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">import Jimp from "jimp/browser/lib/jimp"\n' +
      '\n' +
      "document.querySelector&lt;HTMLInputElement>('#file')?.addEventListener('change',  e => {\n" +
      '  const target = e.target as HTMLInputElement\n' +
      '  if (target.files !== null)  {\n' +
      '    const file = target.files&#091;0]\n' +
      '    const url = URL.createObjectURL(file)\n' +
      "    document.querySelector&lt;HTMLImageElement>('.inputImage')!.src = url\n" +
      '    Jimp.read(url).then(image => {\n' +
      '\n' +
      '      // ここから画像処理を書く\n' +
      '      /////  画像処理  /////\n' +
      '      //ここまで\n' +
      '\n' +
      '      image.getBase64(Jimp.MIME_JPEG, (error, img) => {\n' +
      "        document.querySelector&lt;HTMLImageElement>('.outputImage')!.src = img\n" +
      '      })\n' +
      '    })\n' +
      '  }\n' +
      '}, false)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>たったのこれだけです。フォーム周りの処理の説明は割愛します。<br>Jimpで行っている処理は２つです</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①画像の読み込み</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">Jimp.read(url).then(image => {/**画像処理 */})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Jimp.readに画像のURLを指定して読み込みを行っています。Promiseを返すのでthenでつなげており、コールバック関数内で画像処理を行います。コールバックの引数(上のコードだとimage)が処理対象の画像になります。画像はライブラリ固有のJimp型です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②画像の出力</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.getBase64(Jimp.MIME_JPEG, (error, img) => {\n' +
      "  document.querySelector&lt;HTMLImageElement>('.outputImage')!.src = img\n" +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードは画像をどの形式で出力するかによって変わってくるので、あくまで参考程度にとらえてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>getBase64で画像のData URIが取得でき、コールバック内でアウトプット用のimgタグのsrc属性にセットしています。これによって、処理結果の画像がimgタグとしてブラウザ上で出力されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは、実際に画像処理を行います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Jimp-2">Jimpの書式</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Jimpのコードは基本的に、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-ts">image.フィルタ(パラメータ)</code></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>の書式です。フィルタを何個も適用したい場合はチェーンして書きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">Jimp.read(url).then(image => {\n' +
      '\n' +
      '  image.フィルター1()\n' +
      '    .フィルター2()\n' +
      '    .フィルター3()\n' +
      '    \n' +
      '  image.getBase64(Jimp.MIME_JPEG, (error, img) => {\n' +
      "    document.querySelector&lt;HTMLImageElement>('.outputImage')!.src = img\n" +
      '  })\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">基本的なフィルターの説明</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それではJimpで予め用意されているフィルターを紹介します。<br>入力画像は次のお寿司の画像にします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/osushi.jpg" alt="" class="wp-image-1895" width="384" height="384" srcset="https://tekrog.com/wp-content/uploads/2022/04/osushi.jpg 512w, https://tekrog.com/wp-content/uploads/2022/04/osushi-300x300.jpg 300w, https://tekrog.com/wp-content/uploads/2022/04/osushi-150x150.jpg 150w" sizes="(max-width: 384px) 100vw, 384px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-6">リサイズ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①contain</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>画像の大きさを変更します。<br>入力画像は、指定した幅と高さに収まるようにリサイズされます。足りない部分は黒で埋め尽くされます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">image.contain(幅 , 高さ &#091;, Alignモード, Resizeモード])</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>結果： image.contain(500,300)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/contain1.jpeg" alt="" class="wp-image-1896" width="375" height="225" srcset="https://tekrog.com/wp-content/uploads/2022/04/contain1.jpeg 500w, https://tekrog.com/wp-content/uploads/2022/04/contain1-300x180.jpeg 300w" sizes="(max-width: 375px) 100vw, 375px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>元画像より小さいサイズを指定して、画像を縮小しました。<br>足りない部分は黒で塗りつぶされています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Alignモードについて</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>省略可能なパラメータです。<br>Alignモードは画像を揃える位置を指定します。例えば <code class="language-ts">Jimp.HORIZONTAL_ALIGN_LEFT;</code>とすると左添えになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>結果：image.contain(500, 300, Jimp.HORIZONTAL_ALIGN_LEFT)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/alignmode.jpeg" alt="" class="wp-image-1897" width="375" height="225" srcset="https://tekrog.com/wp-content/uploads/2022/04/alignmode.jpeg 500w, https://tekrog.com/wp-content/uploads/2022/04/alignmode-300x180.jpeg 300w" sizes="(max-width: 375px) 100vw, 375px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この他にも揃える位置について次のAlignモードがあります。それぞれの意味は読んで字の如くです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">Jimp.HORIZONTAL_ALIGN_LEFT;\n' +
      'Jimp.HORIZONTAL_ALIGN_CENTER;\n' +
      'Jim'... 25241 more characters,
    date: '2022-05-21T01:34:28',
    categories: { nodes: [Array] },
    title: '【Jimp】TypeScriptでブラウザ上の画像処理【ライブラリ使用】',
    featuredImage: { node: [Object] },
    uri: '/jimp-with-typescript-on-browser/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1895
203 wp-image-1896
203 wp-image-1897
203 wp-image-1898
203 wp-image-1899
203 wp-image-1975
203 wp-image-1976
203 wp-image-1977
203 wp-image-1978
203 wp-image-1980
203 wp-image-1981
203 wp-image-1983
203 wp-image-1985
203 wp-image-1986
203 wp-image-1988
203 wp-image-1990
203 wp-image-1991
203 wp-image-1992
203 wp-image-1994
203 wp-image-1995
203 wp-image-1996
203 wp-image-1997
203 wp-image-1998
203 wp-image-2000
203 wp-image-2001
203 wp-image-2002
203 wp-image-2003
203 wp-image-2004
203 wp-image-2006
203 lkc-favicon
203 lkc-thumbnail-img
101010101010101010 {
  post: {
    content: '\n' +
      '<p>VueUseはVueの開発で遭遇する「よくある機能」をロジック単位で切り出し、それを関数として簡単に利用できるライブラリです。この記事ではVueUseの必要性や基本的な使い方、いくつかの関数をピックアップして紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#VueUse"><span class="toc_number toc_depth_1">1</span> VueUse概要</a><ul><li><a href="#VueUse-2"><span class="toc_number toc_depth_2">1.1</span> VueUseとは</a></li><li><a href="#VueUse-3"><span class="toc_number toc_depth_2">1.2</span> VueUseの例</a></li><li><a href="#VueUseComposition_API"><span class="toc_number toc_depth_2">1.3</span> VueUseはComposition APIがベース</a></li><li><a href="#i"><span class="toc_number toc_depth_2">1.4</span> インストール</a></li></ul></li><li><a href="#VueUse-4"><span class="toc_number toc_depth_1">2</span> VueUseの基本情報</a><ul><li><a href="#Ref"><span class="toc_number toc_depth_2">2.1</span> 関数の戻り値はRef型のオブジェクト</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">2.2</span> イベントフィルタ</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">2.3</span> レンダリング不要のコンポーネント版もある</a></li></ul></li><li><a href="#VueUse-5"><span class="toc_number toc_depth_1">3</span> VueUseの関数紹介</a><ul><li><a href="#useBreakpoints"><span class="toc_number toc_depth_2">3.1</span> useBreakpoints</a></li><li><a href="#useScroll"><span class="toc_number toc_depth_2">3.2</span> useScroll</a></li><li><a href="#useNow"><span class="toc_number toc_depth_2">3.3</span> useNow</a></li><li><a href="#useStorage"><span class="toc_number toc_depth_2">3.4</span> useStorage</a></li><li><a href="#useBase64"><span class="toc_number toc_depth_2">3.5</span> useBase64</a></li><li><a href="#useCounter"><span class="toc_number toc_depth_2">3.6</span> useCounter</a></li><li><a href="#useCycleList"><span class="toc_number toc_depth_2">3.7</span> useCycleList</a></li><li><a href="#useLastChanged"><span class="toc_number toc_depth_2">3.8</span> useLastChanged</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">3.9</span> その他</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="VueUse">VueUse概要</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="VueUse-2">VueUseとは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>VueUseとは、開発中に出くわす「よくある機能」を、ロジック単位で切り離した関数を提供するライブラリです。<br>このような関数をコンポジション関数、コンポーザブル関数と言ったりします。<br>ReactのカスタムHooksのようなものです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="VueUse-3">VueUseの例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>では、VueUseで用意されている関数の例を挙げます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、VueUseを使えば、現在のカーソル位置を取得するコードが1行で書けます。<br>(タグやimportなどで行が増えていますが、ロジック部分は1行です。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">&lt;script setup lang="ts">\n' +
      'import { useMouse } from "@vueuse/core"\n' +
      'const { x, y } = useMouse() \n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このように関数は主にuseXXXXの形式で提供されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>全関数一覧は公式ドキュメントを御覧ください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>VueUse &#8211; Functions(公式ドキュメント) </p><cite>h<a href="//vueuse.org/functions.html#category=Browser" target="_blank" rel="noreferrer noopener">ttps://vueuse.org/functions.html#category=Browser</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="VueUseComposition_API">VueUseはComposition APIがベース</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>VueUseはCompositionAPIで使います。Composition APIについてご存知無い方は次の記事をご参考下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/vue3-ts-quickmanual"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/vue3-ts-quickmanual</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/10/vuexts_thumb-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">Vue3でTypeScriptを使う方法【CompositionAPI】</div></div><div class="lkc-excerpt">Vue.jsでTypeScriptを使う方法、使う際に最低限知っておきたい事をまとめました。データや関数、算出プロパティなど、代表的な機能におけるTypeScriptの記述方法につい...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">インストール</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>CDN、NPMの2つを記載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・CDN</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;script src="https://unpkg.com/@vueuse/shared">&lt;/script>\n' +
      '&lt;script src="https://unpkg.com/@vueuse/core">&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・npm</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm i @vueuse/core</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="VueUse-4">VueUseの基本情報</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Ref">関数の戻り値はRef型のオブジェクト</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>提供されているほとんどの関数の戻り値はRef型のオブジェクトとなっています。<br>デストラクチャリングして戻り値を得るのがベストプラクティスとされています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>useMouse()の例を見てみます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">&lt;script setup lang="ts">\n' +
      'import { useMouse } from "@vueuse/core"\n' +
      'const { x, y } = useMouse() \n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>xとyにデストラクチャリングしており、それぞれの値はRef&lt;number&gt;型となっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">イベントフィルタ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>イベントを制御するフィルターが提供されています。<br>例えば、throttleFilterはイベントにスロットリングをかけ、debounceFilterはイベントを遅延評価します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これもまたuseMouseの例で見てみます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//100ms秒に1回イベントが発火するように抑制\n' +
      'const { x1, y1 } = useMouse({ eventFilter: throttleFilter(100)})\n' +
      '\n' +
      '//100ms後にイベントが発火するように抑制\n' +
      'const { x2, y2 } = useMouse({ eventFilter: debounceFilter(100)})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>throttleFilterでは100ms秒ごとにマウス位置を取得し、debounceFilterではマウスが停止100ms後にマウス位置が評価されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このように、関数に適宜引数を渡すことによって戻り値や動作をカスタマイズすることが出来ます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">レンダリング不要のコンポーネント版もある</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>useXXXの代わりに&lt;UseXXX&gt;で同様の機能を果たせるコンポーネントが幾つかあります。<br>useMouseの例をあげます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template>\n' +
      '  &lt;UseMouse v-slot="{ x, y }">\n' +
      '    ({{ x }}, {{ y }})\n' +
      '  &lt;/UseMouse>\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コンポーネント版を利用するには、別途ライブラリのインストールが必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm i @vueuse/components</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="VueUse-5">VueUseの関数紹介</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それではVueUseのいくつか面白い関数を紹介します。VueUseで提供されている関数は非常に多いです。<br>今回は全体の極々一部の紹介に留めさせて頂きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useBreakpoints">useBreakpoints</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>メディアクエリのブレークポイントをプログラマブルに設定できます。<br>使用手順は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①ブレークポイントを定義します。<br>②現在どのブラウザ幅かを判定するブール値の変数を定義します。<br>③テンプレート側で、②で設定した真偽値をもとに表示を決定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下詳しく説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①では、オブジェクトを利用してブレークポイントを設定します。プロパティ名は自由です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const breakpoints = useBreakpoints({\n' +
      '  sm: 300,\n' +
      '  md: 600,\n' +
      '  lg: 900\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②ブラウザ幅を判定する変数を定義します。<br>①で指定したブレークポイントより小さい(smaller)、2つのブレークポイントの間(between)、大きい(greater)、それぞれを判定する記述をします。以下の変数は真偽値を返します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">const sm = breakpoints.smaller('sm')//より小さい\n` +
      "const md = breakpoints.between('sm', 'md')//間\n" +
      "const lg = breakpoints.between('md', 'lg')//間\n" +
      "const xl = breakpoints.greater('lg')//より大きい</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>③②で決めた真偽値によって、テンプレートの表示非表示を設定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template>\n' +
      '  &lt;div class="font-mono">\n' +
      '    &lt;div class="wrapper"> sm: &lt;p v-if="sm" >NOW&lt;/p>&lt;/div>\n' +
      '    &lt;div class="wrapper"> md: &lt;p v-if="md" >NOW&lt;/p>&lt;/div>\n' +
      '    &lt;div class="wrapper"> lg: &lt;p v-if="lg" >NOW&lt;/p>&lt;/div>\n' +
      '    &lt;div class="wrapper"> xl: &lt;p v-if="xl" >NOW&lt;/p>&lt;/div>\n' +
      '  &lt;/div>\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下実行例です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full"><img decoding="async" width="1860" height="640" src="https://tekrog.com/wp-content/uploads/2022/03/ezgif-2-111b8623ae-1.gif" alt="" class="wp-image-1769"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useScroll">useScroll</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロールに関する様々な情報を取得できます。<br>取得できる情報は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>現在のスクロール量 / スクロール中かどうか / ページの一番上(右、下、左)にいるか / スクロールの方向</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const el = ref&lt;HTMLElement | null>(null)\n' +
      'const {\n' +
      '  x,  // 横方向のスクロール量\n' +
      '  y, // 縦方向のスクロール量\n' +
      '  isScrolling, // 現在スクロール中か\n' +
      '  arrivedState,  // 左右上下いずれかのページの端にいるか\n' +
      '  directions // スクロールの方向\n' +
      '} = useScroll(el)\n' +
      '\n' +
      '//左右上下のそれぞれ端にいるかどうか、boolean\n' +
      'const { left, right, top, bottom } = toRefs(arrivedState)\n' +
      '\n' +
      '//スクロールの方向\n' +
      'const { left: toLeft, right: toRight, top: toTop, bottom: toBottom } = toRefs(directions)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useNow">useNow</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>現在時刻を毎秒リアルタイムで更新します。<br>controlsオプションを付けることで、時刻の一時停止やキャンセルが可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;script setup lang="ts">\n' +
      "import { useNow } from '@vueuse/core'\n" +
      'const { now, pause, resume } = useNow({ controls: true })\n' +
      '&lt;/script>\n' +
      '\n' +
      '&lt;template>\n' +
      '  Now: {{ now }} &lt;!--毎秒更新される-->\n' +
      '  &lt;button @click="pause()">Pause&lt;/button>\n' +
      '  &lt;button @click="resume()">Resume&lt;/button>\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useStorage">useStorage</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>リアクティブなLocal / Session Storageを提供します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts">\n' +
      "import { useStorage } from '@vueuse/core'\n" +
      '\n' +
      '// オブジェクト登録\n' +
      "const state = useStorage('my-store', { hello: 'hi', greeting: 'Hello' })\n" +
      '\n' +
      '// ブール値登録\n' +
      "const flag = useStorage('my-flag', true) // returns Ref&lt;boolean>\n" +
      '\n' +
      '// 数字登録\n' +
      "const count = useStorage('my-count', 0) // returns Ref&lt;number>\n" +
      '\n' +
      '// セッションストレージの利用、文字列登録\n' +
      "const id = useStorage('my-id', 'some-string-id', sessionStorage) // returns Ref&lt;string>\n" +
      '\n' +
      '// 削除\n' +
      'state.value = null\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="useBase64">useBase64</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>BASE64に変換します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts">\n' +
      "import { useBase64 } from '@vueuse/core'\n" +
      "import { ref, type Ref } from 'vue';\n" +
      'const image = ref() as Ref&lt;HTMLImageElement>\n' +
      'const { base64: imageBase64 } = useBase64(ima'... 3178 more characters,
    date: '2022-03-09T13:48:37',
    categories: { nodes: [Array] },
    title: 'Vueのライブラリ「VueUse」とは？',
    featuredImage: { node: [Object] },
    uri: '/know-vueuse/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
203 lkc-favicon
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue3.2で&lt;script setup&gt;構文が導入され、Composition APIの記述が簡単になりました。&lt;script setup&gt;構文は記述が簡単になるだけでなく、他にも多くのメリットが存在します。この記事では&lt;script setup&gt;構文の説明から、propsやemitなどの特有の記述方法、メリットなどを説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#ltscript_setupgt"><span class="toc_number toc_depth_1">1</span> &lt;script setup&gt;構文の基本</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">1.1</span> 記述方法</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">1.2</span> メリット</a></li></ul></li><li><a href="#ltscript_setupgtPropEmits"><span class="toc_number toc_depth_1">2</span> &lt;script setup&gt;構文でのPropとEmitsの記述方法</a><ul><li><a href="#definePropsdefineEmits"><span class="toc_number toc_depth_2">2.1</span> 基本〜definePropsとdefineEmits〜</a></li><li><a href="#TypeScript"><span class="toc_number toc_depth_2">2.2</span> TypeScriptによる簡略化した記述</a></li><li><a href="#defineProps"><span class="toc_number toc_depth_2">2.3</span> definePropsについて補足</a></li><li><a href="#defineEmits"><span class="toc_number toc_depth_2">2.4</span> defineEmitsについて補足</a></li></ul></li><li><a href="#import"><span class="toc_number toc_depth_1">3</span> コンポーネントは、importするだけで使用可能になる</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">4</span> その他のトピック</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">4.1</span> 親コンポーネントに変数を公開するには</a></li><li><a href="#export"><span class="toc_number toc_depth_2">4.2</span> exportするには</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="ltscript_setupgt">&lt;script setup&gt;構文の基本</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">記述方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;script setup&gt;構文は、従来のComposition APIのシンタックスシュガー(中身は同じで別の書き方)です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Composition APIをご存じない方はこちらの記事を参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/vue3-ts-quickmanual"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/vue3-ts-quickmanual</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/10/vuexts_thumb-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">Vue3でTypeScriptを使う方法【CompositionAPI】</div></div><div class="lkc-excerpt">Vue.jsでTypeScriptを使う方法、使う際に最低限知っておきたい事をまとめました。データや関数、算出プロパティなど、代表的な機能におけるTypeScriptの記述方法につい...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;script setup&gt;構文ですが、使うために必要なのは<strong class="yellow-line">scriptタグ内ににsetupと記述するだけ</strong>です。<br>まずは従来の記述方法と比較することで、具体的な記述方法を見ていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>・&lt;script setup&gt;構文</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup>\n' +
      "import { computed, ref } from 'vue'\n" +
      '//変数\n' +
      'const hoge = ref("hoge")\n' +
      'const num = ref&lt;number>()\n' +
      '//関数\n' +
      'const onClick = () => console.log("clicked!")\n' +
      '//computed\n' +
      'const twice = computed(() => num.value)\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>従来の方法</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>同じ内容のコードを従来通りに書くと次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts">\n' +
      'import { defineComponent, ref, computed } from "vue";\n' +
      'export default defineComponent({\n' +
      '  setup() {\n' +
      '    //変数\n' +
      '    const hoge = ref("hoge")\n' +
      '    const num = ref&lt;number>()\n' +
      '    //関数\n' +
      '    const onClick = () => console.log("clicked!")\n' +
      '    //computed\n' +
      '    const twice = computed(() => num.value)\n' +
      '    return {\n' +
      '      hoge, num, onClick, twice\n' +
      '    }\n' +
      '  }\n' +
      '})\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>見ての通り、最初に記載した&lt;script setup&gt;構文では<strong class="yellow-line">圧倒的に記述が楽になりました。</strong><br>また、全てトップレベルに記述できるので<strong class="yellow-line">コードの見通しも良い</strong>です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>具体的に言うと、次の3つの記述が不要になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>export default defineComponentによるオブジェクトのラップ</li><li>setup()関数</li><li>return文</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>トップレベルに書いた変数や関数はがそのままtemplateで使えるのです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">メリット</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>記述が楽になりコードの見通しが良くなる、以外にも多くのメリットが存在します。<br>いくつか紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>TypeScriptによる型推論のパフォーマンス向上!</li><li>PropとEmitの記述が楽に！TypeScriptで書ける(<strong>後述</strong>)</li><li>templateで使うコンポーネントは、importするだけで使用可能になる!<strong>(後述)</strong></li><li>実行パフォーマンスの向上!</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="ltscript_setupgtPropEmits">&lt;script setup&gt;構文でのPropとEmitsの記述方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="definePropsdefineEmits">基本〜definePropsとdefineEmits〜</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>従来のComposition APIでPropsとEmitは、setup()と同じ階層に併記していました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;script  setup&gt;構文では、definePropsやdefineEmitsを用いて、トップレベルに記述します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts"&gt;\n' +
      'const props = defineProps({\n' +
      '  num: {\n' +
      '    type: Number,\n' +
      '    required: true\n' +
      '  },\n' +
      '  str: {\n' +
      '    type: String,\n' +
      '    default: "hoge"\n' +
      '  }\n' +
      '})\n' +
      'const emits = defineEmits(\n' +
      "  &#091;'change']\n" +
      ')\n' +
      '&lt;/script&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>typeやrequired、defaultの書き方は普通のsetup文の時と変わりません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="TypeScript">TypeScriptによる簡略化した記述</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TypeScriptのジェネリックを使えば、更に簡単に記述できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script setup lang="ts">\n' +
      'const props = defineProps&lt;{\n' +
      '  num: number,\n' +
      '  str?: string //?なのでrequired: falseと同じ\n' +
      '}>()\n' +
      'const emits = defineEmits&lt;{\n' +
      "  (e: 'change', id: number): void\n" +
      '}>()\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下、このコードについて解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="defineProps">definePropsについて補足</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コード例に載せたとおり、propsの型はTypeScriptの記述で指定します。<br>「num: number」はnumber型で必須(required: true)のpropsを表し、<br>「str?: string」はstring型で任意(required: false)のpropsにできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このように?の有無でrequiredの指定ができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ただし、<strong class="yellow-line">この記述方法ではpropsのデフォルト値が表現できません。</strong><br>デフォルト値が必要な場合はwithDefaults関数を利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const props = withDefaults(defineProps&lt;{\n' +
      '  num?: number,\n' +
      '  str?: string\n' +
      '}&gt;(), {\n' +
      '  num: 3,\n' +
      '  str: "hoge"\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、scriptブロック内でpropsは利用せずにtemplateブロック内でのみ利用する場合、const propsに代入せずに次のような宣言をするだけで構いません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">defineProps&lt;{ msg: string }>()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="defineEmits">defineEmitsについて補足</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ジェネリックの&lt;>内で必要な数のemitを定義していきます。<br>基本的な書き方は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">const emits = defineEmits&lt;{\n' +
      '  (e: "Emitの名前", 渡したい引数: 型): void\n' +
      '  (e: "Emitの名前2", 渡したい引数: 型): void\n' +
      '}>()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>具体的な使用例を載せます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">&lt;script setup lang="ts">\n' +
      '\n' +
      'const emits = defineEmits&lt;{\n' +
      '  (e: "hoge", num: number): void\n' +
      '  (e: "fuga"): void\n' +
      '}>()\n' +
      '\n' +
      'const onclick = () => {\n' +
      '  emits("hoge", 3) //3を引数にhogeを発火\n' +
      '  emits("fuga") //引数無しでfugaを発火\n' +
      '}\n' +
      '\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="import">コンポーネントは、importするだけで使用可能になる</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>templateで使うコンポーネントは、script setupブロック内でimportするだけで、template側で使用可能になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;script setup lang="ts">\n' +
      "import Child from './Child.vue';\n" +
      '&lt;/script>\n' +
      '\n' +
      '&lt;template>\n' +
      '  &lt;Child /> \n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">その他のトピック</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">親コンポーネントに変数を公開するには</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>親がテンプレート参照を用いて子トップレベルの変数等にアクセスするには、defineExposeを使う必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const num = ref&lt;number>()\n' +
      'defineExpose({\n' +
      '  num\n' +
      '})\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これで、このコンポーネントを利用する親コンポーネントはテンプレート参照を用いてnumにアクセスできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="export">exportするには</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;script setup&gt;構文ではexportの記述ができません。<br>従来の&lt;script&gt;だけの構文も記述してexportする必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts"&gt;\n' +
      'export const hoge = "fuga" //OK\n' +
      '&lt;/script&gt;\n' +
      '\n' +
      '&lt;script setup lang="ts"&gt;\n' +
      '// export const fuga = "fuga" //エラー\n' +
      '&lt;/script&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;script setup&gt;構文について、一通りの使い方とメリットを紹介しました。非常に多くのメリットが存在し、記述が簡単になり開発効率も上がるので積極的に利用すべきです。</p>\n',
    date: '2022-03-19T09:30:14',
    categories: { nodes: [Array] },
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    featuredImage: { node: [Object] },
    uri: '/vue3-script-setup/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-thumbnail-img
203 wp-image-1769
203 wp-image-1761
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>MPAにおいて、LaravelのBladeファイルの中でVue3.jsのコンポーネントを利用する方法を紹介します。createAppの記述方法に注意しないと、意図した結果が得られないので注意が必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Blade"><span class="toc_number toc_depth_1">1</span> Bladeファイルでコンポーネントを使う場面</a></li><li><a href="#i"><span class="toc_number toc_depth_1">2</span> 下準備</a></li><li><a href="#createApp"><span class="toc_number toc_depth_1">3</span> createAppに使用したいコンポーネントを登録</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="Blade">Bladeファイルでコンポーネントを使う場面</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回説明する内容は、MPA(マルチページアプリケーション)を想定しています。<br>複数あるBladeファイルでVueコンポーネントを使いまわしたいケースです。<br>マルチページなのでBladeファイルが複数あります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/03/mpa.png" alt="" class="wp-image-1847" width="469" height="331" srcset="https://tekrog.com/wp-content/uploads/2022/03/mpa.png 938w, https://tekrog.com/wp-content/uploads/2022/03/mpa-300x211.png 300w, https://tekrog.com/wp-content/uploads/2022/03/mpa-768x541.png 768w" sizes="(max-width: 469px) 100vw, 469px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回は深堀りしませんが、SPA(シングルページアプリケーション)の場合はBladeファイルを1つ用意し、<br>&lt;div id=&#8221;app&#8221;/>をBladeファイルに書いてVueコンポーネントをマウントするだけです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/03/spa.png" alt="" class="wp-image-1846" width="411" height="228" srcset="https://tekrog.com/wp-content/uploads/2022/03/spa.png 822w, https://tekrog.com/wp-content/uploads/2022/03/spa-300x166.png 300w, https://tekrog.com/wp-content/uploads/2022/03/spa-768x426.png 768w" sizes="(max-width: 411px) 100vw, 411px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">下準備</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずはBladeファイル内で、Vueコンポーネントを利用したい箇所を全て囲みます。<br>今回はお決まりの &lt;div id=&#8221;app&#8221;>配下で使用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">  {{-- Bladeファイルです --}}\n' +
      '  &lt;div id="app">\n' +
      "    @yield('content')\n" +
      '  &lt;/div> </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コンポーネントを利用するBladeファイルの出力は全て@yieldで行うとします。<br>逆に言うと、id=&#8221;app&#8221;の配下以外ではコンポーネントの利用はできません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="createApp">createAppに使用したいコンポーネントを登録</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>app.ts(もしくはapp.js)でcreateApp()を呼び出してマウントするのが一般的だと思います。<br>BladeでVue3のコンポーネントを利用するには、ここで利用するコンポーネントを登録してマウントするだけです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// app.ts\n' +
      'createApp({\n' +
      '  components:{\n' +
      '    ComponentA,\n' +
      '    ComponentB,\n' +
      '    ComponentC,\n' +
      '  }\n' +
      "}).mount('#app')</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">注意してほしいのが、componentsプロパティを利用する点です。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>createAppにおいて、componentsプロパティを利用せずに直接コンポーネントを引数にすると、&lt;div id=&#8221;app&#8221;>配下が全てコンポーネントで置き換えられるので注意して下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、次のような記述をすれば、&lt;div id=&#8221;app&#8221;>内が全てComponentAに置換されてしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">createApp(ComponentA).mount('#app')</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>※SPAならこの書き方で、#appにルートコンポーネントをマウントします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>componentsプロパティを利用すれば全て置換されることがなく、色々なBladeファイル内でコンポーネントを自由に使うことが可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>LaravelのBladeファイルにおいてVue3コンポーネントを利用する方法を説明しました。componentsプロパティを使用しないとid=&#8221;app&#8221;配下が全てコンポーネントに書き換えられてしまうので注意が必要です。</p>\n',
    date: '2022-02-24T16:01:20',
    categories: { nodes: [Array] },
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    featuredImage: { node: [Object] },
    uri: '/vue3-components-in-blade/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-1847
203 wp-image-1846
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>この記事では、ライブラリを一切用いず、TypeScriptを用いてブラウザ上で画像処理をする方法を紹介します。また、画像処理をする方法を解説するだけでなく、実際にコードを掲載して画像処理をした結果や、紹介したコードによるデモも掲載しています。JavaScriptしかご存じない方も、型の定義を無視すればJavaScriptのコードとして読み進めることが可能です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> デジタル画像処理をご存じない方へ</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">1.2</span> ライブラリを使えば簡単に画像処理が可能</a></li></ul></li><li><a href="#TypeScript"><span class="toc_number toc_depth_1">2</span> TypeScriptでの画像処理の方法</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">2.1</span> 画像処理をする一連の流れ(概要)</a></li><li><a href="#ImageData"><span class="toc_number toc_depth_2">2.2</span> ImageData型とは</a></li></ul></li><li><a href="#TypeScript-2"><span class="toc_number toc_depth_1">3</span> TypeScriptでの画像処理の流れ(コード)</a><ul><li><a href="#_HTMLcanvas"><span class="toc_number toc_depth_2">3.1</span> ① HTMLでcanvasタグを用意する</a></li><li><a href="#_TSJSImage"><span class="toc_number toc_depth_2">3.2</span> ② TS(JS)でImageクラスのインスタンスを作成</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">3.3</span> ③ ②で作ったインスタンスを用いて画像をロード</a></li><li><a href="#_canvas"><span class="toc_number toc_depth_2">3.4</span> ④ 画像のロードが終わったらcanvasタグに出力</a></li><li><a href="#_canvasImageData"><span class="toc_number toc_depth_2">3.5</span> ⑤ canvasタグから画像データを取得し、ImageData型のオブジェクトに代入</a></li><li><a href="#_ImageData"><span class="toc_number toc_depth_2">3.6</span> ⑥ 取得したImageData型の画像を処理</a></li><li><a href="#_canvas-2"><span class="toc_number toc_depth_2">3.7</span> ⑦ 結果をcanvasタグに表示</a></li></ul></li><li><a href="#i-6"><span class="toc_number toc_depth_1">4</span> 空間フィルタリングでの使用例</a><ul><li><a href="#i-7"><span class="toc_number toc_depth_2">4.1</span> シャープフィルタのコード</a></li><li><a href="#i-8"><span class="toc_number toc_depth_2">4.2</span> シャープフィルタの結果</a></li></ul></li><li><a href="#i-9"><span class="toc_number toc_depth_1">5</span> 様々な画像処理とデモ</a><ul><li><a href="#i-10"><span class="toc_number toc_depth_2">5.1</span> デモ</a></li></ul></li><li><a href="#i-11"><span class="toc_number toc_depth_1">6</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">デジタル画像処理をご存じない方へ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事を読むには「デジタル画像処理」の基礎知識(画素値の変換や空間フィルタリング程度で可)が必要です。そこで、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-vivid-red-color has-text-color"><strong>画像処理の知識が無い方でも簡単に画像処理が行える方法を別記事にしました！</strong></p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/easy-image-processing-by-ts"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/easy-image-processing-by-ts</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】</div></div><div class="lkc-excerpt">TypeScript、あるいはJavaScriptで簡単に画像処理を行う方法を紹介します。画像処理の知識も不要でライブラリも使いません。そのためにCSSを利用し、プロパティ値をスク...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-black-color has-text-color">ただし、ライブラリを使わずCSSを駆使する方法ですので、表現の幅は限られています。(その分非常に簡単)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">ライブラリを使えば簡単に画像処理が可能</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-vivid-red-color has-text-color"><strong><span style="text-decoration: underline;">★ライブラリを使えば、デジタル画像処理の知識がなくても様々な画像処理が可能です！</span><br>Jimpという画像処理ライブラリで、誰でも簡単に画像処理ができる方法をまとめています。</strong></p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/jimp-with-typescript-on-browser"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/jimp-with-typescript-on-browser</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/05/thumb-ijimp-with-typescript-on-browser-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【Jimp】TypeScriptでブラウザ上の画像処理【ライブラリ使用】</div></div><div class="lkc-excerpt">JavaScriptの画像処理ライブラリ「Jimp」をTypeScriptで使い、ブラウザ上で画像処理を行う方法を説明します。Jimpは画像処理のアルゴリズムを知らない人も簡単に画像処...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript">TypeScriptでの画像処理の方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下で紹介する方法はライブラリを一切使わないため、自分で画素値にアクセスして0から画像処理のアルゴリズムを書いていくことになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">画像処理をする一連の流れ(概要)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ブラウザ上で画像処理をする一連のプロセスは次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol class="ulOnly">\n' +
      '<li>① HTMLでcanvasタグを用意</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>② TS(JS)でImageクラスのインスタンスを作成</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>③ ②で作ったインスタンスを用いて画像ファイルをロード</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>④ 画像のロードが終わったらcanvasタグに出力(これが入力画像)</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>⑤ ★canvasタグから画像データを取得し、ImageData型のオブジェクトに代入</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>⑥ ★取得したImageData型の画像を変換(画像処理)</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>⑦ 処理結果(出力画像)をcanvasタグに表示</li>\n' +
      '</ol>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>図で表すと、次のようなイメージです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/02/process-image-1024x687.png" alt="" class="wp-image-1715" width="512" height="344" srcset="https://tekrog.com/wp-content/uploads/2022/02/process-image-1024x687.png 1024w, https://tekrog.com/wp-content/uploads/2022/02/process-image-300x201.png 300w, https://tekrog.com/wp-content/uploads/2022/02/process-image-768x515.png 768w, https://tekrog.com/wp-content/uploads/2022/02/process-image-1536x1030.png 1536w, https://tekrog.com/wp-content/uploads/2022/02/process-image.png 1742w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>結構まどろっこしい手順を踏みます。7ステップ示しましたが、実際に画像処理をするのは⑥です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>一度処理する前の画像を④でcanvasに出力する必要があります。<br>処理前のcanvasタグと処理後のcanvasタグを共通のものとすれば、処理前の画像は実際に表示されませんが。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>重要なポイントは★印をつけた⑤と⑥のステップです。<br><strong class="yellow-line">TypeScript (及びJavaScript)で処理する画像データはImageData型になります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いて、このImageData型について解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="ImageData">ImageData型とは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><a href="https://developer.mozilla.org/ja/docs/Web/API/ImageData" target="_blank" rel="noreferrer noopener">公式ドキュメント</a>に詳しい記述はありますが、ここでは最低限必要なポイントに絞って説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group ulUI"><div class="wp-block-group__inner-container">\n' +
      '<p>ImageData型のプロパティ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul>\n' +
      '<li>width: 画像の幅を返す(読み取り専用)</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>height: 画像の高さを返す (読み取り専用)</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>★data: 画像のピクセル値を配列で返す (読み取り専用)</li>\n' +
      '</ul>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>画像本体はImageData型のdataプロパティにピクセル値の配列として格納されています。<br><strong class="yellow-line">ピクセル値は、すべてのピクセルのRGBαの4値を1列に並べた１次元配列となっています。</strong><br>つまり、4値 x 幅 x 高さの長さを持つ1次元配列となります。画素値は通常通り0~255の256値を取ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>図でまとめると、次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/04/imagedata-2-1024x803.png" alt="" class="wp-image-1886" width="512" height="402" srcset="https://tekrog.com/wp-content/uploads/2022/04/imagedata-2-1024x803.png 1024w, https://tekrog.com/wp-content/uploads/2022/04/imagedata-2-300x235.png 300w, https://tekrog.com/wp-content/uploads/2022/04/imagedata-2-768x602.png 768w, https://tekrog.com/wp-content/uploads/2022/04/imagedata-2-1536x1204.png 1536w, https://tekrog.com/wp-content/uploads/2022/04/imagedata-2.png 1676w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ImageData型について解説したので、実際のコードと画像処理の結果を見ていきます。<br>前節で説明した7つのステップの順に説明していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="TypeScript-2">TypeScriptでの画像処理の流れ(コード)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="_HTMLcanvas">① HTMLでcanvasタグを用意する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>入力画像と出力画像を別々に表示したいのであれば2つ用意します。<br>出力画像だけ欲しい場合は入力と出力のcanvasが同じで構いません。<br>今回は画像処理の結果の前後を比べたいので、2つcanvasタグを用意します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;canvas id="canvas-in">&lt;/canvas>\n' +
      '&lt;canvas id="canvas-out">&lt;/canvas></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>用意しただけではスクリプトで扱えないので、スクリプト側で参照します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">const canvasIn = document.querySelector&lt;HTMLCanvasElement>('#canvas-in')!\n` +
      "const canvasOut = document.querySelector&lt;HTMLCanvasElement>('#canvas-out')!</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回はcanvasサイズを256 x 256ピクセルとします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const SIZE = 256\n' +
      'canvasIn.width = SIZE\n' +
      'canvasIn.height = SIZE\n' +
      'canvasOut.width = SIZE\n' +
      'canvasOut.height = SIZE</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="_TSJSImage">② TS(JS)でImageクラスのインスタンスを作成</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>文字通り、Imageクラスのインスタンスを作成します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">let image = new Image()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">③ ②で作ったインスタンスを用いて画像をロード</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Imageのインスタンスのsrcプロパティに画像のパスを代入するだけで、画像の読み込みが行われます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">image.src = 'hoge.jpg'</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="_canvas">④ 画像のロードが終わったらcanvasタグに出力</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Imageのインスタンスにイベントリスナを設定し、ロードが終わったらcanvasタグに画像を出力します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p>なお、出力の際にCanvasRenderingContext2Dインターフェースを利用します。<br>長い名前のインターフェースですがコードは単純で、canvas要素のプロパティとして、<code class="language-ts">canvas.getContext('2d')</code>と呼び出すだけです。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>canvasの説明ではないのでCanvasRenderingContext2Dインターフェースについてはこれ以上は深入りしません。<br>2Dのレンダリング関係とだけ覚えておいて、今回は決り文句として利用するだけでいいです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//CanvasRe'... 7971 more characters,
    date: '2022-02-24T08:51:15',
    categories: { nodes: [Array] },
    title: 'TypeScriptを用いたブラウザ上の画像処理【ライブラリ不使用】',
    featuredImage: { node: [Object] },
    uri: '/image-processing-by-ts/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1715
203 wp-image-1886
203 wp-image-1717
203 wp-image-1716
203 wp-image-1721
203 wp-image-1915
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>CSSでスクロールスナップの指定をするとスクロール量が取得できなくなります。これが原因で、Vue Routerで他のURLへ遷移して元のURLに戻る際、遷移前にいたスクロール位置に戻るコードに少し工夫が必要になります。この記事ではこの要件を満たしたコードを紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 実現したい内容</a></li><li><a href="#scrollBehavior"><span class="toc_number toc_depth_1">2</span> 問題：scrollBehaviorでは戻れない</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">3</span> 解決：遷移後に指定した要素へ飛ぶ</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">4</span> 補足：スナップ時にスクロール位置が取得できない理由</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2 id="実現したい内容"><span id="i">実現したい内容</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue Routerを用いてURLを切り替えることを考えます。<br>元のURLをURL1、切り替え先のURLをURL2とし、URL1のページはスクロールスナップが効いているとします。<br>この時、実現したい内容は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>実現したい内容</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>URL1でスクロールして、セクションAからセクションBへ</li><li>セクションBからURL2に移動する</li><li>URL2からURL1に戻ってきた時、元のセクションBの位置に直接戻る</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>図で説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①スクロールスナップを設定しているURL1で、スクロールをしてセクションBへ移動します。<br>ここでセクションとは、スクロールスナップによって区切られている各要素の単位を表します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01-1024x1017.png" alt="" class="wp-image-1699" width="512" height="509" srcset="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01-1024x1017.png 1024w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01-300x298.png 300w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01-150x150.png 150w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01-768x763.png 768w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue01.png 1240w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②セクションBから、URL2のコンポーネントへ移動します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02-1024x766.png" alt="" class="wp-image-1700" width="768" height="575" srcset="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02-1024x766.png 1024w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02-300x224.png 300w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02-768x574.png 768w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02-1536x1149.png 1536w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue02.png 1647w" sizes="(max-width: 768px) 100vw, 768px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>③URL2からURL1へ戻ったとき、直接セクションBの位置へ戻ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03-1024x757.png" alt="" class="wp-image-1701" width="768" height="568" srcset="https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03-1024x757.png 1024w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03-300x222.png 300w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03-768x568.png 768w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03-1536x1135.png 1536w, https://tekrog.com/wp-content/uploads/2022/02/scroll-snap-vue03.png 1674w" sizes="(max-width: 768px) 100vw, 768px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="問題-scrollbehaviorでは戻れない"><span id="scrollBehavior">問題：scrollBehaviorでは戻れない</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ルーティング設定ファイルのcreateRouter()内でscrollBehavior()を呼び出せば、遷移後のページの指定位置へジャンプすることができます。<strong class="yellow-line">しかしスクロールスナップの設定上、ここでの設定が利きません。</strong><br>よって、他で元のセクションへ移動する処理を書く必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>scrollBehaviorについて詳しく知りたい方は、公式のドキュメントを参照下さい。今回は使いません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Scroll Behavior</p><cite><a href="https://router.vuejs.org/guide/advanced/scroll-behavior.html" target="_blank" rel="noreferrer noopener">https://router.vuejs.org/guide/advanced/scroll-behavior.html</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2 id="解決-遷移後に指定した要素へ飛ぶ"><span id="i-2">解決：遷移後に指定した要素へ飛ぶ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">要素X.scrollIntoView()を用いれば、要素Xがビューポートに入るようにスクロール(ジャンプ)してくれます。<br>つまり、元のセクションへ戻れます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回の要件を満たすコードの手順を記します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>解決策</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>URL1の各セクションに、それぞれのセクションが一意に求まるクラスまたはIDを設定します。今回はIDとします。</li><li>ページ遷移前に、直前にいたセクションBのIDを保持します。Vuexなどの外部ストアを用いても良いです。セクションのIDの検出は、Intersection Observer APIなどを用います。</li><li>ページを遷移し、戻って来たときにセクションBのIDを取得します。</li><li>遷移後にdocument.querySelector(&#8216;セクションBのID&#8217;).scrollIntoView()でジャンプします。</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>.scrollIntoView()によるジャンプは一瞬なので、直接元のセクションへ戻れます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="補足-スナップ時にスクロール位置が取得できない理由"><span id="i-3">補足：スナップ時にスクロール位置が取得できない理由</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事で紹介しています。適宜参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/get-scrolly-when-using-scrollsnap"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/get-scrolly-when-using-scrollsnap</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/10/scrollsnap-scrolly-150x150.png" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">スクロールスナップ時にスクロール量を取得する方法</div></div><div class="lkc-excerpt">CSSでscroll-snap-typeを指定した時、普通の方法ではスクロール量の取得ができません。そこで今回は、ちょっとした工夫でスクールスナップ時にスクロール量を取得する方...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ある工夫でスクロール量を取得する方法も紹介しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="まとめ"><span id="i-4">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロールスナップ時に、VueRouterで遷移前のセクション位置へ戻る方法を紹介しました。他にも方法はありますが、一例として説明しています。</p>\n',
    date: '2022-02-09T11:55:13',
    categories: { nodes: [Array] },
    title: 'スクロールスナップ+Vueで遷移前のページ位置に戻る方法',
    featuredImage: { node: [Object] },
    uri: '/scroll-snap-vue-router/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue.jsにおいてv-forでHTML要素を繰り返し作成したとき、それぞれの要素に対してテンプレート参照する方法を解説します。ただしVue3のComposition APIのみを対象としています。また、要素の生成から参照するまでのタイミングや挙動、watchとの利用や注意点についてもまとめています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 前提</a></li><li><a href="#v-for"><span class="toc_number toc_depth_1">2</span> v-for指定した要素をテンプレート参照する方法</a><ul><li><a href="#lttemplatev-forref"><span class="toc_number toc_depth_2">2.1</span> ①&lt;template＞側でv-forを付けた要素に:refをつける</a></li><li><a href="#ltscriptgt"><span class="toc_number toc_depth_2">2.2</span> ②&lt;script&gt;側で値の代入を行う</a></li><li><a href="#DOM"><span class="toc_number toc_depth_2">2.3</span> 【重要】DOMに更新がある場合</a></li></ul></li><li><a href="#watch"><span class="toc_number toc_depth_1">3</span> テンプレート参照とマウント、watchのタイミング</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">3.1</span> 要素とコードが紐づくタイミング</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">3.2</span> ウォッチを用いる場合</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">前提</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue.jsの3.x系でComposition APIを利用しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="v-for">v-for指定した要素をテンプレート参照する方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="lttemplatev-forref">①&lt;template＞側でv-forを付けた要素に:refをつける</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">refではなく、:refのように「：」がついていることに注意して下さい。</strong><br>そして:refの右辺に関数を代入します。<br>この関数は次の節できちんと定義するので、この時点で関数の名前は何でも構いません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html"> &lt;div v-for="i in num" :ref="setDivRef">{{i}}&lt;/div></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上のコードの例において、numは要素を繰り返す回数を表すとします。任意の数字に置き換えて下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="ltscriptgt">②&lt;script&gt;側で値の代入を行う</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>テンプレート参照をする配列を用意します。<br>そして①で指定した関数を定義し、その関数の中で引数を配列にpushします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const divs = ref&lt;HTMLDivElement&#91;]>(&#91;])\n' +
      'const setDivRef = (el: any) => {\n' +
      '  if (el) {\n' +
      '    divs.value.push(el)\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">これで配列divsの任意のインデックスにアクセスすれば、v-forで生成された各要素が参照ができます。</strong><br>例えば、divs.value[0]にアクセスすれば1個目のdiv、divs.value[1]にアクセスすれば2個目のdiv、といった要領です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、①と②をまとめて次のようにも書けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html"> &lt;div v-for="(n, i) in num" :ref="(el: any) => {if (el) divs&#91;i] = el}"></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>v-forで繰り返される値が後から増えても、テンプレート参照が働いて配列としてアクセスすることができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="DOM">【重要】DOMに更新がある場合</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>画面に更新処理が走る度に、テンプレート参照を格納した配列に参照がpushされてしまいます。<br>v-forとは関係のない部分のDOMの更新であっても、テンプレート参照の配列に同じテンプレート参照が何度も何度もpushされてしまい、意図したものが得られなくなります。<br>ですので、<strong class="yellow-line">次のようなコードを書いて更新処理が走る前にテンプレート参照の配列を一旦空にする必要があります</strong>。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">onBeforeUpdate(() => {\n' +
      '  divs.value = &#91;]\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="watch">テンプレート参照とマウント、watchのタイミング</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下v-forを5回繰り返して生成した要素を考え、テンプレート参照が行われるタイミングや動作などを見ていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">要素とコードが紐づくタイミング</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要素はbeforeMountの後にコードと紐付きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const setDivRef = (el: any) =&gt; {\n' +
      '  if (el) {\n' +
      '    divs.value.push(el)\n' +
      '    console.log("push")//v-forは5回繰り返す\n' +
      '  }\n' +
      '}\n' +
      '\n' +
      "console.log('created')\n" +
      "onBeforeMount(() =&gt; console.log('beforeMount'))\n" +
      "onMounted(() =&gt; console.log('mounted'))</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードの出力結果は次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">created\n' +
      'beforeMount\n' +
      'push\n' +
      'push\n' +
      'push\n' +
      'push\n' +
      'push\n' +
      'mounted</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>確かにbeforeMount〜mountedの間にテンプレート参照がpushされていることが分かります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>したがって、setup直下にコードを書いても(createdのタイミングなので)テンプレート参照した要素にはアクセスできません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//v-forは5回繰り返すのでdivsには5個要素が入るが\n' +
      'const divs = ref&lt;HTMLElement&#91;]>(&#91;])\n' +
      "console.log('created', divs.value.length) // 0になってしまう</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>マウント後なら次のコードのようにきちんとアクセスできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">onMounted(() => console.log('mounted', divs.value.length)) //5</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">ウォッチを用いる場合</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>テンプレート参照をwatchEffectで監視するケースを考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watchEffectをそのまま利用すると、テンプレート参照がpushされる度にウォッチが作動します。<br>また、初回(生成時)と2回目以降(push時)の実行タイミングも異なります。初回はcreated後、2回目以降はbeforeMount後です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">console.log('created',divs.value.length)\n` +
      "onBeforeMount(() => console.log('before mount',divs.value.length))\n" +
      "onMounted(() => console.log('mounted', divs.value.length))\n" +
      'watchEffect(() => console.log("watchEffect", divs.value.length))</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードの出力は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">created 0\n' +
      'watchEffect 0\n' +
      'before mount 0\n' +
      'watchEffect 1\n' +
      'watchEffect 2\n' +
      'watchEffect 3\n' +
      'watchEffect 4\n' +
      'watchEffect 5\n' +
      'mounted 5</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>watchEffectのflushのタイミングをpostにすると、mountedの直前に１回のみ呼ばれるようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">console.log('created',divs.value.length)\n` +
      "onBeforeMount(() => console.log('before mount',divs.value.length))\n" +
      "onMounted(() => console.log('mounted', divs.value.length))\n" +
      `watchEffect(() => console.log("watchEffect", divs.value.length), {flush: 'post'})</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードの出力は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">created 0\n' +
      'before mount 0\n' +
      'watchEffect 5\n' +
      'mounted 5</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>確かに、mounted直前に1回だけ呼び出されていることが分かります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>v-forを指定した要素にテンプレート参照をする方法と、使用の際の注意点についてまとめました。<br>実行タイミングやDOM更新時の注意点には特に気をつけて利用する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n',
    date: '2022-01-23T14:26:07',
    categories: { nodes: [Array] },
    title: 'v-for指定した要素のテンプレート参照方法【Vue3】',
    featuredImage: { node: [Object] },
    uri: '/vue3-v-for-and-ref/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-1699
203 wp-image-1700
203 wp-image-1701
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
info  - Generating static pages (29/59)
101010101010101010 {
  post: {
    content: '\n' +
      '<p>最新のTypeScript4.5から、TypeScript4.0に遡って新機能をまとめています。まとめてある内容は文法レベルの新機能で、細かい仕様変更についてはまとめていません。ざっと新機能だけを確認するのが目的です。記事の後ろに行けば行くほど古いバージョンについて書いているため、知っているバージョンまでスクロールする必要はありません。各見出しの後には、公式ドキュメント(英語)に対応する項目を記載しております。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#TypeScript_46"><span class="toc_number toc_depth_1">1</span> TypeScript 4.6以降について</a></li><li><a href="#TypeScript_45"><span class="toc_number toc_depth_1">2</span> TypeScript 4.5</a><ul><li><a href="#AwaitedPromise"><span class="toc_number toc_depth_2">2.1</span> Awaited型とPromiseの改良</a></li></ul></li><li><a href="#TypeScript_44"><span class="toc_number toc_depth_1">3</span> TypeScript 4.4</a><ul><li><a href="#Symbol"><span class="toc_number toc_depth_2">3.1</span> Symbol型とテンプレートリテラル型をキーとするインデックスシグネチャ</a></li><li><a href="#static"><span class="toc_number toc_depth_2">3.2</span> クラスにstaticブロックの追加</a></li></ul></li><li><a href="#TypeScript_43"><span class="toc_number toc_depth_1">4</span> TypeScript 4.3</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">4.1</span> ゲッタとセッタの型を別々に指定できる</a></li><li><a href="#override"><span class="toc_number toc_depth_2">4.2</span> override修飾子</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">4.3</span> テンプレートリテラル型の改良</a></li></ul></li><li><a href="#TypeScript_42"><span class="toc_number toc_depth_1">5</span> TypeScript 4.2</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">5.1</span> タプルのレストパラメータを好きな位置に記述できる</a></li><li><a href="#abstract"><span class="toc_number toc_depth_2">5.2</span> abstractコンストラクタシグネチャ</a></li></ul></li><li><a href="#TypeScript_41"><span class="toc_number toc_depth_1">6</span> TypeScript 4.1</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">6.1</span> テンプレートリテラル型の追加</a></li><li><a href="#Map"><span class="toc_number toc_depth_2">6.2</span> Map型のキー名を変更できる</a></li><li><a href="#Conditional"><span class="toc_number toc_depth_2">6.3</span> 再帰的なConditional 型</a></li></ul></li><li><a href="#TypeScript_40"><span class="toc_number toc_depth_1">7</span> TypeScript 4.0</a><ul><li><a href="#i-5"><span class="toc_number toc_depth_2">7.1</span> 可変タプル型</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">7.2</span> ラベル付きタプル</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">7.3</span> コンストラクタからプロパティの型を推論</a></li><li><a href="#Null"><span class="toc_number toc_depth_2">7.4</span> 短絡演算、Null合体演算の複合演算子</a></li><li><a href="#catchunknown"><span class="toc_number toc_depth_2">7.5</span> catchするエラーの型をunknown型にできる</a></li></ul></li><li><a href="#i-8"><span class="toc_number toc_depth_1">8</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="TypeScript_46">TypeScript 4.6以降について</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>長くなったので別記事にまとめてあります。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/new-features-in-typescript4-2"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/new-features-in-typescript4-2</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">TypeScript4.9~4.6の新機能まとめ</div></div><div class="lkc-excerpt">TypeScript4.9からTypeScript4.6に遡って新機能をまとめています。4.5以前の内容は別記事にまとめています。まとめてある内容は文法レベルの新機能で、細かい改良及び仕...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript_45">TypeScript 4.5</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="AwaitedPromise">Awaited型とPromiseの改良</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名：「The Awaited Type and Promise Improvements」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Awaited型が導入されました。Promiseを再帰的にアンラップできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">type A = Awaited&lt;Promise&lt;number>> // A = number\n' +
      'type B = Awaited&lt;Promise&lt;Promise&lt;string>>> // B = string \n' +
      'type C = Awaited&lt;string | Promise&lt;string> | PromiseLike&lt;string>> // C = string</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これによってPromise.allをうまく推論してくれます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">declare function MaybePromise&lt;T&gt;(value: T): T | Promise&lt;T&gt; | PromiseLike&lt;T&gt;\n' +
      'async function doSomething(): Promise&lt;[number, number]&gt; {\n' +
      '  const result = await Promise.all([MaybePromise(100), MaybePromise(200)])\n' +
      '  // resultの型は4.4以前では\n' +
      '  // [number | Promise&lt;100&gt;, number | Promise&lt;200&gt;]\n' +
      '  // と推論されてエラーが出る\n' +
      '  // 4.5ではAwaited&lt;MaybePromise&lt;T&gt;(value: T): T | Promise&lt;T&gt; | PromiseLike&lt;T&gt;&gt;\n' +
      '  // = T となりうまく推論される\n' +
      '  return result\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="TypeScript_44">TypeScript 4.4</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Symbol">Symbol型とテンプレートリテラル型をキーとするインデックスシグネチャ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><meta charset="utf-8">項目名：「<meta charset="utf-8">Symbol and Template String Pattern Index Signatures」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>インデックスシグネチャのキーに、Symbol型とテンプレートリテラル型を利用できるようになりました。従来はnumber型とstring型のみでした。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">interface Options {\n' +
      '  //キーが""data-"から始まるプロパティのみ受け付ける\n' +
      '  &#091;key: `data-${string}`]: number,\n' +
      '  //値がSymbol型のキーも受け付ける\n' +
      '  &#091;key: symbol]: string\n' +
      '}\n' +
      'let a: Options = {\n' +
      "  'data-hoge': 0,\n" +
      "  'data-fuga': 2,\n" +
      "  // 'piyo': 3 //エラー,\n" +
      '}\n' +
      '//キーとして利用\n' +
      'const mySymbol = Symbol()\n' +
      'a&#091;mySymbol] = "symbol"</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="static">クラスにstaticブロックの追加</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><meta charset="utf-8">項目名：「<meta charset="utf-8">Static Blocks in Classes」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>クラスにstaticブロックを作成できるようになりました。このブロックはクラス定義をするだけで呼び出されます。staticメンバの初期化等に使えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">class MyClass {\n' +
      '  static {\n' +
      '    console.log("hoge") //インスタンスを作成しないでも出力される\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript_43">TypeScript 4.3</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">ゲッタとセッタの型を別々に指定できる</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>項目名：「<meta charset="utf-8">Separate Write Types on Properties」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ゲッタとセッタの型に別の型を定義することが可能となります。<br>従来は、「セッタの引数の型」と「ゲッタの戻り値の型」は統一する必要があり、型を明示していない場合にも自動的に統一されていました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>4.3からは「ゲッタの戻り値の型」と「セッタの引数の型」を別の型にすることが出来ます。ただし、「ゲッタの戻り値の型」は「セッタの引き数の型」に割り当て可能でなければなりません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">class MyClass {\n' +
      '    #size: number = 0\n' +
      '    get size(): number { //従来は number | stringしか指定できなかった\n' +
      '        return this.#size\n' +
      '    }\n' +
      '    set size(n: number | string) {\n' +
      '        if (typeof n === "string") {\n' +
      '            this.#size = Number(n)\n' +
      '        } else if (typeof n === "number")\n' +
      '            this.#size = n\n' +
      '    }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="override">override修飾子</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><meta charset="utf-8">項目名：「override and the &#8211;noImplicitOverride Flag」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オーバーライドするメソッドに<code class="language-ts">override</code>キーワードをつけると、オーバーライドであることを明示的に宣言できるようになりました。<code class="language-ts">override</code>を付けたメソッドが先祖で定義されていなければエラーを出してくれます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">class MyClass {\n' +
      '  protected hoge() {}\n' +
      '  public fuga() {}\n' +
      '}\n' +
      'class MyChild extends MyClass{\n' +
      '  override hoge() {}\n' +
      '//  　　override piyo() {} //親クラスで定義されていないのでエラー\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、&#8211;noImplicitOverride Flagをつけるとオーバーライドするメソッドに<code class="language-ts">override</code>キーワードの付与を強制できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>公式ページでoverrideの説明と一緒にフラグの紹介がされていたため、まとめて紹介しました。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">テンプレートリテラル型の改良</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><meta charset="utf-8">項目名：「Template String Type Improvements」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>テンプレートリテラル型の改善です。<br>次のような代入が可能となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">declare let s1: `${number}-${number}-${number}`;\n' +
      'declare let s2: `${number}-2-3`;\n' +
      's1 = s2;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="TypeScript_42">TypeScript 4.2</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">タプルのレストパラメータを好きな位置に記述できる</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><meta charset="utf-8">項目名：「Leading/Middle Rest Elements in Tuple Types」</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>タプルのレストパラメータを、要素の好きな位置に置けるようになりました。<br>4.1以前はタプルの最後にしか置けませんでした。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">//最初に置く\n' +
      'let ary: &#091;...string&#091;], number]\n' +
      'ary = &#091;2]\n' +
      'ary = &#091;"hoge", 4]\n' +
      'ary = &#091;"hoge", "fuga", 10]\n' +
      '//間に置く\n' +
      'let ary2: &#091;string, ...number&#091;], boolean]\n' +
      'ary2 = &#091;"hoge", true]\n' +
      'ary2 = &#091;"hoge", 2, false]\n' +
      'ary2 = &#091;"hoge", 10, 23, 2, false]</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この機能を利用すれば、レストパラメータを最初に受け取る関数を定義することが出来ます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">function hoge(...args: &#091;...nums: number&#091;], flag: boolean]) {\n' +
      '    let nums = args.slice(0, args.length-1)//先行レストパラメータ\n' +
      '    let flag = args&#091;args.length]\n' +
      '    //\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ただし、レストパラメータは1つしか使用できません。<br>また、オプショナルパラメータを使う場合はレストパラメータを最後以外には置けません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">// let ary3: &#091;string, ...number&#091;], ...string&#091;]] //エラー：レストパラメータが2つある\n' +
      '// let ary4: &#091;boolean, ...number&#091;], string?] //エラー：オプショナルパラメータがあるのにレストパラメータが最後にない\n' +
      'let ary5: &#091;boolean?, ...number&#091;]] // OK</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="abstract">abstractコンストラクタシグネチャ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="u'... 10174 more characters,
    date: '2022-01-02T18:45:35',
    categories: { nodes: [Array] },
    title: 'TypeScript4.5~4.0の新機能まとめ',
    featuredImage: { node: [Object] },
    uri: '/new-features-in-typescript4/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>記事のサイドバーにある「追従する目次」の作り方を紹介します。また、単に追従させるだけではなく、更に「現在位置のハイライト機能」と「現在位置に応じた目次自体のスクロール機能」を搭載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 作成する目次の仕様</a></li><li><a href="#HTML"><span class="toc_number toc_depth_1">2</span> 目次のHTMLコードを出力する</a><ul><li><a href="#1_0"><span class="toc_number toc_depth_2">2.1</span> ケース1: 自力で0から作成する方法</a></li><li><a href="#2WordPress"><span class="toc_number toc_depth_2">2.2</span> ケース2:WordPressを使っている場合</a></li></ul></li><li><a href="#CSS"><span class="toc_number toc_depth_1">3</span> CSSでスティッキーにする</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">4</span> ハイライト機能の実装</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">4.1</span> 各見出しの絶対位置を取得する</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">4.2</span> スクロール位置と要素の位置を比較する</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 目次の高さ制限、自動スクロール機能の実装</a><ul><li><a href="#i-6"><span class="toc_number toc_depth_2">5.1</span> はみ出る目次への対処方法</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">5.2</span> スクロールする目次の実装</a></li></ul></li><li><a href="#i-8"><span class="toc_number toc_depth_1">6</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">作成する目次の仕様</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回作成する目次の仕様は以下のとおりです。本ブログで搭載している目次になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>サイドバーに常に表示されており、自動的に追従する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>現在の見出しをハイライトする</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>目次の高さを制限して、自動的にスクロールするようにする</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/01/sideindex0-1024x682.png" alt="" class="wp-image-1636" width="512" height="341" srcset="https://tekrog.com/wp-content/uploads/2022/01/sideindex0-1024x682.png 1024w, https://tekrog.com/wp-content/uploads/2022/01/sideindex0-300x200.png 300w, https://tekrog.com/wp-content/uploads/2022/01/sideindex0-768x511.png 768w, https://tekrog.com/wp-content/uploads/2022/01/sideindex0.png 1068w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは目次の作り方を、順を追って説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="HTML">目次のHTMLコードを出力する</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは目次のHTMLコードを作成します。<br>『①自力で０から作成する方法』と『②WordPressを用いてる場合の簡単な方法』の2ケース紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="1_0">ケース1: 自力で0から作成する方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次の手順で作成していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly">\n' +
      '<li>① 目次にしたい要素(h2やh3)にID属性を指定する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>② 目次にしたい要素の『テキスト』を取得する</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>③ 目次のHTMLを組み立てる</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>順に説明していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①目次にしたい要素にID属性を指定する</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>話は簡単で、id=~ でIDを割り振っていきます。次のように手動で振っても良いですが、プログラムを書いたほうがミスは少なくなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;h2 id="titleA">タイトルA&lt;/h2>\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>プログラムで振る場合は、document.querySelector等でh2やh3の要素を取得し、setAttributeメソッドを用いて記事全体で名前が一意になるようなID要素をつけます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>② 目次にしたい要素の『テキスト』を取得する</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>document.querySelector等でh2, h3の要素を指定し、innerTextメソッドでタイトルの文字列を取得します。なお、この処理は①と同時に行っても構いません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>③目次のHTMLを組み立てる</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①,②で取得した要素を用いて、スクリプトで次のような構造で目次を組み立てます。名前は何でも構いませんが、この記事では次の名前で統一します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1.png" alt="" class="wp-image-1646" width="777" height="499" srcset="https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1.png 1553w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-300x193.png 300w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-1024x657.png 1024w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-768x493.png 768w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-1536x986.png 1536w" sizes="(max-width: 777px) 100vw, 777px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上で下準備は終わりです。次のケース2の章はWordPress専用なので飛ばしてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="2WordPress">ケース2:WordPressを使っている場合</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>WordPressを使っているならば、<strong>Table of Contents Plus</strong>というプラグインで、簡単かつ自動的に目次を出力することが出来ます。ケース１の方法で実装した場合はこの章は飛ばしてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①functions.phpでウジェットエリアの登録</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ウィジェットを利用していない場合は、funtions.phpでサイドバーのウィジェットエリアの登録を行います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//functions.php\n' +
      "add_action('widgets_init', function() {\n" +
      '  register_sidebar([\n' +
      "    'id' =&gt; 'sidebar-1',\n" +
      "    'name' =&gt; 'sidebar',\n" +
      '  ]);\n' +
      '});</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p>ウィジェットはデフォルトで<code class="language-html">&lt;li id="toc-widget-3"&gt;</code>タグに囲まれて出力されますが、<code class="language-php">'before_widget'</code>キーと<code class="language-php">'after_widget'</code>キーを記述すると出力するタグを他のタグにすることも出来ます。次のコードは<code class="language-html">&lt;aside&gt;</code>タグにする例です。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//functions.php(出力タグを指定)\n' +
      "add_action('widgets_init', function() {\n" +
      '  register_sidebar([\n' +
      "    'id' =&gt; 'sidebar-1',\n" +
      "    'name' =&gt; 'sidebar',\n" +
      `    'before_widget' =&gt; '&lt;aside id="%1$s" class="widget %2$s %1$s"&gt;&lt;div class="%2$s-inner"&gt;',\n` +
      "    'after_widget' =&gt; '&lt;/div&gt;&lt;/aside&gt;'\n" +
      '  ]);\n' +
      '});</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>%1$sはtoc-widget-3に、%2$sはtoc_widgetに置換されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②Table of Contents Plusプラグインの追加</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Table of Contents Plus(通称TOC+)を追加して有効化します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>③TOC+ウィジェットの登録</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>WordPressの管理画面→「外観」→「ウィジェット」からTOC+のウィジェットを登録します。先程functions.phpで<code class="language-php">register_sidebar()</code>を記述しましたが、その際に引数で渡した連想配列のname属性(今回はsidebar)がウィジェットに表示されています。そこに登録して下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5-1024x472.png" alt="" class="wp-image-1629" width="512" height="236" srcset="https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5-1024x472.png 1024w, https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5-300x138.png 300w, https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5-768x354.png 768w, https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5-1536x707.png 1536w, https://tekrog.com/wp-content/uploads/2022/01/34294fca89d909209b4185724c2ffaf5.png 1646w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>④テンプレートで出力</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>サイドバーのテンプレートファイルにおいて、目次を出力したい場所に以下の記述を追加します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-php">dynamic_sidebar('sidebar-1');</code></pre>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下サイドバー直下に記述したものとして説明を進めます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>結果として出力されるHTML構造は次のようになります。<br>比較のため、本サイトで利用している実際の目次の画像も右に掲載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1.png" alt="" class="wp-image-1646" width="777" height="499" srcset="https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1.png 1553w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-300x193.png 300w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-1024x657.png 1024w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-768x493.png 768w, https://tekrog.com/wp-content/uploads/2022/01/sideindex8-1-1536x986.png 1536w" sizes="(max-width: 777px) 100vw, 777px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>#toc-widget-3全体が目次を表しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>自分で目次のコードを書いた場合も、概ね上のような構造にすると今回紹介する方法が適用できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="CSS">CSSでスティッキーにする</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>目次の<strong>1番外側の要素</strong>のCSSをposition: stickyに指定します。<br>ウィジェットを他の要素でラップしていない限りは、#toc-widget-3が目次の一番外側の要素になります。<br>ここで、<strong>サイドエリアの高さは記事の高さいっぱい</strong>にしないと上手く動作しません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2022/01/sideindex.png" alt="" class="wp-image-1630" width="417" height="357" srcset="https://tekrog.com/wp-content/uploads/2022/01/sideindex.png 834w, https://tekrog.com/wp-content/uploads/2022/01/sideindex-300x256.png 300w, https://tekrog.com/wp-content/uploads/2022/01/sideindex-768x657.png 768w" sizes="(max-width: 417px) 100vw, 417px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>topの指定も忘れずにしましょう。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-css">#toc-widget-3 {\n' +
      '  position: sticky;\n' +
      '  top: 30px;\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここまでのコードで追従する目次の最低要件は満たせます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">ハイライト機能の実装</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いてハイライト機能を実装します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">各見出しの絶対位置を取得する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは目次にする要素の絶対位置を取得します。絶対位置とは、ブラウザの最上部からの距離、長さのことです。<br>絶対位置の詳しい取得方法は以下の記事で説明しています。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/get-absolute-position"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/get-absolute-position</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/10/get-element-position-thumb-1-150x150.png" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">HTML要素の位置を取得する方法とズレた場合の対処法</div></div><div class="lkc-excerpt">この記事では、ページの一番上からHTML要素までの大きさ、要素の位置の取得方法を説明します。ただし、JavaScriptのコードの記述場所に注意しないと取得した値がずれて...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここでは、h2とh3の要素のみを考えます。これらの絶対位置を取得するコードは次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-js">//single-contentを記事のクラスとし、記事内のh2、h3のみ取得\n' +
      "const headingContents = document.querySelectorAll('.single-content h2, .single-content h3')\n" +
      '\n' +
      '//各見出しの絶対位置\n' +
      'let headingPos = headingPos = [...headingContents].map(element =&gt; Mat'... 7074 more characters,
    date: '2022-01-12T21:08:03',
    categories: { nodes: [Array] },
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    featuredImage: { node: [Object] },
    uri: '/following-side-index/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-1636
203 wp-image-1646
203 wp-image-1629
203 wp-image-1646
203 wp-image-1630
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1633
203 wp-image-1638
203 wp-image-1634
203 wp-image-1635
203 wp-image-1645
203 wp-image-1661
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>ラグランジュの未定乗数法は「ある条件下で関数の極値を求める」方法です。2変数で等式制約のケースの解き方は大学の初等数学で習いますが、3次元以上の「多変数」の場合や「不等式制約」におけるラグランジュの未定乗数法は、実際に応用されている場所で初めて出くわすかもしれません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では「多変数・N変数のラグランジュの未定乗数法」とその解き方を、「等式制約」の場合と「不等式制約」の場合に分けて解説します。さらに「不等式制約」について2次計画問題と呼ばれるものについて説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> ラグランジュの未定乗数法(等式制約)</a><ul><li><a href="#1"><span class="toc_number toc_depth_2">2.1</span> 制約条件が1つの場合</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">2.2</span> 制約条件が複数の場合</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">3</span> ラグランジュの未定乗数法(不等式制約)</a></li><li><a href="#2"><span class="toc_number toc_depth_1">4</span> 2次計画問題</a><ul><li><a href="#i-5"><span class="toc_number toc_depth_2">4.1</span> 凸関数</a></li><li><a href="#2QP"><span class="toc_number toc_depth_2">4.2</span> 2次計画問題(QP)</a></li><li><a href="#QP"><span class="toc_number toc_depth_2">4.3</span> QPの解法</a></li></ul></li><li><a href="#i-6"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>前提となる知識</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>N変数(多変数)の関数とその偏微分・勾配</li><li>N次元ベクトルとその性質</li><li>超曲面や等高線の法線ベクトル</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それぞれ以下の記事から短時間で学べます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①N次元ベクトルについて</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-vector-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-vector-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習のベクトル</div></div><div class="lkc-excerpt">機械学習の理解にあたって最も重要なの概念はベクトルです。しかし高校で習うベクトルは基礎の基礎で、機械学習を学べるレベルのものではありません。そこで、この記事...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②N変数関数と偏微分について</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-differential-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-differential-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-partialdeff-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習の微分と多変数関数</div></div><div class="lkc-excerpt">微分は高校生でも習いますが、機械学習で出てくる微分の理解には大学数学の知識が必要です。しかし0から大学数学の微積分を学ぼうとするのは遠回りかもしれません。この...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>③超曲面や法線ベクトルについて</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/normal-vector-of-hypersurface-and-contour"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/normal-vector-of-hypersurface-and-contour</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-noraml-vector-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">超曲面や等高線の法線ベクトルを直感的に理解する</div></div><div class="lkc-excerpt">この記事ではN次元空間における「超曲面と等高線(等値面)の法線ベクトル」の公式について、図と例を用いて直感的に分かりやすく説明しています。大学の初等数学が分かれ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>この記事の目的・目標</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事はサポートベクターマシンの数式を理解することを主な目標に書いております。<br>ですので、この記事の最終目的は「不等式制約付きの２次計画問題をラグランジュの未定乗数法で解く」ところにあります。そこに向けて記事を書いていきますが、「サポートベクターマシンはどうでも良くてラグランジュの未定乗数法だけ知りたい」という方も対象となっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">ラグランジュの未定乗数法(等式制約)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="1">制約条件が1つの場合</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="def"><strong>【定理】</strong><br><?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="1.373ex" height="1.005ex" role="img" focusable="false" viewBox="0 -444 607 444" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: 0px;"><defs><path id="MJX-464-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D431" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-464-TEX-B-1D431"/></g></g></g></g></svg>をn次元ベクトルとする。<br>このとき、条件<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="8.361ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3695.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-1017-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-1017-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-1017-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/><path id="MJX-1017-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-1017-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-1017-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D454" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-I-1D454"/></g><g data-mml-node="mo" transform="translate(477,0)"><use data-c="28" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-N-28"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(866,0)"><g data-mml-node="mi"><use data-c="1D431" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-B-1D431"/></g></g><g data-mml-node="mo" transform="translate(1473,0)"><use data-c="29" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(2139.8,0)"><use data-c="3D" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(3195.6,0)"><use data-c="30" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1017-TEX-N-30"/></g></g></g></svg>の下で関数<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="4.378ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1935 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-1023-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -'... 239576 more characters,
    date: '2021-12-31T13:05:39',
    categories: { nodes: [Array] },
    title: '多変数のラグランジュの未定乗数法と2次計画問題',
    featuredImage: { node: [Object] },
    uri: '/method-of-lagrange-multiplier/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1344
203 wp-image-1530
203 wp-image-1342
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1412
203 wp-image-1356
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>この記事ではN次元空間における「超曲面と等高線(等値面)の法線ベクトル」の公式について、図と例を用いて直感的に分かりやすく説明しています。大学の初等数学が分かれば読める内容となっています。これが理解できれば、ラグランジュの未定乗数法や機械学習にも応用できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 超曲面と等値面</a><ul><li><a href="#N"><span class="toc_number toc_depth_2">2.1</span> N変数関数は超曲面を表す</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">2.2</span> 等高線の表示方法</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">3</span> 超曲面の法線ベクトル</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">4</span> 超曲面の等高線の法線ベクトル</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>前提知識となる知識</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では以下のような大学数学の概念が登場します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>N次元ベクトルの性質や演算方法 </li><li>N変数関数・多変数関数の偏微分・勾配 </li><li>陽関数と陰関数</li><li>テイラー展開</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これらについてご存知ない方は、以下の記事をご覧ください。短時間で学べます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①N次元ベクトルについて</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-vector-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-vector-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習のベクトル</div></div><div class="lkc-excerpt">機械学習の理解にあたって最も重要なの概念はベクトルです。しかし高校で習うベクトルは基礎の基礎で、機械学習を学べるレベルのものではありません。そこで、この記事...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②N変数関数と偏微分について</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-differential-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-differential-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-partialdeff-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習の微分と多変数関数</div></div><div class="lkc-excerpt">微分は高校生でも習いますが、機械学習で出てくる微分の理解には大学数学の知識が必要です。しかし0から大学数学の微積分を学ぼうとするのは遠回りかもしれません。この...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">超曲面と等値面</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="N">N変数関数は超曲面を表す</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>N変数からなる関数をN次元ベクトル<strong>x</strong>を用いて</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="25.51ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11275.5 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-8050-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-8050-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-8050-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-8050-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-8050-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-8050-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-8050-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path id="MJX-8050-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/><path id="MJX-8050-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-8050-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-8050-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D453" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-I-1D453"/></g><g data-mml-node="mo" transform="translate(550,0)"><use data-c="28" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-28"/></g><g data-mml-node="msub" transform="translate(939,0)"><g data-mml-node="mi"><use data-c="1D465" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-I-1D465"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><use data-c="31" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-31"/></g></g><g data-mml-node="mo" transform="translate(1947.6,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2C"/></g><g data-mml-node="msub" transform="translate(2392.2,0)"><g data-mml-node="mi"><use data-c="1D465" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-I-1D465"/></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><use data-c="32" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-32"/></g></g><g data-mml-node="mo" transform="translate(3400.8,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(3845.4,0)"><use data-c="2E" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2E"/></g><g data-mml-node="mo" transform="translate(4290.1,0)"><use data-c="2E" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2E"/></g><g data-mml-node="mo" transform="translate(4734.8,0)"><use data-c="2E" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2E"/></g><g data-mml-node="mo" transform="translate(5179.4,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-N-2C"/></g><g data-mml-node="msub" transform="translate(5624.1,0)"><g data-mml-node="mi"><use data-c="1D465" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-8050-TEX-I-1D465"/>'... 284548 more characters,
    date: '2021-12-31T13:02:40',
    categories: { nodes: [Array] },
    title: '超曲面や等高線の法線ベクトルを直感的に理解する',
    featuredImage: { node: [Object] },
    uri: '/normal-vector-of-hypersurface-and-contour/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>機械学習の理解にあたって最も重要なの概念はベクトルです。しかし高校で習うベクトルは基礎の基礎で、機械学習を学べるレベルのものではありません。そこで、この記事では高校レベルのベクトルを理解している人に向けて、機械学習を理解するために必要最低限なベクトルの知識をまとめます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 表記の違い</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 諸概念</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">3.1</span> 転置</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">3.2</span> 内積</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">3.3</span> ノルム</a></li></ul></li><li><a href="#4"><span class="toc_number toc_depth_1">4</span> 4次元以上のベクトル</a><ul><li><a href="#N4"><span class="toc_number toc_depth_2">4.1</span> N次元〜4次元以上の空間〜</a></li><li><a href="#N"><span class="toc_number toc_depth_2">4.2</span> N次元ベクトル</a></li><li><a href="#N-2"><span class="toc_number toc_depth_2">4.3</span> N次元ベクトルの諸演算</a></li></ul></li><li><a href="#i-7"><span class="toc_number toc_depth_1">5</span> まとめ</a></li><li><a href="#i-8"><span class="toc_number toc_depth_1">6</span> (補足)さらにベクトルを学びたい人へ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>前提知識</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>高校で習うベクトルの知識のみ。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>目的</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>機械学習に必要なベクトルの知識を速習する。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>扱うトピック</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では以下のトピックを扱います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>大学以降でのベクトルの表記方法について</li><li>列ベクトル・行ベクトルの違い</li><li>転置</li><li>ノルム</li><li>N次元ベクトル</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これらのことについてご存知ない方を対象とした記事になります。<br>それでは解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">表記の違い</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>矢印は付けない</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>専門書を読むにあたって、まず気をつけたいのが表記の違いです。<br>高校数学でベクトルは<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="3.497ex" height="2.351ex" role="img" focusable="false" viewBox="0 -845 1545.7 1039" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-1032-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-1032-TEX-N-20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"/><path id="MJX-1032-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-1032-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><use data-c="1D44E" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1032-TEX-I-1D44E"/></g><g data-mml-node="mo" transform="translate(264.5,30) translate(-250 0)"><use data-c="20D7" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1032-TEX-N-20D7"/></g></g></g><g data-mml-node="mo" transform="translate(529,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1032-TEX-N-2C"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(973.7,0)"><g data-mml-node="mover"><g data-mml-node="mi"><use data-c="1D465" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1032-TEX-I-1D465"/></g><g data-mml-node="mo" transform="translate(313.8,31) translate(-250 0)"><use data-c="20D7" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1032-TEX-N-20D7"/></g></g></g></g></g></svg>のようにアルファベットの上に矢印をつけて表していました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>しかし大学以降でこの記述を見ることはほとんど無く、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="3.87ex" height="1.462ex" role="img" focusable="false" viewBox="0 -452 1710.7 646" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-1170-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/><path id="MJX-1170-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-1170-TEX-BI-1D499" d="M74 282H63Q43 282 43 296Q43 298 45 307T56 332T76 365T110 401T159 433Q200 451 233 451H236Q273 451 282 450Q358 437 382 400L392 410Q434 452 483 452Q538 452 568 421T599 346Q599 303 573 280T517 256Q494 256 478 270T462 308Q462 343 488 367Q501 377 520 385Q520 386 516 389T502 396T480 400T462 398Q429 383 415 341Q354 116 354 80T405 44Q449 44 485 74T535 142Q539 156 542 159T562 162H568H579Q599 162 599 148Q599 135 586 111T550 60T485 12T397 -8Q313 -8 266 35L258 44Q215 -7 161 -7H156Q99 -7 71 25T43 95Q43 143 70 165T125 188Q148 188 164 174T180 136Q180 101 154 77Q141 67 122 59Q124 54 136 49T161 43Q183 43 200 61T226 103Q287 328 287 364T236 400Q200 400 164 377T107 302Q103 288 100 285T80 282H74Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D431" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1170-TEX-B-1D431"/></g></g><g data-mml-node="mo" transform="translate(607,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1170-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1051.7,0)"><use data-c="1D499" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1170-TEX-BI-1D499"/></g></g></g></svg>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>のように<strong class="yellow-line">小文字かつ太文字で表現するのが一般的です。</strong>書籍によって立体だったりイタリック体だったりします。</p><p>というのも、大学以降の数学では表記が統一されていません。<br>私は立体の太文字が好みなので、以降<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="3.644ex" height="1.464ex" role="img" focusable="false" viewBox="0 -453 1610.7 647" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-1179-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/><path id="MJX-1179-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-1179-TEX-B-1D41A" d="M64 349Q64 399 107 426T255 453Q346 453 402 423T473 341Q478 327 478 310T479 196V77Q493 63 529 62Q549 62 553 57T558 31Q558 9 552 5T514 0H497H481Q375 0 367 56L356 46Q300 -6 210 -6Q130 -6 81 30T32 121Q32 188 111 226T332 272H350V292Q350 313 348 327T337 361T306 391T248 402T194 399H189Q204 376 204 354Q204 327 187 306T134 284Q97 284 81 305T64 349ZM164 121Q164 89 186 67T238 45Q274 45 307 63T346 108L350 117V226H347Q248 218 206 189T164 121Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D431" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1179-TEX-B-1D431"/></g></g><g data-mml-node="mo" transform="translate(607,0)"><use data-c="2C" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1179-TEX-N-2C"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1051.7,0)"><g data-mml-node="mi"><use data-c="1D41A" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-1179-TEX-B-1D41A"/></g></g></g></g></svg>で統一します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>手書きするときは縦線をつける</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>矢印を付けずに太文字で記述されてることは分かりました。では自分で手書きするときはどうするのでしょうか。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">一般的に、縦線や斜め線を変数につけて、ベクトルでない変数(スカラ)と区別します。</strong><br>以下にいくつか例を挙げます。ここらへんも厳密な記述の決まりはありません。スカラと区別されていればOKです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding'... 113229 more characters,
    date: '2021-12-31T12:54:25',
    categories: { nodes: [Array] },
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    featuredImage: { node: [Object] },
    uri: '/basic-vector-for-ml/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>モダンなJavaScriptの開発ではPromiseやasync、awaitの利用が欠かせません。今回はこれらの意味について極限まで簡単にして説明します。10分程度で理解できる内容です。この内容を理解すれば、今後出くわすであろう、応用的なコードについても理解できるはずです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Proimse_async_await"><span class="toc_number toc_depth_1">1</span> Proimse/ async / awaitの基本</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">1.1</span> 意味と使いどころ</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">1.2</span> 使い方の概要</a></li></ul></li><li><a href="#Proimse_async_await-2"><span class="toc_number toc_depth_1">2</span> Proimse/ async / awaitの使い方</a><ul><li><a href="#Promise"><span class="toc_number toc_depth_2">2.1</span> ①非同期処理をPromiseでラップする</a></li><li><a href="#await"><span class="toc_number toc_depth_2">2.2</span> ②awaitで非同期処理が終わるのを待つ</a></li><li><a href="#awaitasync"><span class="toc_number toc_depth_2">2.3</span> ③awaitを使ったブロックを関数にしてasyncで囲む</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 実用的なコードに向けて</a><ul><li><a href="#Promise-2"><span class="toc_number toc_depth_2">3.1</span> Promiseを違う関数に分離する</a></li><li><a href="#Promise-3"><span class="toc_number toc_depth_2">3.2</span> Promiseが失敗した場合を考える</a></li></ul></li><li><a href="#awaitPromise"><span class="toc_number toc_depth_1">4</span> awaitやPromiseの実行タイミング</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">4.1</span> 連続で呼び出す</a></li><li><a href="#Promise-4"><span class="toc_number toc_depth_2">4.2</span> すぐにPromiseをリターンしない</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 次のステップ</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">6</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="Proimse_async_await">Proimse/ async / awaitの基本</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">意味と使いどころ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Promise、await、asyncの簡単な意味は次の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>それぞれの意味</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol>\n' +
      '<li>Promise: 非同期処理を簡単に扱うためのもの </li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>await: 非同期処理が終わるまで待つもの</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>async: その関数が非同期処理か、普通の関数か区別するためのも</li>\n' +
      '</ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Promise/ async/ awaitを使えば、次のような処理が簡単に読みやすく書けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>以下の処理が簡単に！</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol>\n' +
      '<li>非同期処理を簡単に記述 (コールバック地獄から解放, thenより簡単)</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>複数の非同期処理を同時(並列)に走らせる（配列で指定するだけ）</li>\n' +
      '</ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では最も基本である①の処理について解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②の『複数の非同期処理を同時(並列)』に走らせる方法は次の記事を参考にしてください。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/typescript-promise-cocurrency"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/typescript-promise-cocurrency</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency-150x150.png" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】</div></div><div class="lkc-excerpt">TypeScript/ JavaScriptのPromiseの並列処理メソッド『all, race, allSetteled, any』について、実際のコードと図を用いて分かりやすく解説します。Promiseの並列処理基...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">使い方の概要</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Promise/ await/ asyncは次の3つのステップに分けると理解しやすいです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-vivid-red-color has-text-color"><strong>詳しい意味は順を追って説明しますので、今はわからなくて構いません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>3つのステップ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol>\n' +
      '<li>非同期処理をPromise()で囲み、newする → <strong>new Promise(非同期処理)</strong></li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>new Promise(非同期処理)の左にawaitを付ける →<strong> await new Promise(非同期処理)</strong></li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>awaitを使った一連の処理を関数にして<strong>async</strong>をつける</li>\n' +
      '</ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">今回は非同期処理として、setTimeout()関数を例にして進めていきます。</strong><br>setTimeoutは、コールバックで登録した関数を、指定した秒数(ミリ秒)後に遅延実行してくれる関数です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// 3000ミリ秒 = 3秒後に "Hello World!"が表示される\n' +
      'setTimeout(() => console.log("Hello World!"), 3000)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは使い方を順に解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Proimse_async_await-2">Proimse/ async / awaitの使い方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Promise">①非同期処理をPromiseでラップする</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Promiseとコールバックで囲む</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは非同期処理をPromiseオブジェクトで囲みます。<br><strong class="yellow-line">ただし、そのままラップするのではなく、次のようにPromiseの中でコールバック関数を定義してラップします。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// functionキーワードの例\n' +
      'Promise(function() {\n' +
      '  非同期処理\n' +
      '})\n' +
      '\n' +
      '// アロー関数の例\n' +
      'Promise(() =&gt; 非同期処理)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>つまり「①Promise」と「②コールバック」で2重にラップすることになります。とりあえずはここらへんは決まりとして覚えておいて下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>具体例としてsetTimeoutを考えているので、具体的には次のように書けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">Promise(() => {\n' +
      '  setTimeout(() => console.log("Hello World!"), 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、Promiseはnewをつけないと使えない決まり(インスタンス化しないと使えない)なのでnewも付けます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">new Promise(() => {\n' +
      '  setTimeout(() => console.log("Hello World!"), 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>コールバックに引数を与える</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>先ほどはコールバックを引数なしで呼び出しましたが、<strong class="yellow-line">第一引数を与えて、それを使うことによって「非同期処理が終わったことを非同期処理の外部に伝える」準備ができます。</strong></p>\n' +
      '<p>後で説明しますが、<strong class="yellow-line">外部とはawaitのことで、「非同期処理が終わったことが伝えらえる」までプログラムが止まって待っててくれるようになります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>第一引数にresolveという名前で引数を与えてみます。(resolveという名前は何でもいいです。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">new Promise((resolve) =&gt; {\n' +
      '  setTimeout(() =&gt; console.log("Hello World!"), 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>引数を与えましたがまだ使っていないので、これだけでは非同期処理が終わったことを伝えられません。<br>それではこの第一引数をどう使えば処理が終わったことを伝えられるのでしょうか。<br>それは、<strong class="language-ts">resolve()として、関数として呼び出すだけです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">new Promise((resolve) => {\n' +
      '  setTimeout(() => {\n' +
      '    console.log("Hello World!")\n' +
      '    resolve()\n' +
      '  }, 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これで、3秒後に&#8221;Hello World&#8221;と表示され、その非同期処理が終わったことを外部(await)に伝えることが出来ます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、<strong class="pink-line">resolve(&#8220;hoge&#8221;)のようにresolveに引数を指定することで、「①終わったことを伝える機能」に加えて、「②引数(&#8220;hoge&#8221;)を非同期処理の外部(await)に渡す」ことも可能となります。</strong>実用例では、非同期処理で得たデータを外部に渡したい場合などが該当するでしょう。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Promiseの型について</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上のコードはTypeScriptだとエラーが出ます。Promiseの後ろにジェネリックを付けてresolveの引数の型を指定しなければなりません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="pink-line">new Promise(非同期処理)の返す型は、Promise&lt;T&gt;型のオブジェクトとなります。Tはresolveの引数の型です。</strong>上の例ではresolveの引数はないのでvoidを指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">new Promise&lt;void>((resolve) => {\n' +
      '  setTimeout(() => {\n' +
      '    console.log("Hello World!")\n' +
      '    resolve()\n' +
      '  }, 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えばresolve(&#8220;hoge&#8221;)という呼び出しならばPromise&lt;string&gt;型、resolve(3)ならPromise&lt;number&gt;型となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="await">②awaitで非同期処理が終わるのを待つ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>await句はPromise&lt;T&gt;型のオブジェクトにつけます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>awaitかthenか</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①の次の処理方法は、2択あります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul>\n' +
      '<li class="ulOnly">ケース１：後ろにthen句を続ける<br>ケース２：前にawait句を付ける</li>\n' +
      '</ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">//ケース１\n' +
      'new Promise&lt;void>((resolve) => {\n' +
      '  setTimeout(() => {\n' +
      '    console.log("Hello World!")\n' +
      '    resolve()\n' +
      '  }, 3000)\n' +
      '}).then(/* なんかの処理 */)\n' +
      '//ケース２\n' +
      'await new Promise&lt;void>((resolve) => {\n' +
      '  setTimeout(() => {\n' +
      '    console.log("Hello World!")\n' +
      '    resolve()\n' +
      '  }, 3000)\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回はこの記事のタイトル通りケース２のawait句を使った方法を説明をします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>then句の使い方やawait句との違いはこちらで紹介しています。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/difference-between-then-and-await"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/difference-between-then-and-await</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2023/02/thumb-await-150x150.png" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【Promise】thenとasync/awaitの違い, 使い分けと同時利用法</div></div><div class="lkc-excerpt">JavaScript(TypeScript)のthenについて解説し、async/awaitとの違いを説明した後、使い分けや同時に使うケースなどを紹介します。この記事はTypeScriptで解説しますが、...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>await句には大きく分けて2つの意味があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>awaitの役割</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol>\n' +
      '<li>Promise型の非同期処理が終わるのを待つ</li>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<li>Promise型の非同期処理から値を受け取る</li>\n' +
      '</ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>awaitの意味①：Promise型の非同期処理が終わるまで待つ</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>awaitは、非同期処理が終わるのを待つためのものです。処理がここで一旦止まります。<br><strong class="yellow-line">new Promise(非同期処理) にawaitをつけることで、非同期処理が終わるまでプログラムが待ってくれるようになります。 </strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">// 何らかの処理　....\n' +
      'await new Promise&lt;void>((resolve) => {\n' +
      '  setTimeout(() => resolve(), 5000); //この行で処理が一旦と止まる！！！\n' +
      '});\n' +
      '// ↑の非同期処理が終わったらこの行以降へ進める</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>非同期処理が終わったことを伝えるにはresolve()を呼び出すのでした。つまり、<strong>resolve()が呼ばれるまで、await句が待ってくれる役割を果たします。</strong>そしてresolveが呼ばれた後にawait句の次の行へ進めるようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えば、次のようにawait句が連続している場合、<strong>”各行ごとに”</strong>、非同期処理が終わるのを待ってから次の行へ進みす。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">await new Promise&lt;void>(resolve => setTimeout(() => resolve(), 3000)) //3秒待ってから次の行へ\n' +
      'await new Promise&lt;void>(resolve => setTimeout(() => resolve(), 1000)) //1秒待ってから次の行へ\n' +
      'await new Promise&lt;void>(resolve => setTimeout(() => resolve(), 2000)) //2秒待ってから次の行へ\n' +
      'console.log("hoge")</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>各行で3秒＋１秒＋２秒＝計6秒待つので、最後の行のconsole.logが表示されるのは6秒後となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>awaitを付けなかった場合は非同期処理が終わるのを待っ'... 9812 more characters,
    date: '2021-12-23T17:38:11',
    categories: { nodes: [Array] },
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    featuredImage: { node: [Object] },
    uri: '/learn-async-await-promise/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-2225
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
[
  {
    title: 'Themeの使い方～TypeScriptでstyled-components〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-styled-theme02.jpg'
  },
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: 'TypeScript4.9~4.6の新機能まとめ',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/thumb-ts-4-1.jpg'
  },
  {
    title: 'TypeScriptでstyled-components〜基礎から発展的な使い方〜',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-scs.jpg'
  },
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  }
]
203 wp-image-1492
203 wp-image-1300
203 wp-image-1301
203 wp-image-1365
203 wp-image-1302
203 wp-image-1303
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>微分は高校生でも習いますが、機械学習で出てくる微分の理解には大学数学の知識が必要です。しかし0から大学数学の微積分を学ぼうとするのは遠回りかもしれません。この記事では機械学習で出てくる微分の必要最低限の知識をまとめます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a></li><li><a href="#N"><span class="toc_number toc_depth_1">2</span> N変数関数(多変数関数)</a><ul><li><a href="#N-2"><span class="toc_number toc_depth_2">2.1</span> N変数関数とは</a></li><li><a href="#N-3"><span class="toc_number toc_depth_2">2.2</span> N変数関数の幾何学的解釈</a></li></ul></li><li><a href="#N-4"><span class="toc_number toc_depth_1">3</span> ベクトルの内積でN変数関数を表現する</a><ul><li><a href="#1"><span class="toc_number toc_depth_2">3.1</span> 1次形式</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">3.2</span> 超平面</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">4</span> 点と超平面の距離の公式</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">4.1</span> 陽関数と陰関数</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">4.2</span> 点と直線の距離</a></li></ul></li><li><a href="#i-6"><span class="toc_number toc_depth_1">5</span> 偏微分と勾配</a><ul><li><a href="#2"><span class="toc_number toc_depth_2">5.1</span> 2変数の偏微分</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">5.2</span> 高階偏微分</a></li><li><a href="#2-2"><span class="toc_number toc_depth_2">5.3</span> 2変数の勾配</a></li><li><a href="#N-5"><span class="toc_number toc_depth_2">5.4</span> N変数関数の偏微分と勾配</a></li><li><a href="#i-8"><span class="toc_number toc_depth_2">5.5</span> 勾配の公式</a></li></ul></li><li><a href="#i-9"><span class="toc_number toc_depth_1">6</span> テイラー展開</a><ul><li><a href="#1-2"><span class="toc_number toc_depth_2">6.1</span> 1変数のテイラー展開</a></li><li><a href="#i-10"><span class="toc_number toc_depth_2">6.2</span> 多変数のテイラー展開</a></li></ul></li><li><a href="#i-11"><span class="toc_number toc_depth_1">7</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>前提知識</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・高校レベルの微分の概念</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・機械学習に出てくるベクトルの基礎知識(N次元ベクトル / ノルム / 転置 /表記方法など)<br><strong>　以下の記事で短時間で学べます</strong>!!</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-vector-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-vector-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習のベクトル</div></div><div class="lkc-excerpt">機械学習の理解にあたって最も重要なの概念はベクトルです。しかし高校で習うベクトルは基礎の基礎で、機械学習を学べるレベルのものではありません。そこで、この記事...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>扱うトピック</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事で扱うトピックは次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>N変数関数(多変数関数)</li><li>1次形式と超平面</li><li>超平面と点の距離の公式</li><li>偏微分</li><li>勾配、ベクトルで微分</li><li>テイラー展開</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これらについてご存知のない方を対象とした記事になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="N">N変数関数(多変数関数)</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="N-2">N変数関数とは</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>変数がN個ある関数のことです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>高校数学で扱う関数は、変数が1つの1変数関数<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="4.299ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1900 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-2332-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-2332-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-2332-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-2332-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D453" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-2332-TEX-I-1D453"/></g><g data-mml-node="mo" transform="translate(550,0)"><use data-c="28" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-2332-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(939,0)"><use data-c="1D465" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-2332-TEX-I-1D465"/></g><g data-mml-node="mo" transform="translate(1511,0)"><use data-c="29" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#MJX-2332-TEX-N-29"/></g></g></g></svg>がメインで、せいぜい2変数関数<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="6.413ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2834.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-2334-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-2334-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-2334-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-2334-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-2334-TEX-I-1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2334-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D453" xmlns:xlink="http://www.w3.org/1999/xlink" x'... 377748 more characters,
    date: '2021-12-31T12:57:51',
    categories: { nodes: [Array] },
    title: '【速習】高校数学で理解できる機械学習の微分と多変数関数',
    featuredImage: { node: [Object] },
    uri: '/basic-differential-for-ml/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>PHP8.1がリリースされました。PHP7からできることが非常に増えており、PHPがますます便利になっています。<br>この記事ではPHP7とPHP8.xの違いを、主要な新機能についてまとめてました。深堀りすべき内容は別記事として分離します。なお、<a href="https://tekrog.com/php7-to-php8/" target="_blank" rel="noreferrer noopener"><strong>PHP7からPHP8へのバージョンアップの方法はこちらをご覧ください</strong>。</a></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#enum"><span class="toc_number toc_depth_1">1</span> 列挙型(enum)の追加</a></li><li><a href="#read_only"><span class="toc_number toc_depth_1">2</span> read onlyプロパティの追加</a></li><li><a href="#First-class_callable_syntax"><span class="toc_number toc_depth_1">3</span> First-class callable syntax</a></li><li><a href="#new"><span class="toc_number toc_depth_1">4</span> デフォルトパラメータでnewできる</a></li><li><a href="#i"><span class="toc_number toc_depth_1">5</span> 新しい型のサポート</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">5.1</span> 交差型(&amp;)</a></li><li><a href="#never"><span class="toc_number toc_depth_2">5.2</span> never型</a></li><li><a href="#Union80"><span class="toc_number toc_depth_2">5.3</span> Union型[8.0]</a></li><li><a href="#mixed80"><span class="toc_number toc_depth_2">5.4</span> mixed型[8.0]</a></li></ul></li><li><a href="#final"><span class="toc_number toc_depth_1">6</span> クラス定数のfinal宣言</a></li><li><a href="#Fibers"><span class="toc_number toc_depth_1">7</span> Fibers</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">8</span> 文字列がキーの連想配列のアンパック</a></li><li><a href="#80"><span class="toc_number toc_depth_1">9</span> 属性・アトリビュート[8.0]</a></li><li><a href="#match80"><span class="toc_number toc_depth_1">10</span> match式[8.0]</a></li><li><a href="#80-2"><span class="toc_number toc_depth_1">11</span> コンストラクタの省略記法[8.0]</a></li><li><a href="#Nullsafe80"><span class="toc_number toc_depth_1">12</span> Nullsafe演算子[8.0]</a></li><li><a href="#80-3"><span class="toc_number toc_depth_1">13</span> 名前付き引数[8.0]</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">14</span> その他</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">15</span> まとめ</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">16</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="enum">列挙型(enum)の追加</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>他の言語でお馴染みの列挙型が使えるようになりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//列挙型\n' +
      'enum Color\n' +
      '{\n' +
      '  case Red;\n' +
      '  case Green;\n' +
      '}\n' +
      '\n' +
      '//引数をColor型に限定できる\n' +
      'function printColor(Color $color)\n' +
      '{\n' +
      '  // \n' +
      '}\n' +
      '\n' +
      '//列挙型へのアクセス\n' +
      '$color = Color::Red;//::でアクセス\n' +
      'printColor($color);</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">PHPの列挙型は、他にもメソッドを持てたりインターフェースやトレイトが利用できたりと、非常に多機能です。</strong><br>PHPの列挙型については別記事で詳しく説明しています。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/how-to-use-enum-in-php8-1"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/how-to-use-enum-in-php8-1</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/05/thumb-php-enum-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【PHP8.1】列挙型(Enum)について徹底解説</div></div><div class="lkc-excerpt">PHPの列挙型について解説します。PHPの列挙型はメソッドを持つことが出来たり、インターフェースの実装、トレイトの利用も可能で様々な表現ができます。本記事は公式ド...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="read_only">read onlyプロパティの追加</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>read onlyを指定すると読み取り専用のプロパティが作れます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php \n' +
      'class Person\n' +
      '{\n' +
      '  public function __construct(\n' +
      '    public readonly string $name, //読み取り専用\n' +
      '    public int $age //普通のプロパティ\n' +
      '    ){}\n' +
      '}\n' +
      '\n' +
      "$person = new Person('Taro', 30);\n" +
      '$person->age = 10; //OK\n' +
      '//$person->name = "Jiro"; エラーが出る</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコンストラクタの記述方法をご存じない方は、<a href="#construct">コンストラクタの省略記法(ページ内リンク)</a>を参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="First-class_callable_syntax">First-class callable syntax</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>関数からクロージャに変換する際の新しい記述方法です。<br>簡単に言うと、関数を別名に保存してから別名で呼び出すための手段です。<br>従来Closure::fromCallable()として呼び出していたものを簡単に記述できるようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-php">//$fn = Closure::fromCallable('strlen'); 従来\n` +
      '$fn = strlen(...);\n' +
      "echo $fn('hoge'); //4\n" +
      '\n' +
      '$fn2 = count(...);\n' +
      'echo $fn2(&#091;1, 2, 3, 4, 5]); //5</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="new">デフォルトパラメータでnewできる</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>関数やコンストラクタのデフォルトパラメータで、newを用いたインスタンスの作成ができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-php">function hoge(Person $person = new Person('Jiro', 3))\n` +
      '{\n' +
      '  echo "{$person->name}({$person->age})";\n' +
      '}\n' +
      '\n' +
      "hoge(new Person('Taro', 5)); // Taro(5)\n" +
      'hoge(); //Jiro(3)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">新しい型のサポート</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">交差型(&amp;)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>交差型をサポートしました。型Aと型Bがあるとき、交差型A&amp;BはAかつBの型を表現します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//IteratorかつCountable\n' +
      'function count_and_iterable(Iterator&amp;Countable $value)\n' +
      '{\n' +
      '  //\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="never">never型</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>関数の戻り値にnever型が追加されました。例外のスローやexit、dieなど、関数が決して値を返さないときに宣言します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Union80">Union型[8.0]</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>AまたはBの型を表現します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">class MyClass {\n' +
      '  //intまたはfloat\n' +
      '  private int|float $number;\n' +
      '\n' +
      '  //\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="mixed80">mixed型[8.0]</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>任意の型はmixedで表現します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="final">クラス定数のfinal宣言</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>クラス定数をfinal宣言することができるようになり、オーバーライドを禁止できるようになりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">class MyClass1 \n' +
      '{\n' +
      '  final public const HOGE = "HOGE";\n' +
      '}\n' +
      '\n' +
      'class MyClass2 extends MyClass1\n' +
      '{\n' +
      '  // public const HOGE = "FUGA"; //エラー\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Fibers">Fibers</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Fiberを使うと非同期処理を綺麗に表現することが出来ます。<br>Fiberについて詳しく説明すると1記事では足りないので、別記事で紹介予定です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">文字列がキーの連想配列のアンパック</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8">文字列がキーの連想配列のアンパックもサポートされました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-php">$ary1 = &#091;'hoge' => 1];\n` +
      "$ary2 = &#091;'fuga' => 2];\n" +
      "$ary3 = &#091;'hoge' => 10, ...$ary1, ...$ary2]; //&#091;hoge] => 1 &#091;fuga] => 2</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="80">属性・アトリビュート[8.0]</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>アトリビュートともいいます。コードのロジックとは別にメタデータを埋め込める機能です。<br>アトリビュートに関してもこの記事では足りないので別記事で紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="match80">match式[8.0]</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>match式が導入されました。値を返すswitch文のようなものです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="line-numbers"><code class="language-php">$arg = 'B';\n` +
      '\n' +
      '//switch式\n' +
      'switch ($arg)\n' +
      '{\n' +
      "  case 'A':\n" +
      "    echo 'Apple';\n" +
      '    break;\n' +
      "  case 'B':\n" +
      "    echo 'Banana';\n" +
      '    break;\n' +
      '  default:\n' +
      "    echo 'hoge';\n" +
      '    break;\n' +
      '}\n' +
      '\n' +
      '//上のswitch式と等価なmatch式\n' +
      '$result = match($arg)\n' +
      '{\n' +
      "  'A' => 'Apple',\n" +
      "  'B' => 'Banana',\n" +
      "  default => 'hoge'\n" +
      '};\n' +
      '\n' +
      'echo $result;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>matchはswtichを置き換えるものではなく、重要な相違点がいくつかあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>switchとmatchの違い</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>比較は厳密等価演算</li><li>break文が不要</li><li>=&gt;の右側は1つの式</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①比較は厳密等価演算</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>switch文は式と値が等価演算(==)で比較されていましたが、match式では厳密等価演算(===)で評価されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②break文が不要</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>break文はいりません。フォールスルーしたい場合は、=&gt;の左辺にカンマ区切りで複数の値を指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>③=&gt;の右側は一つの式</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>=&gt;の右側に複数の式を書きたい場合はswitch式を利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="construct"><span id="80-2">コンストラクタの省略記法[8.0]</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コンストラクタの省略記法が導入されました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//新しい記法\n' +
      'class Person\n' +
      '{\n' +
      '  public function __construct(\n' +
      '    public string $name, \n' +
      '    public int $age \n' +
      '    ){}\n' +
      '}\n' +
      '\n' +
      '//従来の記法\n' +
      'class Person\n' +
      '{\n' +
      '  public string $name;\n' +
      '  public int $age;\n' +
      '  \n' +
      '  public function __construct(string $name, int $age)\n' +
      '  {\n' +
      '    $this->name = $name;\n' +
      '    $this->age = $age;\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Nullsafe80">Nullsafe演算子[8.0]</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>nullチェックのif文を一々記述する代わりに、nullsafe演算子を用いて一気にメソッドチェーンができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>従来ならnullチェックをしていたオブジェクトからメソッドチェーンするとき、アロー演算子の前に?をつけます。<br>hoge?-&gt;fugaのような記述になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">//従来\n' +
      'if ($numA !== null) {\n' +
      '  $numB = $numA->B;\n' +
      '\n' +
      '  if ($numB !== null) {\n' +
      '    $numC = $numB->C();\n' +
      ' \n' +
      '    if ($numC !== null) {\n' +
      '      $numD = $numC->D;\n' +
      '    }\n' +
      '\n' +
      '    if ($numD !== null) {\n' +
      '      $numE = $numD->E;\n' +
      '    }\n' +
      '  }\n' +
      '}\n' +
      '\n' +
      '//nullsafe演算子\n' +
      '$numE = $numA?->B?->C()?->D->E;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>メソッドチェーンの途中でnullがあった場合は全体がnullとして評価されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="80-3">名前付き引数[8.0]</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>関数を呼び出す際、呼び出し側で引数名を明示できるようになりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">function printPerson($name="Taro", $age=10, $blood="C")\n' +
      '{\n' +
      '  echo "{$name}({$age}:{$blood})";\n' +
      '}\n' +
      '\n' +
      "printPerson(name: 'Jaro', blood: 'C');</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<p>これによって、オプション引数のスキップや引数の順序を気にせずに関数の呼び出しができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">その他</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・PHP8からJIT機能を搭載。JITエンジンを有効にすれば実行効率が向上</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・@演算子が致命的なエラーを隠さないようになった</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・等価演算(==)の判定方法の変更。より直感的に。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、PHP8.x系の新機能について、概要をさらいました。<br>他の言語にある機能を搭載しつつも、PHP独自の進化も見受けられます。<br>深堀りできなかった内容については別記事でまとめる予定です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-6">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>PHP8.1 Released! (公式ドキュメント)</p><cite><a href="https://www.php.net/releases/8.1/en.php" target="_blank" rel="noreferrer noopener">https://www.php.net/releases/8.1/en.php</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n',
    date: '2021-12-15T19:05:06',
    categories: { nodes: [Array] },
    title: '【PHP8.x】PHP8.1の新機能！PHP7との違いまとめ',
    featuredImage: { node: [Object] },
    uri: '/difference-between-php7-and-php8/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Laravel ViteはViteをLaravelに統合させるプロジェクトです。公式サイトもあり、たったの数コマンドを実行するだけでViteをLaravelに統合させることが出来ます。設定ファイルの変更作業はいりません。しかし、ドキュメントの手順通りにコマンドを入力しても「There are no commands defined in the &#8220;vite&#8221; namespace.」というエラーが出てしまいます。そこでこの記事では、Laravel Viteのセットアップ方法を説明しながら、発生するエラーの対処方法についても紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#There_are_no_commands_defined_in_the_8220vite8221_namespace"><span class="toc_number toc_depth_1">1</span> エラー「There are no commands defined in the &#8220;vite&#8221; namespace.」の対処法だけ知りたい方</a></li><li><a href="#Laravel_Vite"><span class="toc_number toc_depth_1">2</span> Laravel Viteとは</a></li><li><a href="#Laravel_Vite-2"><span class="toc_number toc_depth_1">3</span> Laravel Viteのセットアップ方法</a><ul><li><a href="#Laravel"><span class="toc_number toc_depth_2">3.1</span> ①Laravel プロジェクトを作る</a></li><li><a href="#Laravel_Vite-3"><span class="toc_number toc_depth_2">3.2</span> ②Laravel Viteのプリセットコマンド実行</a></li><li><a href="#npm_install"><span class="toc_number toc_depth_2">3.3</span> ③npm installの実行</a></li><li><a href="#i"><span class="toc_number toc_depth_2">3.4</span> ④@エイリアスの解決</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">3.5</span> ⑤エラーの解決</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">3.6</span> ⑥サーバの起動</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="There_are_no_commands_defined_in_the_8220vite8221_namespace"><meta charset="utf-8">エラー「There are no commands defined in the &#8220;vite&#8221; namespace.」の対処法だけ知りたい方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><a href="#error-resolution">ここからページ下部へ飛んで下さい。</a>しばらくはLaravel Viteのセットアップ手順について説明しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Laravel Viteのセットアップ方法について１から知りたい方は順番に読んで行って下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Laravel_Vite">Laravel Viteとは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そもそもLaravel Viteとは、ViteをLaravelに統合させるプロジェクトです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Laravel Vite</p><cite><a href="https://laravel-vite.innocenzi.dev/" target="_blank" rel="noreferrer noopener">https://laravel-vite.innocenzi.dev/</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>LaravelにはLaravel Mixが搭載されていてVueを簡単に扱えますが、これにはWebpackを利用しています。<br>近年はWebpackよりも軽くて早いViteが注目されていることもあり、Laravel ViteではLaravelでも簡単にViteを扱えるようにします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="Laravel_Vite-2">Laravel Viteのセットアップ方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>手作業で設定ファイルをいじることも出来ますが、コマンドを使えばすぐにVite環境を構築できます。Laravel Viteのサイトでもコマンドによる方法を推奨しています。ですので、この記事ではコマンドによる構築方法について紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Laravel">①Laravel プロジェクトを作る</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは普通にLaravelプロジェクトを作ります</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">laravel new プロジェクト名</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Laravel_Vite-3">②Laravel Viteのプリセットコマンド実行</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>プロジェクトディレクトリに入り、次のコマンドを実行します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npx apply laravel:vite</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>もしここでエラーが出たら、<code class="language-shell">npm i -g apply</code>でapplyコマンドをインストールするか、<code class="language-shell">--ignore-existing</code>を付けてコマンドを実行します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、ここでGitアカウントとの連携とそのSSHキーの入力を求められます。入力したくない場合は<code class="language-shell">--no-ssh</code>フラグをつけてコマンドを再実行します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この時点で各種設定が自動的に行われ、ウェルカムページのbladeファイルやルーティングの書き換えや、Vueファイルなどが用意されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="npm_install">③npm installの実行</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>npm installを実行します</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">npm install</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">④@エイリアスの解決</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>resources/scripts/main.tsを見てみると、@というエイリアスが未定義のためにエラーが出ています<br>そこで、次のコマンドを実行してtsconfig.jsonを更新します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">php artisan vite:aliases</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>しかし次のようなエラーが出てコマンドが受け付けられません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-vivid-red-color has-text-color">There are no commands defined in the &#8220;vite&#8221; namespace.</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3 id="error-resolution"><span id="i-2">⑤エラーの解決</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>エラー解決の手順を説明します。たったの2ステップです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①vendorディレクトリの削除</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">rm -rf vendor</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②composer周りをアップデート</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-shell">composer update</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これでエラーがでなくなるので、④のコマンド<code class="language-shell">php artisan vite:aliases</code>を実行します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">⑥サーバの起動</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-shell">npm run dev</code>と<code class="language-shell">php artisan serve</code>で2つのサーバを立ち上げます。laravel側のサーバにアクセスし、Viteのウェルカムページが表示されていれば成功です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、Laravel Viteの紹介から簡単なセットアップの方法、エラーの解決方法に至るまでを解説しました。エラーの解決も含めて、たったの数コマンドでLaravel Viteの環境が構築できます。</p>\n',
    date: '2021-12-06T11:44:18',
    categories: { nodes: [Array] },
    title: '【Laravel Vite】簡単なセットアップ方法とエラーの対処法',
    featuredImage: { node: [Object] },
    uri: '/setup-laravel-vite-and-error-resolution/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php7-8.jpg'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>サポートベクターマシン(SVM)の数式の意味を「高校レベル教養」があれば理解できるよう分かりやすく解説しています。マージンの概念から始め、マージンを最大化する目的関数と双対問題、決定関数を導出するまでの式変形を細部に至るまで全て記載しています。更にハードマージンSVMから初め、ソフトマージンSVMまで解説し、スラック変数の解説もしています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> はじめに</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> 注意事項</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">1.2</span> 前提となる知識</a></li></ul></li><li><a href="#SVM"><span class="toc_number toc_depth_1">2</span> ハードマージンSVM</a><ul><li><a href="#SVM-2"><span class="toc_number toc_depth_2">2.1</span> SVMの概念とマージン</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">2.2</span> 不等式制約の導出まで</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">2.3</span> 目的関数の導出</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">2.4</span> 主問題から双対問題の導出</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">2.5</span> 決定関数の導出</a></li></ul></li><li><a href="#SVM-3"><span class="toc_number toc_depth_1">3</span> ソフトマージンSVM</a><ul><li><a href="#i-8"><span class="toc_number toc_depth_2">3.1</span> スラック変数の導入</a></li><li><a href="#i-9"><span class="toc_number toc_depth_2">3.2</span> 目的関数の導出</a></li><li><a href="#i-10"><span class="toc_number toc_depth_2">3.3</span> 主問題から双対問題の導出</a></li><li><a href="#i-11"><span class="toc_number toc_depth_2">3.4</span> 決定関数の導出と矩形制約について</a></li></ul></li><li><a href="#i-12"><span class="toc_number toc_depth_1">4</span> 超曲面での分離〜カーネル法へ〜</a></li><li><a href="#i-13"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">はじめに</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">注意事項</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事は、SVMの数学を高校数学レベルに落とし込むのではなく、SVMに必要なレベルの数学を説明する形式になっています。なので専門書レベルの本格的な知識が身につき、他の機械学習の手法の理解にも繋がります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">前提となる知識</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>SVMの数学的理解には以下の基礎知識が必要です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>多変数関数の偏微分や勾配</li><li>多次元ベクトル</li><li>不等式のラグランジュの未定乗数法と二次計画問題</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これらの概念を高校数学の知識だけで短時間で学べる記事を4つ用意しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①N次元ベクトルについて</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-vector-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-vector-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習のベクトル</div></div><div class="lkc-excerpt">機械学習の理解にあたって最も重要なの概念はベクトルです。しかし高校で習うベクトルは基礎の基礎で、機械学習を学べるレベルのものではありません。そこで、この記事...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②N変数関数と偏微分について</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/basic-differential-for-ml"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/basic-differential-for-ml</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-partialdeff-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【速習】高校数学で理解できる機械学習の微分と多変数関数</div></div><div class="lkc-excerpt">微分は高校生でも習いますが、機械学習で出てくる微分の理解には大学数学の知識が必要です。しかし0から大学数学の微積分を学ぼうとするのは遠回りかもしれません。この...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>③超曲面や法線ベクトルについて</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/normal-vector-of-hypersurface-and-contour"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/normal-vector-of-hypersurface-and-contour</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-noraml-vector-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">超曲面や等高線の法線ベクトルを直感的に理解する</div></div><div class="lkc-excerpt">この記事ではN次元空間における「超曲面と等高線(等値面)の法線ベクトル」の公式について、図と例を用いて直感的に分かりやすく説明しています。大学の初等数学が分かれ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>④ラグランジュの未定乗数法</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/method-of-lagrange-multiplier"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/method-of-lagrange-multiplier</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/thumb-lm-1-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">多変数のラグランジュの未定乗数法と2次計画問題</div></div><div class="lkc-excerpt">ラグランジュの未定乗数法は「ある条件下で関数の極値を求める」方法です。2変数で等式制約のケースの解き方は大学の初等数学で習いますが、3次元以上の「多変数」の場...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>本記事で分からないことがあったら、これらの記事から学べます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="SVM">ハードマージンSVM</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="SVM-2">SVMの概念とマージン</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>M個のm次元ベクトル<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="16.221ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7169.5 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-49-TEX-B-1D431" d="M227 0Q212 3 121 3Q40 3 28 0H21V62H117L245 213L109 382H26V444H34Q49 441 143 441Q247 441 265 444H274V382H246L281 339Q315 297 316 297Q320 297 354 341L389 382H352V444H360Q375 441 466 441Q547 441 559 444H566V382H471L355 246L504 63L545 62H586V0H578Q563 3 469 3Q365 3 347 0H338V62H366Q366 63 326 112T285 163L198 63L217 62H235V0H227Z"/><path id="MJX-49-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-49-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-49-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-49-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-49-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-49-TEX-N-22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/><path id="MJX-49-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/><path id="MJX-49-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g da'... 845549 more characters,
    date: '2021-12-31T13:08:00',
    categories: { nodes: [Array] },
    title: '高校数学から理解できるSVMの数学【サポートベクターマシーン】',
    featuredImage: { node: [Object] },
    uri: '/math-of-svm/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1375
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Sassに新しいモジュールシステムが導入されるため、従来通りのSassの書き方が出来なくなるといった話は耳にしたことがあると思います。有名なところでいうと、@import文の廃止と@useの導入などでしょうか。その他にも関数にモジュールシステムが適用され、その書き方も大きく変わることになります。今回はSass関数の中でも便利な「色の関数」について全てまとめ、新しいモジュールシステムに対応した使い方を解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> そもそも新しいモジュールシステムとは</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 色のパラメータを取得する関数</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 色のパラメータを変える関数</a><ul><li><a href="#colorchange"><span class="toc_number toc_depth_2">3.1</span> color.change()関数</a></li><li><a href="#coloradjust"><span class="toc_number toc_depth_2">3.2</span> color.adjust()関数</a></li><li><a href="#colorscale"><span class="toc_number toc_depth_2">3.3</span> color.scale()関数</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> 色を変換する関数</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 色を混ぜる関数</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">6</span> 色を設定する関数</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">7</span> まとめ</a></li><li><a href="#i-8"><span class="toc_number toc_depth_1">8</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="i">そもそも新しいモジュールシステムとは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>従来のSassはどのファイルからでも自由に、他のファイルに定義された変数やミックスインを使うことが出来ました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/sass-color-1024x567.jpg" alt="" class="wp-image-1021" width="512" height="284" srcset="https://tekrog.com/wp-content/uploads/2021/11/sass-color-1024x567.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/11/sass-color-300x166.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/sass-color-768x425.jpg 768w, https://tekrog.com/wp-content/uploads/2021/11/sass-color.jpg 1436w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このように、どこからでも参照可能な範囲をを<strong class="yellow-line">グローバルスコープ</strong>といいます。<strong class="yellow-line">従来はSassの関数もグローバルスコープを持ち、特別な宣言をしなくても呼び出すことが出来ました。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-scss">.text {\n' +
      '  color: lighten($color, 30%); //lighten()をそのまま呼び出せる\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">一見便利そうなグローバルスコープですが、非常に多くの問題があります。</strong>変数がどこで宣言されているか分からなくなったり、知らないうちに変数を上書きしてしまったり&#8230;etc。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>プロラミング経験者ならグローバルスコープの厄介さをご存知かと思います。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そこでSassに新しいモジュールシステムが導入されました。ファイルごとに異なるスコープを持つようになったので、グローバルスコープの厄介さから開放されます。「〇〇のファイルのXXという変数を使います」と宣言(@use宣言)をしないと他のファイルの変数を使えなくなりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/sass-color2-1024x567.jpg" alt="" class="wp-image-1024" width="512" height="284" srcset="https://tekrog.com/wp-content/uploads/2021/11/sass-color2-1024x567.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/11/sass-color2-300x166.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/sass-color2-768x425.jpg 768w, https://tekrog.com/wp-content/uploads/2021/11/sass-color2.jpg 1436w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">モジュールシステムによって組み込み関数にも宣言が必要になります</strong>(一部例外あり)。map系の関数はsass:map宣言、色系の関数はsass:color宣言が必要になりました。これにより、<strong class="yellow-line">従来使っていた関数も新しい書き方で書く必要があります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-scss">@use "sass:map";    //map系の関数を使う宣言\n' +
      '@use "sass:color";  //color系の関数を使う宣言\n' +
      '@use "sass:list";   //list系\n' +
      '@use "sass:string"; //文字列系</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>本題ですが、タイトルの通り<strong class="yellow-line">この記事ではcolor系、すなわち色の関数について全て紹介します。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">色のパラメータを取得する関数</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>色を渡すと、色に関するパラメータを返します。使い方が同じなので一挙に紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>関数名</th><th>意味</th></tr><tr><td>color.red($color)</td><td>RGB値のRの値を取得(0 〜 255)</td></tr><tr><td>color.green($color)</td><td>RGB値のGの値を取得(0 〜 255)</td></tr><tr><td>color.blue($color)</td><td>RGB値のBの値を取得(0 〜 255)</td></tr><tr><td>color.hue($color)</td><td>HSL値のH(色相の角度)を取得(0〜359deg)</td></tr><tr><td>color.saturation($color)</td><td>HSL値のS(彩度)を取得(0 ~ 100%)</td></tr><tr><td>color.lightness($color)</td><td>HSL値のL(明度)を取得(0 ~ 100%)</td></tr><tr><td>color.whiteness($color)</td><td>HWB値のW(白色度)を取得(0 ~ 100%)</td></tr><tr><td>color.blackness($color)</td><td>HWB値のB(黒色度)を取得(0 ~ 100%)</td></tr><tr><td>color.alpha($color)</td><td>アルファ値(透過度)を返す(0 ~ 1)</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ほとんどが従来からある関数の前にcolor.がついただけです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-scss">@use "sass:color";\n' +
      '$color: rgba(#45f98c, .3);\n' +
      '\n' +
      '@debug color.red($color); //69\n' +
      '@debug color.green($color); //249\n' +
      '@debug color.blue($color); //140\n' +
      '@debug color.hue($color); //143.66deg\n' +
      '@debug color.saturation($color); //93.75%\n' +
      '@debug color.lightness($color); //62.35%\n' +
      '@debug color.whiteness($color); //27.05%\n' +
      '@debug color.blackness($color); //2.35%\n' +
      '@debug color.alpha($color); //0.3</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">色のパラメータを変える関数</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>RGB値や彩度、明度、透過度などを変える関数です。その前に注意点があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="error">以下の関数はモジュールシステムで採用されていません<br>・色相を変える<strong> adjust-hue()</strong>関数<br>・明度を変える<strong>lighten()</strong>関数と<strong>darken()</strong>関数<br>・彩度を変える<strong>saturate()</strong>関数と<strong>desaturate()</strong>関数<br>・透過度を変える<strong>opacify()</strong>関数と<strong>transparentize()</strong>関数</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>理由は望み通りの色調整がなかなか出来ないからだそうです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>代わりに以下の関数を使うことが推奨されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>関数名</th><th>意味</th></tr><tr><td>color.change(パラメータ)</td><td>色のパラメータを置き換える</td></tr><tr><td>color.adjust(パラメータ)</td><td>色のパラメータを固定値で増減させる</td></tr><tr><td>color.scale(パラメータ)</td><td>色のパラメータを相対値で増減させる</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>従来はそれぞれchange-color()関数、adjust-color()関数、scale-color()関数として定義されていました。使い方も同じですが、次の節から関数の使い方とパラメータの意味を詳しく説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="colorchange">color.change()関数</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>指定した色のパラメータを置き換える関数です。例えば「Rを200に、Bを120、Gは変えない」といったことや「色相を200度、彩度が30%、明度を50%」といった指定が可能になります。置き換えられるパラメータは以下の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>パラメータ</th><th>意味</th><th>値の範囲</th></tr><tr><td>$red</td><td>R値</td><td>0 ~ 255</td></tr><tr><td>$green</td><td>G値</td><td>0 ~ 255</td></tr><tr><td>$blue</td><td>B値</td><td>0 ~ 255</td></tr><tr><td>$hue</td><td>色相</td><td>0 ~ 359</td></tr><tr><td>$saturation</td><td>彩度</td><td>0 ~ 100%</td></tr><tr><td>$lightness</td><td>明度</td><td>0 ~ 100%</td></tr><tr><td>$whiteness</td><td>白色度</td><td>0 ~ 100%</td></tr><tr><td>$blackness</td><td>黒色度</td><td>0 ~ 100%</td></tr><tr><td>$alpha</td><td>透過度</td><td>0 ~ 1</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">異なる色空間のパラメータを同時に操作してはいけません。<br>RGB値、HSL値、HWB値それぞれの範囲内でのみ操作します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-scss">@use "sass:color";\n' +
      '$color: rgba(134,160,234,0.4);\n' +
      '\n' +
      '@debug color.change($color, $red: 100, $green: 50); //rgba(100, 50, 234, 0.4)\n' +
      '@debug color.change($color, $hue: 200, $saturation: 40%); //rgba(156, 193, 212, 0.4)\n' +
      '@debug color.change($color, $hue: 100, $blackness: 30%, $whiteness: 20%); //rgba(94, 179, 51, 0.4)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="coloradjust">color.adjust()関数</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>指定した色のパラメータに固定値を加算、減算します。例えば「Rを+20、Bを-120、Gは-30」といったことや「色相を-20度回転させ、明度を30%下げて彩度を50%上げる」といった演算が可能になります。パラメータはchange()と同じです。減算もできるので、マイナス値も指定できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>パラメータ</th><th>意味</th><th>値の範囲</th></tr><tr><td>$red</td><td>R値</td><td>±0 ~ 255</td></tr><tr><td>$green</td><td>G値</td><td><meta charset="utf-8">±0 ~ 255</td></tr><tr><td>$blue</td><td>B値</td><td><meta charset="utf-8">±0 ~ 255</td></tr><tr><td>$hue</td><td>色相</td><td><meta charset="utf-8">±0 ~ 359</td></tr><tr><td>$saturation</td><td>彩度</td><td><meta charset="utf-8">±0 ~ 100%</td></tr><tr><td>$lightness</td><td>明度</td><td><meta charset="utf-8">±0 ~ 100%</td></tr><tr><td>$whiteness</td><td>白色度</td><td><meta charset="utf-8">±0 ~ 100%</td></tr><tr><td>$blackness</td><td>黒色度</td><td><meta charset="utf-8">±0 ~ 100%</td></tr><tr><td>$alpha</td><td>透過度</td><td><meta charset="utf-8">±0 ~ 1</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>彩度や明度などパラメータを下げたい場合はマイナス値を指定して減算します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>注意点はchange()と同じです。同じ色空間で操作してください。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-scss">@use "sass:color";\n' +
      '$color: rgba(134,160,234,0.4);\n' +
      '\n' +
      '@debug color.adjust($color, $red: 100, $green: 50); //rgba(234, 210, 234, 0.4)\n' +
      '@debug color.adjust($color, $hue: 200, $saturation: 40%); //rgba(245, 255, 113, 0.4)\n' +
      '@debug color.adjust($color, $hue: 100, $blackness: 30%, $whiteness: 20%); //rgba(167, 167, 167, 0.4)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="colorscale">color.scale()関数</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>指定した色のパラメータを-100% ~ 100%の相対値で変えます。RGB値、アルファ値も-100%~100%で指定します。「Rを50%上げてGを30%下げたい」といったことや「彩度を50%落として明度を20%上げる」といった演算ができます。ただし、<strong class="yellow-line">上記2つの関数と違い色相に関する演算はできません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers'... 3642 more characters,
    date: '2021-11-23T20:16:14',
    categories: { nodes: [Array] },
    title: '【Sass】@useで使える色の関数まとめ',
    featuredImage: { node: [Object] },
    uri: '/sass-new-color-methods/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>今回はHWBカラーモデルについて解説します。このモデルを利用したhwb()という色関数がSassに実装されています。この関数、実はCSSにも存在しますが、執筆時点(2021年11月27日)で対応しているブラウザはSafariのみです。HWBはRGBやHSLより直感的なモデルとなっているので、その意味を理解すればより簡単に色を扱えるようになります。HWBについて紹介した後、RGBやHSLとの関係についても紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#HWB"><span class="toc_number toc_depth_1">1</span> HWBカラーモデルとは</a><ul><li><a href="#HWB-2"><span class="toc_number toc_depth_2">1.1</span> HWBを実際に見てみる</a></li><li><a href="#HWB-3"><span class="toc_number toc_depth_2">1.2</span> HWBのパラメータの詳しい説明</a></li></ul></li><li><a href="#HWB-4"><span class="toc_number toc_depth_1">2</span> HWBカラーモデルの例</a></li><li><a href="#CSSSass"><span class="toc_number toc_depth_1">3</span> CSSやSassでの使用例</a></li><li><a href="#i"><span class="toc_number toc_depth_1">4</span> 他のカラーモデルとの関係</a><ul><li><a href="#RGB"><span class="toc_number toc_depth_2">4.1</span> RGBカラーモデルとの関係</a></li><li><a href="#HSV"><span class="toc_number toc_depth_2">4.2</span> HSVカラーモデルとの関係</a></li></ul></li><li><a href="#i-2"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="HWB">HWBカラーモデルとは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>HWBカラーモデルは</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>３つのパラメータ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li><strong>色相(Hue)</strong></li><li><strong>白色度(Whiteness)</strong></li><li><strong>黒色度(Blackness)</strong></li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>から構成されるカラーモデルです。<br>簡単に説明すると、<strong class="yellow-line">色に黒と白がどの程度含まれているかを表現するモデル</strong>です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="HWB-2">HWBを実際に見てみる</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>とりあえず例を見てみましょう。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/hwb-red-1024x686.png" alt="" class="wp-image-1054" width="512" height="343" srcset="https://tekrog.com/wp-content/uploads/2021/11/hwb-red-1024x686.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/hwb-red-300x201.png 300w, https://tekrog.com/wp-content/uploads/2021/11/hwb-red-768x514.png 768w, https://tekrog.com/wp-content/uploads/2021/11/hwb-red.png 1472w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>赤の色相の例です。右に行けば行くほど黒色度が高くなります。また、下に行けば行くほど白色度が高くなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>つまり<strong class="yellow-line">純色(左上)にどれくらい黒と白を混色したかを表すカラーモデル</strong>です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="HWB-3">HWBのパラメータの詳しい説明</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>色相</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>色相はHSLカラーモデルと同じく、色相関の位置を角度で表した値です。<br>赤を0度とし、0~360度までの値を取ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/hue-50.jpg" alt="" class="wp-image-1058" width="267" height="254" srcset="https://tekrog.com/wp-content/uploads/2021/11/hue-50.jpg 533w, https://tekrog.com/wp-content/uploads/2021/11/hue-50-300x285.jpg 300w" sizes="(max-width: 267px) 100vw, 267px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>白色度・黒色度</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>白色度は名前の通り、どれくらい白色が含まれているかを表します。<br>取る値は0~100%の範囲で、0%は白が全く含まれていない状態、値が大きくなればなるほど白が含まれます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>黒色度は白色度を黒にしたバージョンで、これも0~100%の値を取ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、<strong class="yellow-line">色相の角度,  白色の割合,  黒色の割合の3つの数値を指定するだけで色が表せるとても直感的なモデルとなっています。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>実際、開発者のAlvy Ray smith氏はHSVカラーモデルをより直感的に扱えるように開発したそうです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="HWB-4">HWBカラーモデルの例</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上で見た赤色の例の他にも、代表的な色におけるHWBカラーモデルを見てみます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・黄</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/hwb-yellow-1024x686.png" alt="" class="wp-image-1061" width="512" height="343" srcset="https://tekrog.com/wp-content/uploads/2021/11/hwb-yellow-1024x686.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/hwb-yellow-300x201.png 300w, https://tekrog.com/wp-content/uploads/2021/11/hwb-yellow-768x514.png 768w, https://tekrog.com/wp-content/uploads/2021/11/hwb-yellow.png 1472w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・緑</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/hwb-green-1024x686.png" alt="" class="wp-image-1065" width="512" height="343" srcset="https://tekrog.com/wp-content/uploads/2021/11/hwb-green-1024x686.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/hwb-green-300x201.png 300w, https://tekrog.com/wp-content/uploads/2021/11/hwb-green-768x514.png 768w, https://tekrog.com/wp-content/uploads/2021/11/hwb-green.png 1472w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・青</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/hwb-blue-1-1024x686.png" alt="" class="wp-image-1064" width="512" height="343" srcset="https://tekrog.com/wp-content/uploads/2021/11/hwb-blue-1-1024x686.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/hwb-blue-1-300x201.png 300w, https://tekrog.com/wp-content/uploads/2021/11/hwb-blue-1-768x514.png 768w, https://tekrog.com/wp-content/uploads/2021/11/hwb-blue-1.png 1472w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="CSSSass">CSSやSassでの使用例</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>hwb関数について、スタイリングする際のコードを見てみましょう。<br><strong>執筆時点(2021年11月27日)ではCSSの対応ブラウザはSafariだけとなっています。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>公式ドキュメント：hwb()</p><cite><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb()" target="_blank" rel="noreferrer noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb()</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>よって今回はSassでの使用例についてのみ掲載します。<br>hwb関数は<strong>color.hwb(色相, 白色度, 黒色度)</strong>として使います。<br>前述通り、色相は0 ~ 359度、白色度と黒色度は0 ~ 100%の値を取ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="css,result" data-slug-hash="NWvQVwL" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/NWvQVwL" class="broken_link">\n' +
      '  sample-color.hwb()</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">他のカラーモデルとの関係</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>少々数学チックな話になります。数学好きの人だけ読んで下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="RGB">RGBカラーモデルとの関係</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>R,G,B値のうち、最小のものをMIN、最大のものをMAXとします。</p>\n' +
      '<?xml version="1.0" standalone="no"?>\n' +
      '<svg xmlns="http://www.w3.org/2000/svg" width="43.275ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 19127.4 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-175-TEX-N-4D" d="M132 622Q125 629 121 631T105 634T62 637H29V683H135Q221 683 232 682T249 675Q250 674 354 398L458 124L562 398Q666 674 668 675Q671 681 683 682T781 683H887V637H854Q814 636 803 634T785 622V61Q791 51 802 49T854 46H887V0H876Q855 3 736 3Q605 3 596 0H585V46H618Q660 47 669 49T688 61V347Q688 424 688 461T688 546T688 613L687 632Q454 14 450 7Q446 1 430 1T410 7Q409 9 292 316L176 624V606Q175 588 175 543T175 463T175 356L176 86Q187 50 261 46H278V0H269Q254 3 154 3Q52 3 37 0H29V46H46Q78 48 98 56T122 69T132 86V622Z"/><path id="MJX-175-TEX-N-49" d="M328 0Q307 3 180 3T32 0H21V46H43Q92 46 106 49T126 60Q128 63 128 342Q128 620 126 623Q122 628 118 630T96 635T43 637H21V683H32Q53 680 180 680T328 683H339V637H317Q268 637 254 634T234 623Q232 620 232 342Q232 63 234 60Q238 55 242 53T264 48T317 46H339V0H328Z"/><path id="MJX-175-TEX-N-4E" d="M42 46Q74 48 94 56T118 69T128 86V634H124Q114 637 52 637H25V683H232L235 680Q237 679 322 554T493 303L578 178V598Q572 608 568 613T544 627T492 637H475V683H483Q498 680 600 680Q706 680 715 683H724V637H707Q634 633 622 598L621 302V6L614 0H600Q585 0 582 3T481 150T282 443T171 605V345L172 86Q183 50 257 46H274V0H265Q250 3 150 3Q48 3 33 0H25V46H42Z"/><path id="MJX-175-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-175-TEX-N-6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path id="MJX-175-TEX-N-69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 4'... 58993 more characters,
    date: '2021-11-27T15:42:39',
    categories: { nodes: [Array] },
    title: '【Sass】HWBカラーモデルとは？hwb関数について解説【CSS】',
    featuredImage: { node: [Object] },
    uri: '/hwb-color-model/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-1384
203 wp-image-1377
203 wp-image-1021
203 wp-image-1024
203 lkc-favicon
203 lkc-thumbnail-img
101010101010101010 {
  post: {
    content: '\n' +
      '<p>無料のメーラー「Thunderbird」でメッセージを送信した際、「メッセージを送信しています」「Sentフォルダーへメッセージをコピーしています&#8230;」とういうダイアログが消えなかったので、消し方の備忘録です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 状況</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 解決方法</a><ul><li><a href="#1_Sent"><span class="toc_number toc_depth_2">2.1</span> 方法1. Sentフォルダーを作成、指定する(おすすめの方法!)</a></li><li><a href="#2_Sent"><span class="toc_number toc_depth_2">2.2</span> 方法2. Sentフォルダーへメッセージをコピーしない</a></li><li><a href="#3"><span class="toc_number toc_depth_2">2.3</span> 方法3. 時間が経つと自動的に解決する</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">状況</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Thunderbirdでメッセージを送信した際に、「メッセージを送信しています」というダイアログが消えませんでした。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog-1024x482.png" alt="" class="wp-image-860" width="512" height="241" srcset="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog-1024x482.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog-300x141.png 300w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog-768x361.png 768w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog.png 1046w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ダイアログの状況は、状態に「Sentフォルダーへメッセージをコピーしています」と表示され、進行状況が100%になってもダイアログが消えません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">解決方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>解決方法は大きく分けて3つあります。<strong class="yellow-line">1の方法がオススメです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>解決方法</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li><strong>Sentフォルダーを作成、指定する(おすすめ !)</strong></li><li>Sentフォルダーへメッセージをコピーしない</li><li>時間が立つと自動的に解決する</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">Sentフォルダーとは、文字通り「送信済みフォルダー」。Thunderbirdでは「送信済みトレイ」のことを表しています。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは順番に解決方法を説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="1_Sent">方法1. Sentフォルダーを作成、指定する(おすすめの方法!)</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">送信済みトレイが無いか、または指定されていない可能性があります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①送信済みトレイがない場合</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/12/thunderbird01.png" alt="" class="wp-image-1244" width="430" height="240" srcset="https://tekrog.com/wp-content/uploads/2021/12/thunderbird01.png 860w, https://tekrog.com/wp-content/uploads/2021/12/thunderbird01-300x167.png 300w, https://tekrog.com/wp-content/uploads/2021/12/thunderbird01-768x429.png 768w" sizes="(max-width: 430px) 100vw, 430px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>送信済みトレイ用に、新しくフォルダーを作成しましょう。<br>メールアドレス名のところで<strong>「右クリック」</strong>→<strong>「新規フォルダー</strong>」で作成できます。<br>フォルダー名は何でも良いですが、「送信済みトレイ」など分かりやすいものが良いと思います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/12/thunderbird02-1.png" alt="" class="wp-image-1246" width="483" height="99" srcset="https://tekrog.com/wp-content/uploads/2021/12/thunderbird02-1.png 644w, https://tekrog.com/wp-content/uploads/2021/12/thunderbird02-1-300x61.png 300w" sizes="(max-width: 483px) 100vw, 483px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>私の場合、2つ目以降のアカウントでは「受信トレイ」の中にしかフォルダーが作成できませんでした。<br>これでも問題ないので次に行きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②送信済みトレイがすでにある、または①でフォルダを作成した場合</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>「アカウント設定」</strong>から<strong>「送信控えと特別なフォルダー」</strong>を選択します。<br>そして、一番上の<strong>「メッセージ送信時に自動的にコピーを作成する」</strong>にチェックを入れ、<strong>「次のアカウントの送信済みトレイフォルダー」</strong>のラジオボタンをオンにします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog04.jpg" alt="" class="wp-image-867" width="659" height="217" srcset="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog04.jpg 1464w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog04-300x99.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog04-1024x337.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog04-768x253.jpg 768w" sizes="(max-width: 659px) 100vw, 659px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これでもうまく行かない場合は、<strong>「その他のフォルダーを指定する」</strong>から①で作ったフォルダを直接指定してみてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5.jpg" alt="" class="wp-image-868" width="716" height="169" srcset="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5.jpg 1790w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5-300x71.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5-1024x241.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5-768x181.jpg 768w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog5-1536x362.jpg 1536w" sizes="(max-width: 716px) 100vw, 716px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="2_Sent">方法2. Sentフォルダーへメッセージをコピーしない</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>※この方法はあまりおすすめしません!!</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8"><strong>「アカウント設定」</strong>から<strong>「送信控えと特別なフォルダー」</strong>を選択します。<br>そして、一番上の<strong>「送信控え」</strong>から<strong>「メッセージ送信時に自動的にコピーを作成する」</strong>のチェックを外します。<br></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog3-1.jpg" alt="" class="wp-image-864" width="740" height="250" srcset="https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog3-1.jpg 1480w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog3-1-300x101.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog3-1-1024x346.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/11/thunderbird-dialog3-1-768x259.jpg 768w" sizes="(max-width: 740px) 100vw, 740px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ただしこの方法では、<strong class="yellow-line">送信メッセージのコピーが作成されなくなるので注意してください。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="3">方法3. 時間が経つと自動的に解決する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このトラブルが起こったのは、アカウントを登録してすぐの事でした。<br>何回かテストをしてみたのですが、時間が立ったら自動的に送信済みトレイが作成されてダイアログが消えました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、<meta charset="utf-8">「メッセージを送信しています」とういうダイアログが消えない場合の対処法を3つ紹介しました。<br>いずれかの方法を取れば解決するはずですので、ぜひ試してみてください。</p>\n',
    date: '2021-11-21T17:42:13',
    categories: { nodes: [Array] },
    title: '【Thunderbird】メッセージ送信ダイアログが消えない時の解決法',
    featuredImage: { node: [Object] },
    uri: '/close-thunderbird-sending-dialog/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【Sass】HWBカラーモデルとは？hwb関数について解説【CSS】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/hwb-thumbnail.png'
  },
  {
    title: '【Sass】@useで使える色の関数まとめ',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/sass-color-thumb-1.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  },
  {
    title: 'スクロールスナップ+Barba.jsで遷移前のページの元の位置に戻る方法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/10/barbajs_scrollsnap_thumb.jpg'
  },
  {
    title: '【Sass】HWBカラーモデルとは？hwb関数について解説【CSS】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/hwb-thumbnail.png'
  },
  {
    title: '【Sass】@useで使える色の関数まとめ',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/sass-color-thumb-1.jpg'
  }
]
203 wp-image-860
203 wp-image-1244
203 wp-image-1246
203 wp-image-867
203 wp-image-868
203 wp-image-864
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【GraphQL】beforeやafter, first, edgeとは何か？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-relay.png'
  },
  {
    title: '【Thunderbird】メッセージ送信ダイアログが消えない時の解決法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/thundrbird-dialog.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  }
]
203 wp-image-1054
203 wp-image-1058
203 wp-image-1061
203 wp-image-1065
203 wp-image-1064
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1.jpg'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【Sass】HWBカラーモデルとは？hwb関数について解説【CSS】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/hwb-thumbnail.png'
  },
  {
    title: '【Sass】@useで使える色の関数まとめ',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/sass-color-thumb-1.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  },
  {
    title: 'スクロールスナップ+Barba.jsで遷移前のページの元の位置に戻る方法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/10/barbajs_scrollsnap_thumb.jpg'
  },
  {
    title: '【Sass】HWBカラーモデルとは？hwb関数について解説【CSS】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/hwb-thumbnail.png'
  },
  {
    title: '【Sass】@useで使える色の関数まとめ',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/sass-color-thumb-1.jpg'
  }
]
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 wp-image-1382
203 wp-image-1395
203 wp-image-1417
203 wp-image-1431
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【速習】高校数学で理解できる機械学習のベクトル',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-nd-vector-1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p><meta charset="utf-8">複数の言語を同時に書いていると、言語の仕様や関数名の違いから混乱することもあると思います。個人的に、PHPとJavaScriptを並行して書くことが多くなってきたので、両者の書き方の違いについてまとめました。PHPとJavaScriptの書き方の違いについて、<a href="https://tekrog.com/difference-between-php-and-js/">前回は仕様の違いについてまとめました</a>。今回は配列操作編です。</p>\n' +
      '\n' +
      '\n' +
      '<div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 配列の長さ</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 要素の追加、削除</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 配列の結合</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">4</span> 部分配列の取得</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">5</span> 途中の要素の追加、削除</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">6</span> 要素のソート</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">7</span> 要素の検索</a></li><li><a href="#i-8"><span class="toc_number toc_depth_1">8</span> 要素が存在するか</a></li><li><a href="#MapFilterReduce"><span class="toc_number toc_depth_1">9</span> 順次、Map、Filter、Reduce</a></li><li><a href="#i-9"><span class="toc_number toc_depth_1">10</span> まとめ</a></li></ul></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">以下、PHPの配列を<em>$ary</em>、JSの配列を<em>ary</em>とします</strong>。また、引数が多く意味が分かりづらい関数については実例も交えて説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">配列の長さ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>count</strong>(<em>$ary</em>)</td><td><em>ary</em><strong>.length</strong></td><td><strong>len</strong>(<em>ary</em>)</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">要素の追加、削除</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>破壊的操作</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>操作</th><th>PHP</th><th>JS</th><th>Python</th></tr><tr><th>末尾に追加</th><td><strong>array_push</strong>(<em>$ary</em>, 要素)</td><td><em>ary</em>.<strong>push</strong>(要素)</td><td><em>ary</em>.<strong>append</strong>(要素)</td></tr><tr><th>末尾を削除</th><td><strong>array_pop</strong>(<em>$ary</em>)</td><td><em>ary</em>.<strong>pop</strong>()</td><td><em>ary</em>.<strong>pop</strong>() or <strong>del</strong> <em>ary</em>[-1]</td></tr><tr><th>先頭に追加</th><td><strong>array_unshift</strong>(<em>$ary,</em> 要素)</td><td><em>ary.</em><strong>unshift</strong>(要素)</td><td><em>ary</em>.<strong>insert</strong>(0, 要素)</td></tr><tr><th>先頭を削除</th><td><strong>array_shift</strong>(<em>$ary</em>)</td><td><em>ary</em>.<strong>shift</strong>()</td><td><strong>del </strong><em>ary</em>[0]</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">配列の結合</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>非破壊的操作</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>array_merge</strong>(<em>$ary1, $ary2</em>)</td><td><em>ary1</em>.<strong>concat</strong>(<em>ary2</em>)</td><td><em>ary1</em> <strong>+</strong><em> ary2</em></td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">部分配列の取得</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>非破壊的操作</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>array_slice</strong>(<em>$ary</em>, 開始index [,要素数])</td><td><em>ary</em><strong>.slice</strong>(開始index [,終了index + 1])</td><td><em>ary</em>[スライス]</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>開始indexの位置から部分配列を取得します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">途中の要素の追加、削除</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>破壊的操作</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>array_splice</strong>(<em>$ary</em>, 削除開始index [,削除する要素数]  [,挿入する配列])</td><td><em>ary</em><strong>.splice</strong>(削除開始index [,削除する要素数] [挿入するスカラー値1, 値2,&#8230;])</td><td>追加：<em>ary</em>.<strong>insert</strong>(オフセット, 挿入配列)<br>削除：<strong>del</strong> <em>ary</em>[スライス]</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>PHPのコード例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$num = &#091;0,1,2,3,4,5,6,7,8,9];\n' +
      '//$num&#091;3]から5個要素を削除、\n' +
      '//そこに&#091;100, 200, 300]を挿入\n' +
      'array_splice($num, 3, 5, &#091;100, 200, 300]);\n' +
      'print_r($num); //&#091;0, 1, 2, 100, 200, 300, 8, 9]</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>JSのコード例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const num = [0,1,2,3,4,5,6,7,8,9]\n' +
      '//num[3]から5個要素を削除、\n' +
      '//そこに100, 200, 300を挿入\n' +
      'num.splice(3, 5, 100, 200, 300)\n' +
      'console.log(num) //[0, 1, 2, 100, 200, 300, 8, 9]</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>関数の戻り値は削除した部分配列になる</li><li>値を追加する場合、PHPは配列で、JSはスカラー値を1つ1つ渡す</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-6">要素のソート</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>破壊的操作</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>sort</strong>(<em>$ary</em>, [ソート定数])/ <strong>rsort</strong>()や<strong>asort</strong>()/<strong>usort</strong>()など</td><td><em>ary</em>.<strong>sort</strong>([自作ルール])<br>デフォルトのソートは<strong>文字列</strong><br><em>ary</em>.<strong>reverse</strong>()で逆転ソート可</td><td><em>ary</em>.<strong>sort</strong>([自作ルール])<br>デフォルトのソートは<strong>数値</strong><br>sort関数の第２引数は逆転ソートのフラグ</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下、詳しく説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>PHPのソート関数一覧</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>関数</th><th>順番</th><th>配列の種類</th><th>ソートするもの</th></tr><tr><td>sort</td><td>昇順</td><td>配列</td><td>値</td></tr><tr><td>rsort</td><td>降順</td><td>配列</td><td>値</td></tr><tr><td>asort</td><td>昇順</td><td>連想配列</td><td>値</td></tr><tr><td>arsort</td><td>降順</td><td>連想配列</td><td>値</td></tr><tr><td>ksort</td><td>昇順</td><td>連想配列</td><td>キー</td></tr><tr><td>krsort</td><td>降順</td><td>連想配列</td><td>キー</td></tr><tr><td>usort</td><td>&#8211;</td><td>&#8211;</td><td>自作ルール</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>PHPのソート定数一覧</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>定数</th><th>意味</th></tr><tr><td>SORT_NUMERIC</td><td>数値順にソート</td></tr><tr><td>SORT_STRING</td><td>文字順にソート</td></tr><tr><td>SORT_NATURAL</td><td>自然順ソート</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>PHPのソート使用例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">$num = [10, 5, 1 ,8, 0];\n' +
      "$str = ['hoge', 'fuga', 'a'];\n" +
      '\n' +
      '//数値順、昇順にソート\n' +
      'sort($num, SORT_NUMERIC); // [0, 1, 5, 8, 10]\n' +
      '//文字順、降順にソート\n' +
      "rsort($str, SORT_STRING); // ['hoge', 'fuga', 'a']</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<h4>JSのソート使用例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>JSはデフォルトで文字順ソートしかしません。数値順ソートも自分で実装する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const num = [10, 5, 1 ,8, 0];\n' +
      '\n' +
      '//数値順、昇順にソート\n' +
      'num.sort((a, b) =&gt; a - b)\n' +
      'console.log(num)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>Pythonのソート使用例</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-python">ary = &#091;(200, 600, 10),(1, 4, 5), (10, 2, 3), (1, 1, 0)]\n' +
      '#タプルの合計値が大きい順にソート\n' +
      'ary.sort(key=lambda tmp: sum(tmp&#091;0:]), reverse=True)\n' +
      'print(ary)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>PHPはソートの方法を組み込み関数や定数である程度指定できる</li><li>JSのsort()は文字順ソート。数値順ソートや複雑なソートも全て自作ルールでカスタマイズ</li><li>Pythonは数値順ソート。reverseフラグがあり、昇順降順を簡単に切り替えられる。</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-7">要素の検索</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要素が配列内にあるか検索します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th></th><th>PHP</th><th>JS</th><th>Python</th></tr><tr><th>関数</th><td><meta charset="utf-8"><strong>array_search</strong>(要素, <em>$ary,</em> [厳密等価で比較するか])</td><td><meta charset="utf-8"><em>ary.</em><strong>indexOf</strong>(要素)/ <em>ary.</em><strong>lastIndexOf</strong>(要素)</td><td><em>ary</em>.<strong>index</strong>(要素[,開始index[,終了index]</td></tr><tr><th>見つからなかった場合</th><td>falseを返す</td><td>-1を返す</td><td>エラー</td></tr><tr><th>比較方法</th><td>第3引数をtrueにすると厳密等価で検索</td><td>厳密等価で検索</td><td>&#8211;</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-8">要素が存在するか</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要素があるかどうか確認します。検索結果が無かった場合も存在の有無が確認できますが、別途関数があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td><strong>in_array</strong>(要素, <em>$ary</em>)</td><td><em>ary</em>.<strong>some</strong>(<em>callback</em>)/ <em>ary</em><strong>.every</strong>(<em>callback</em>)</td><td>要素 <strong>in</strong> <em>ary</em></td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>JSのsomeとeveryについて</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>callbackにはブール値を返す関数を定義します。<br>someは<strong>「配列の要素の内1つでも条件を満たす場合」</strong>、everyは「<strong>配列の要素の内全て条件を満たす場合」</strong>trueを返します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">//偶数＋奇数の配列\n' +
      'const num = &#091;1, 2, 4, 6, 8]\n' +
      '//偶数のみの配列\n' +
      'const even = &#091;2, 4, 6, 8]\n' +
      '\n' +
      '//1つでも偶数があればtrue\n' +
      'console.log(num.some(n => n % 2 === 0)) //true\n' +
      'console.log(even.some(n => n % 2 === 0)) //true\n' +
      '\n' +
      '//全部偶数ならばtrue\n' +
      'console.log(num.every(n => n % 2 === 0)) //false\n' +
      'console.log(even.every(n => n % 2 === 0)) //true</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>どちらの言語も見つかった場合はブール値を返す</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="MapFilterReduce">順次、Map、Filter、Reduce</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>操作</th><th>PHP</th><th>JS</th></tr><tr><th>順次</th><td><strong>array_walk</strong>(<em>$ary</em>, <em>callback</em>(要素, index){&#8230;})</td><td><em>ary</em>.<strong>forEach</strong>(<em>callback</em>(要素,index){&#8230;})</td></tr><tr><th>Map</th><td><strong>array_map</strong>(<em>callback</em>(要素){&#8230;}, <em>$ary</em>)</td><td><em>ary</em>.<strong>map</strong>(<em>callback</em>(要素,index){&#8230;})</td></tr><tr><th>Filter</th><td><strong>array_filter</strong>(<em>$ary, callback</em>(要素){&#8230;})</td><td><em>ary.</em><strong>filter</strong>(<em>callback</em>(要素,index){&#8230;})</td></tr><tr><th>Reduce</th><td><strong>array_reduce</strong>(<em>$ary, callback</em>(蓄積値, 要素), 初期値)</td><td><em>ary</em>.<strong>reduce</strong>(<meta charset="utf-8"><em>callback</em>(蓄積値, 要素), 初期値)</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>pythonは内包表記を使うと良いです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-9">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、よく使うであろう配列'... 60 more characters,
    date: '2021-11-21T17:42:00',
    categories: { nodes: [Array] },
    title: 'PHP・JavaScript・Pythonの配列操作の違いまとめ【比較】',
    featuredImage: { node: [Object] },
    uri: '/difference-between-php-and-js-in-arrays/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>複数の言語を同時に書いていると、言語の仕様や関数名の違いから混乱することもあると思います。個人的に、PHPとJavaScriptを並行して書くことが多くなってきたので、両者の書き方の違いについてまとめました。この記事は2回に渡ってまとめる予定で、今回はPHPとJavaScriptの「仕様の違い」についてです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 比較演算</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> クラス(インスタンス)の比較</a></li><li><a href="#PHPJSPython"><span class="toc_number toc_depth_2">1.2</span> 連想配列(PHP)とオブジェクト(JS)、ディクショナリ(Python)の比較</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">2</span> 代入演算</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">2.1</span> 配列の代入</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">2.2</span> クラス(インスタンス)の代入</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">2.3</span> 関数の引数に配列を渡す</a></li></ul></li><li><a href="#switch"><span class="toc_number toc_depth_1">3</span> switch文</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">4</span> スコープ</a></li><li><a href="#i-8"><span class="toc_number toc_depth_1">5</span> 配列の仕様</a><ul><li><a href="#i-9"><span class="toc_number toc_depth_2">5.1</span> 最大インデックス以上のインデックスに代入した場合</a></li></ul></li><li><a href="#for"><span class="toc_number toc_depth_1">6</span> ネストされたfor文からの脱出</a></li><li><a href="#i-10"><span class="toc_number toc_depth_1">7</span> クラスの記述</a><ul><li><a href="#i-11"><span class="toc_number toc_depth_2">7.1</span> コンストラクタ</a></li><li><a href="#i-12"><span class="toc_number toc_depth_2">7.2</span> 親コンストラクタの呼び出し</a></li><li><a href="#i-13"><span class="toc_number toc_depth_2">7.3</span> 親メソッドの呼び出し</a></li></ul></li><li><a href="#i-14"><span class="toc_number toc_depth_1">8</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">比較演算</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>左辺と右辺、2つのオペランドが等しくなる条件。<br>つまり、A==B、A===Bの判定条件の仕様の違いです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">クラス(インスタンス)の比較</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>trueになる条件は以下のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>演算</th><th>PHP</th><th>JS</th><th>Python</th></tr><tr><th>等価(==)</th><td>同じクラスのインスタンスで同じプロパティを持つ</td><td>参照が同じ</td><td>参照が同じ</td></tr><tr><th>厳密等価(===)</th><td>参照が同じ</td><td>参照が同じ</td><td>&#8211;</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="PHPJSPython">連想配列(PHP)とオブジェクト(JS)、ディクショナリ(Python)の比較</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>連想配列とオブジェクトを比較するのはナンセンスですが、「キー : 値」という同じ機能を提供するためここで比較します。trueになる条件は以下のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>演算</th><th>PHP(連想配列)</th><th>JS(オブジェクト )</th><th>Python(ディクショナリ)</th></tr><tr><th>等価(==)</th><td>同じ要素を持つ</td><td>参照が同じ</td><td>同じ要素を持つ</td></tr><tr><th>厳密等価(===)</th><td>同じ要素を持ち並び順も同じ</td><td>参照が同じ</td><td>&#8211;</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHPの連想配列と配列は内部的には同じなので、上記のことは配列にも成り立ちます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">代入演算</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>変数に値を代入するとき、値渡しになるか。参照渡しになるか、ということです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">配列の代入</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>値渡し</td><td>参照渡し</td><td>参照渡し</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">クラス(インスタンス)の代入</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>参照渡し</td><td>参照渡し</td><td>参照渡し</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHPで値渡しにしたい場合はclone命令を使います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-6">関数の引数に配列を渡す</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>関数に引数として渡す配列は、値渡しになるか、参照渡しになるか、ということです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>値渡し</td><td>参照渡し</td><td>参照渡し</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHPには参照(&amp;)があるので、それを踏まえれば値渡しがデフォルトであることを忘れにくいと思います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="switch">switch文</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>式と値の比較方法です。等価か厳密等価か言語によって違います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">switch ($num) {     //この変数$num(式)と\n' +
      '  case 1:         // caseの値1を、式 == 値 と判定するのか、 式 === 値　と判定するのか\n' +
      '}    </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>等価演算(==)</td><td>厳密等価演算(===)</td><td>switch文なし</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHP8で導入されたmatch式は厳密等価演算です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-7">スコープ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>グローバル変数とローカル変数の扱いも異なります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>・スコープが異なれば異なる変数。<br><meta charset="utf-8">・ローカルに変数宣言がない場合、ローカルでグローバル変数を使おうとしてもローカル変数として扱われる。(そもそも警告が出る)<br>・グローバル変数として扱いたいならglobal命令を使う。</td><td>・ローカルに変数宣言がない場合、ローカルでグローバル変数を自動参照する。<br>・ローカルで書き換えた値はグローバルにも反映される。</td><td>・スコープが異なれば異なる変数。<br>・ローカルに変数宣言がない場合、ローカルでグローバル変数を使おうとしてもエラーが出る<br>・グローバル変数として扱いたいならglobal命令を使う<br>・ブロックスコープがない。ローカル変数になるのは関数の中のみ<br><br><br><br></td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-php">&lt;?php\n' +
      '//グローバル\n' +
      '$x = 1;\n' +
      '\n' +
      '//ローカル\n' +
      'function hoge() :int {\n' +
      '  return ++$x; //グローバル変数xとは別物\n' +
      '}\n' +
      '\n' +
      'hoge();\n' +
      '\n' +
      'echo $x; // 1のまま</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-js">//グローバル\n' +
      'let x = 1\n' +
      '\n' +
      '//ローカル\n' +
      'function hoge() {\n' +
      '  return ++x // グローバル変数xを参照する\n' +
      '}\n' +
      '\n' +
      'hoge()\n' +
      '\n' +
      'console.log(x) // 2になる</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-python">a = 10\n' +
      'def hoge():\n' +
      '  global a #aをグローバル変数として扱う時、global宣言がないとエラー\n' +
      '  # a = 10 と新しく代入するとローカル変数になりエラーは出ない\n' +
      '  a += 20\n' +
      'hoge()\n' +
      '\n' +
      'print(a) #グローバル変数として使ったので30となる</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHPやPythonにはglobal宣言があることを踏まえれば、この仕様は忘れにくいと思います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-8">配列の仕様</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-9">最大インデックス以上のインデックスに代入した場合</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>配列の長さがnのとき、nより大きいインデックスmに、<code class="language-js">ary[m] = xxx </code>のように値を代入した場合の挙動が違います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">//長さ3の配列\n' +
      '//最大インデックスは2\n' +
      "$ary = &#91;'taro', 'jiro', 'saburo'];\n" +
      '\n' +
      '//大きいインデックスに代入\n' +
      "$ary&#91;100] = 'hoge';</code></pre>\n" +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>インデックスmに値が追加される。<br>長さは<strong>n</strong>+１(プラス1)。<br>n ~ m-1のインデックスの値は定義されない。</td><td>インデックスmに値が追加される。<br>長さは<strong>ｍ</strong>+1(プラスm-n+1)。<br>n ~ m -1にはundefinedで埋め尽くされる。</td><td>エラーが出てそもそも代入できない</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードの例では n = 3、m = 100と置き換えて考えてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="for">ネストされたfor文からの脱出</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th></tr><tr><td>break n</td><td>break ラベル</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-php">&lt;?php\n' +
      'for ($i = 1; $i &lt;= 9; $i++) {\n' +
      '  for ($j = 1; $j &lt;= 9; $j++) {\n' +
      "    echo $i * $j . '&lt;br>';\n" +
      '    if ($i * $j === 21) {\n' +
      '      break 2; //2階層抜ける\n' +
      '    }\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">label:\n' +
      'for (let i = 1; i &lt;= 9; i++) {\n' +
      '  for (let j = 1; j &lt;= 9; j++) {\n' +
      '    console.log(i * j)\n' +
      '    if (i * j === 21) {\n' +
      '      break label;\n' +
      '    }\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-10">クラスの記述</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-11">コンストラクタ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>public function __construct(引数)</td><td>constructor(引数)</td><td>def __init__(self, 引数)</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-12">親コンストラクタの呼び出し</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>parent::__construct(引数)</td><td>super(引数)</td><td>super().__init__(引数)</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-13">親メソッドの<meta charset="utf-8">呼び出し</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table _fixed"><table><tbody><tr><th>PHP</th><th>JS</th><th>Python</th></tr><tr><td>parent::メソッド</td><td>super.メソッド</td><td>super().メソッド</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-14">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>個人的に忘れがちな部分についてだけまとめました。<br>次回の記事では、配列の操作についてまとめます。</p>\n',
    date: '2021-11-21T17:41:43',
    categories: { nodes: [Array] },
    title: 'PHP・JavaScript・Pythonの紛らわしい仕様の違いまとめ【比較】',
    featuredImage: { node: [Object] },
    uri: '/difference-between-php-and-js/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'PHP・JavaScript・Pythonの配列操作の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part2.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの紛らわしい仕様の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part1.jpg'
  },
  {
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php7-8.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの配列操作の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part2.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの紛らわしい仕様の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>PHP7からPHP8へバージョンアップする際に手間取ったので備忘録を残します。ただし、この記事は「<strong>php -vで既にPHP8へのバージョンアップが確認できたにもかかわらず、PHP8が使えない</strong>」場合の対処法で、Apacheの設定方法についての記事になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="has-vivid-red-color has-text-color">【追記: PHP8.1がリリースされています。PHP8.1を使いたい場合は記事内の8.0.xの記述を8.1に置き換えてください。】</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 環境</a></li><li><a href="#PHP8"><span class="toc_number toc_depth_1">2</span> PHP8にバージョンアップできたけど反映されない</a></li><li><a href="#httpdconf"><span class="toc_number toc_depth_1">3</span> httpd.confの設定</a><ul><li><a href="#php7"><span class="toc_number toc_depth_2">3.1</span> php7のモジュールを読み込んでいた</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">3.2</span> コードがそのまま表示される</a></li></ul></li><li><a href="#PHP7PHP8"><span class="toc_number toc_depth_1">4</span> PHP7とPHP8の違いについて</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">環境</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>環境は以下の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>OS</th><td>Mac</td></tr><tr><th>Webサーバ</th><td>元から入っているApache</td></tr></tbody></table></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="PHP8">PHP8にバージョンアップできたけど反映されない</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>PHP7→PHP8のバージョンアップの方法は既に記事がたくさん出てるので、参考になるページのURLを記載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Upgrade to PHP 8 with Homebrew on Mac</p><cite><a href="https://a-zache.medium.com/upgrade-to-php-8-with-homebrew-on-mac-aeff424cc668">https://a-zache.medium.com/upgrade-to-php-8-with-homebrew-on-mac-aeff424cc668</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Mac に Php8 インストールする手順</p><cite><a href="https://sumito.jp/2021/11/11/2581/">https://sumito.jp/2021/11/11/2581/</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>途中でエラーが出ても、コマンドプロンプトの言う通りにコマンド入力を済ませれば難しいことはないと思います。私の場合、git cloneがうまく行かない等のエラーが出ました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここまでは順調でバージョンアップはうまくいったのですが、この後につまりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-none">php -v</code>でPHP8へのバージョンアップが確認できたのですが、<code class="language-php">phpinfo();</code>で表示されるバージョンはPHP7のままでした。そこで<strong class="yellow-line">Apacheの設定ファイルhttpd.confを調べることに。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>ちなみに/etc/apache2/httpd.confにあります。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="httpdconf">httpd.confの設定</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="php7">php7のモジュールを読み込んでいた</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="file-httpd"><code class="language-none">LoadModule php7_module libexec/apache2/libphp7.so</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>と明らかにphp7のモジュールを読み込んでいたので#でコメントアウト。新しくPHP8のモジュールを読み込みます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="file-httpd"><code class="language-none"># LoadModule php7_module libexec/apache2/libphp7.so\n' +
      'LoadModule php_module /usr/local/Cellar/php/8.0.12/lib/httpd/modules/libphp.so </code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">コードがそのまま表示される</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今度はPHPのソースコードがそのままブラウザ表示されるようになってしまいました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この問題は以下の文を追加することで解決しました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="file-httpd"><code class="language-none">&lt;IfModule php_module&gt;\n' +
      '    DirectoryIndex index.html default.php index.php\n' +
      '    AddHandler application/x-httpd-php .php\n' +
      '&lt;/IfModule&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="PHP7PHP8">PHP7とPHP8の違いについて</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>別記事で新機能についてまとめてあります。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/difference-between-php7-and-php8"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/difference-between-php7-and-php8</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2021/12/php8x-thumb-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【PHP8.x】PHP8.1の新機能！PHP7との違いまとめ</div></div><div class="lkc-excerpt">PHP8.1がリリースされました。PHP7からできることが非常に増えており、PHPがますます便利になっています。この記事ではPHP7とPHP8.xの違いを、主要な新機能についてまと...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法を説明しました。今回は主にApache側の設定の問題だったことがわかりました。同じような状況に陥った場合は是非参考にしてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p></p></blockquote>\n',
    date: '2021-11-21T17:41:14',
    categories: { nodes: [Array] },
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    featuredImage: { node: [Object] },
    uri: '/php7-to-php8/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php7-8.jpg'
  }
]
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'PHP・JavaScript・Pythonの配列操作の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part2.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの紛らわしい仕様の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part1.jpg'
  },
  {
    title: 'PHP7からPHP8へのバージョンアップが上手くいかない場合の対処法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php7-8.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの配列操作の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part2.jpg'
  },
  {
    title: 'PHP・JavaScript・Pythonの紛らわしい仕様の違いまとめ【比較】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/php-and-js-part1.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue.js3において、v-onディレクティブで紐づけた「イベントハンドラ」や「トランジションフック」の引数から要素ノードのプロパティを参照、アクセスしようとするとTypeScriptではエラーが出てしまいます。そこで引数のダウンキャストが必要なのですが、<meta charset="utf-8">「イベントハンドラ」と「トランジションフック」でそれぞれキャストの方法が違うので順番に説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> キャストの方法</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> エラーの原因と解説</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">2.1</span> 一般的なイベントハンドラに渡される引数</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">2.2</span> トランジションフックに渡される引数</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">3</span> イベント周りのクラスの関係</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">キャストの方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>先にキャストの方法を示し、順次解説します。<br>結論を言うと、次のコードのようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbets"><code class="language-ts">//@clickや@mouseenterなどのイベントハンドラ\n' +
      'const onclick = (e: Event) =&gt; {\n' +
      '  const target = e.target as HTMLElement //もしくはHTMLElementのサブクラス\n' +
      '  console.log(target.id) //要素ノードにアクセス\n' +
      '}\n' +
      '\n' +
      '//@before-enterなどのトランジションフック\n' +
      'const onenter = (e: Element) =&gt; {\n' +
      '  const elm = e as HTMLElement //もしくはHTMLElementのサブクラス\n' +
      '  console.log(elm.style) //要素ノードにアクセス\n' +
      '}\n' +
      '</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TypsScriptを用いていない、普通のJavascript+Vue.jsの文献などでは、上記のようにどちらも同じ引数名「e」として受け取っていることが多いです。しかしTypeScriptで引数の型を意識すると、<strong class="yellow-line">それぞれ全く違う型であることが分かります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは、解説を行っていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">エラーの原因と解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">一般的なイベントハンドラに渡される引数</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>clickやmouseenterなど、一般的なイベントに紐づく引数について説明します。<br>以下のようなケースです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・テンプレート</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template&gt;\n' +
      '  &lt;a @click="onclick" id="hoge"&gt;~&lt;/a&gt;\n' +
      '&lt;/template&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>JavaScriptでは次のコードでもエラーが出ません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const onclick = e =&gt; {\n' +
      '  console.log(e.target.id)//eを要素ノードと仮定\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>しかし、TypeScriptではエラーが出ます。<br>ここで、<strong class="yellow-line">イベントハンドラに渡される引数の型はEvent型</strong>(もしくはそのサブクラス)になります。<br>JavaScriptで意図したような要素ノードを取得するには、<strong class="yellow-line">Event型のtargetプロパティをきちんとHTMLElement型にアサーションしてアクセスします。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const onclick = (e: Event) =&gt; {\n' +
      '  const target = e.target as HTMLElement //もしくはHTMLElementのサブクラス\n' +
      '  console.log(target.id)//eを要素ノードと仮定\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">トランジションフックに渡される引数</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&lt;transition&gt;タグにおいて、before-enterやafter-leaveに紐づくイベントハンドラ(トランジションフック)へ渡される引数は一般的なイベントハンドラとは異なります。<br>この場合、<strong class="yellow-line">イベントハンドラの引数はElement型</strong>となります。具体的に言うと、&lt;transiton&gt;タグ直下のHTML要素がそのまま表示されます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・テンプレート</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;transition @enter="onenter"&gt;\n' +
      '  &lt;h1 class="heading"&gt;fugafuga&lt;/h1&gt;\n' +
      '&lt;/transition&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクリプト(JS)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const onenter = e =&gt; {\n' +
      '  console.log(e)\n' +
      '  // &lt;h1 class="heading"&gt;fugafuga&lt;/h1&gt;が出力される\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要素ノードの具体的な属性にアクセスしたい場合は、<strong class="yellow-line">HTMLElement(もしくはそのサブクラス)にダウンキャストします。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクリプト(TS)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">const onenter = (e: Element) =&gt; {\n' +
      '  const elm = e as HTMLElement\n' +
      '  console.log(elm.style)\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-5">イベント周りのクラスの関係</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>EventやHTMLElementなどでダウンキャストが多く登場しましたが、そもそもこれらのクラスの関係は次のようになっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/class-relation-1024x888.png" alt="" class="wp-image-685" width="512" height="444" srcset="https://tekrog.com/wp-content/uploads/2021/11/class-relation-1024x888.png 1024w, https://tekrog.com/wp-content/uploads/2021/11/class-relation-300x260.png 300w, https://tekrog.com/wp-content/uploads/2021/11/class-relation-768x666.png 768w, https://tekrog.com/wp-content/uploads/2021/11/class-relation-1536x1331.png 1536w, https://tekrog.com/wp-content/uploads/2021/11/class-relation.png 1628w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>矢印の先が親クラスになっています。ですので、矢印を逆に辿ればどんどん具体的な型になっていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-6">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>イベントハンドラの引数のキャストの方法について解説し、普通のイベントハンドラとトランジションフックでは異なる型が渡されていることも説明しました。</p>\n',
    date: '2021-11-21T17:41:05',
    categories: { nodes: [Array] },
    title: '【Vue3+TypeScript】v-onイベントハンドラの引数のキャスト',
    featuredImage: { node: [Object] },
    uri: '/v-on-directive-with-typescript/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-685
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>クロスブラウザテストをした際、SafariだけCSSアニメーションがカクついてうまく表示されない場合があります。今回はその実例を示した後に原因を解説し、解決策を2つに分けて説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 解説にあたって</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 解決方法</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> 解説</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">3.1</span> ハードウェアアクセラレーションを使う</a></li><li><a href="#transition"><span class="toc_number toc_depth_2">3.2</span> transitionプロパティをきちんと指定する</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">解説にあたって</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例として以下のようなマウスストーカーを考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="css,result" data-slug-hash="MWvVBjX" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/MWvVBjX" class="broken_link">\n' +
      '  Untitled</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>ポイント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>filterプロパティを利用してブラーをかけている</li><li>ホバー時はtransitionプロパティを利用して拡大のアニメーションをしている</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ほとんどのモダンブラウザでは特別な指定をしなくてもデモのように動きますが、SafariではCSSに気を付けないとアニメーションがカクついてしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">解決方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>CSSで必要なプロパティの指定をすることで解決します。指定するプロパティは2点です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>CSSで指定するもの</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>ハードウェアアクセラレーションのためのプロパティ</li><li>transitionを指定している場合、アニメーションするプロパティをきちんと指定する</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードで表すと次のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-css">  //1\n' +
      '  transform: translateZ(0); // or will-change: filter;\n' +
      '  //2\n' +
      '  transition: transform 0.2s;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">ハードウェアアクセラレーションを使う</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p> <code class="language-css">will-change: filter;</code>もしくは <code class="language-css">transform: translateZ(0);</code>を指定するとハードウェアアクセラレーションが有効になり、GPUを使って描画が行われます。指定しなかった場合は以下のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full"><img decoding="async" width="360" height="240" src="https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem01.gif" alt="" class="wp-image-568"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>赤い色はリペイント処理が走っていることを表しています。<br>また同時に、マウスカーソルの軌跡が描画されたままになってしまう不具合も生じていることが分かります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>transitionを指定していない場合は、この指定だけでカクつきが解決します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="transition">transitionプロパティをきちんと指定する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>例えばtransformプロパティにトランジションを指定する場合、きちんと  <code class="language-css">transition: transform ~ ;</code>とします。transformを省略(規定値のall)にするとかなりカクつきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full"><img decoding="async" width="360" height="240" src="https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem02.gif" alt="" class="wp-image-569"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>safariでCSSアニメーションがカクつく原因を解説し、その対処方法を2つ説明しました。<br>ハードウェアアクセラレーションを有効にすること、transitionプロパティをきちんと指定することを覚えておいてください。</p>\n',
    date: '2021-11-21T17:40:32',
    categories: { nodes: [Array] },
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    featuredImage: { node: [Object] },
    uri: '/safari-animation-problem/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-568
203 wp-image-569
101010101010101010 {
  post: {
    content: '\n' +
      '<p class="Vue Router4.x系のナビゲーションガードではVue3のComposition API用に新しいものが提供されています。だけどbeforeRouteEnterに該当するガードが無い...と少し戸惑ったので備忘録を残します。">Vue Router4.x系のナビゲーションガードではVue3のComposition API用に新しいものが提供されています。だけどbeforeRouteEnterに該当するガードが無い&#8230;と少し戸惑ったので備忘録を残します。この記事では<meta charset="utf-8">Composition API用の関数の紹介、beforeRouteEnterに該当するガードが無い理由とその対処方法について説明しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 新旧コンポーネントガード</a></li><li><a href="#onBeforeRouteEnter"><span class="toc_number toc_depth_1">2</span> onBeforeRouteEnterがない理由</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">3</span> 解決策</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">4</span> まとめ</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">5</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="i">新旧コンポーネントガード</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue Router4.x系ではコンポーネントガードをsetup()内で使えるように、onXXX()形式で新しい関数が提供されています。対応表は以下のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-table"><table><tbody><tr><th>Options API(今まで)</th><th>Composition API</th></tr><tr><td>beforeRouteLeave</td><td>onBeforeRouteLeave</td></tr><tr><td>beforeRouteUpdate</td><td>onBeforeRouteUpdate</td></tr><tr><td>beforeRouteEnter</td><td>なし</td></tr></tbody></table><figcaption>Options APIとComposition APIのガード対応表</figcaption></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ご覧の通り<strong class="yellow-line">beforeRouteEnterに対応するonBeforeRouteEnterのようなものはありません</strong>。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="onBeforeRouteEnter">onBeforeRouteEnterがない理由</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">beforeRouteEnterは「コンポーネントへのナビゲーション前」に呼ばれます。対して、setup()が呼ばれる頃にはすでにナビゲーションが完了してしまっています。</strong>よってsetup()内でonXXで呼び出すようなことはできないのです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>きちんと意味を考えたら当たり前のことでした。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-2">解決策</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">これまで通り、beforeRouteEnterを使います。</strong>コンポーネントガードなら、場所はsetup()と併記します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">setup() {},\n' +
      'beforeRouteEnter() {}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事では<meta charset="utf-8">Composition API用の関数の紹介、beforeRouteEnterに該当するガードが無い理由とその対処方法について説明しました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-4">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>公式ドキュメント：CompositionAPIのナビゲーションガード</p><cite><a href="https://next.router.vuejs.org/guide/advanced/composition-api.html#navigation-guards" target="_blank" rel="noreferrer noopener">https://next.router.vuejs.org/guide/advanced/composition-api.html#navigation-guards</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n',
    date: '2021-11-21T17:40:47',
    categories: { nodes: [Array] },
    title: '【Vue+Router】CompositionAPIのナビゲーションガードの書き方',
    featuredImage: { node: [Object] },
    uri: '/compositionapi-and-navigationgurad/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【Sass】@useで使える色の関数まとめ',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/sass-color-thumb-1.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  },
  {
    title: 'スクロールスナップ+Barba.jsで遷移前のページの元の位置に戻る方法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/10/barbajs_scrollsnap_thumb.jpg'
  },
  {
    title: '【GraphQL】beforeやafter, first, edgeとは何か？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-relay.png'
  },
  {
    title: '【Thunderbird】メッセージ送信ダイアログが消えない時の解決法',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/thundrbird-dialog.jpg'
  },
  {
    title: 'safariでCSSアニメーションがカクついた時の対処法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/11/safari-animation-problem.jpg'
  }
]
info  - Generating static pages (44/59)
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>サムネイルのような円グラフ(以下、ドーナツチャート)はChart.jsというライブラリを使うと簡単に作成できます。Chart.jsでは簡単なチャートの作成からアニメーションの設定まで行うことが可能です。<br>今回は簡単なドーナツチャートの作成方法を説明して、いくつかのオプションの意味と使い方の紹介をします。</p>\n' +
      '\n' +
      '\n' +
      '<div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 作成したドーナツチャート</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> 完成形のデモとコード</a></li></ul></li><li><a href="#Chartjs"><span class="toc_number toc_depth_1">2</span> Chart.jsの解説</a><ul><li><a href="#Chartjs3"><span class="toc_number toc_depth_2">2.1</span> Chart.jsの基本は3つのステップから</a></li><li><a href="#Chartjs-2"><span class="toc_number toc_depth_2">2.2</span> Chart.jsのドーナツチャートの基本</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> ドーナツチャートの作成</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">3.1</span> 基本形の作り方</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">3.2</span> 各種プロパティ</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">3.3</span> 応用</a></li></ul></li><li><a href="#i-7"><span class="toc_number toc_depth_1">4</span> まとめ</a></li></ul></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">作成したドーナツチャート</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">完成形のデモとコード</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>完成系のデモを用意しました。これが今回作るドーナツチャートになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="PoKJeMb" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/PoKJeMb" class="broken_link">\n' +
      '  DESC_doughnut_chart</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デモ中のコメントにもありますが、<strong class="yellow-line">パーセンテージ(percentage)と色(backgroundColor)の2つの値を変えれば、好きなようにカスタマイズできます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それでは以下、順を追ってコードの解説をしていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="Chartjs">Chart.jsの解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そもそも<a href="https://www.chartjs.org/">Chart.js</a>とは、様々な種類のチャートを簡単に作ることができるライブラリです。<br><strong class="yellow-line">ドーナツチャートも数行のコードでかけてしまいます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Chartjs3">Chart.jsの基本は3つのステップから</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><a href="https://www.chartjs.org/docs/latest/getting-started/">公式のドキュメント</a>に詳しい始め方が乗っていますが、この記事でも説明します。<br>Chart.jsは以下の<strong>3つのステップ</strong>で簡単に始められます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>①まずはChart.jsを読み込みます</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・CDNの場合</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<code class="language-html">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.6.0/chart.min.js"&gt;&lt;/script&gt;</code>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・npmの場合</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<code class="language-sh">npm install chart.js</code>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>②次にHTLM側に<code class="language-html">&lt;canvas&gt;</code>タグを用意します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;canvas id="myChart">&lt;/canvas></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>③そしてJavaScriptでこのHTML要素を取得します。<br>Chartインスタンスを作成し、第1引数に取得したHTML要素を、第2引数にチャートの設定項目をオブジェクトとして渡します。<strong>この第2引数のオブジェクトの値をカスタマイズするだけで、様々なチャートが書けるようになります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-js">const ctx = document.getElementById('myChart')\n` +
      'const chart = new Chart(ctx, config)</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>この第2引数のconfigでドーナツチャートの設定を行っていきます。</strong><br>以下、この設定について詳しく説明していきます</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Chartjs-2">Chart.jsのドーナツチャートの基本</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ドーナツチャートを作成するには、上で述べたconfigオブジェクトを以下のように指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">const config = {\n' +
      "  type: 'doughnut',\n" +
      '  data\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>configオブジェクトの中身</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>type：チャートの種類。&#8217;doughnut&#8217;を指定することでドーナツチャートになる</li><li>data:  色や形など、更に細かい設定をするためのオブジェクト</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>configオブジェクトの中で、更にdataオブジェクトを渡す必要があります。<strong class="yellow-line">このdataオブジェクトでドーナツチャートの見た目をカスタマイズしていきます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>dataオブジェクトの必要最低限の構成は、<strong class="yellow-line">「形」と「色」の2つの項目だけ</strong>です。<br>「形」でドーナツチャートの長さ(%)を定め、その「色」を同時に指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">data = {\n' +
      '  datasets: [{\n' +
      '    data: number[], // 形。number型の配列\n' +
      '    backgroundColor: string[] //　色。string型の配列\n' +
      '  }]\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずは「形」の指定です。dataプロパティにnumber型の配列を渡して指定します。<br>ただし少し注意が必要で、この<strong class="yellow-line">number型の配列に渡した数値を構成比率としたドーナツチャート</strong>が描画されることになります。例えば[40, 70, 30]を渡すと、4: 7: 3に3分割されたドーナツチャートが描画させます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/doughnut-473-1.jpg" alt="" class="wp-image-1128" width="225" height="202" srcset="https://tekrog.com/wp-content/uploads/2021/11/doughnut-473-1.jpg 900w, https://tekrog.com/wp-content/uploads/2021/11/doughnut-473-1-300x269.jpg 300w, https://tekrog.com/wp-content/uploads/2021/11/doughnut-473-1-768x688.jpg 768w" sizes="(max-width: 225px) 100vw, 225px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p>「色」はbackgroundColorプロパティで設定します。色とは、上の図で言うと、「4:7:3」の3つの各セクションに割り当ててある「赤、緑、青」の3色のことです。これは<code class="language-js">['rgb(255, 0, 0)', 'rgb(0,255,0)', ...]</code>のようにstring型の配列で設定します。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここまでのコードをまとめます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">const ctx = document.getElementById('myChart') as HTMLCanvasElement\n` +
      'new Chart(ctx, {\n' +
      "  type: 'doughnut',\n" +
      '  data: {\n' +
      '    datasets: &#091;{\n' +
      '      data: &#091;40, 70, 30],\n' +
      '      backgroundColor: &#091;\n' +
      "        'rgb(255, 0, 0)',\n" +
      "        'rgb(0, 255, 0)',\n" +
      "        'rgb(0, 0, 255)'\n" +
      '      ]\n' +
      '    }]\n' +
      '  }\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードのデモは次の通りになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="BadwVoZ" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/BadwVoZ" class="broken_link">\n' +
      '  ドーナツチャート2(円グラフ)</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>[40, 70, 30]の配列を渡したので4:7:3のチャートになっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今までのデモを見ると分かりますが、描画の際にアニメーションしています。<br>この<strong class="yellow-line">アニメーションはChart.jsにより自動的に設定されたものです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>アニメーションのカスタマイズも簡単にできます。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">ドーナツチャートの作成</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">基本形の作り方</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上を踏まえて、最初のデモでみたようなドーナツチャートを作ります。ポイントは2点です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>作成のポイント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>「形」を決める配列の長さを2とし、最初の要素にグラフの長さ(%)、次の要素は100- 長さ(%)とする</li><li>「色」を決める配列の2色目は透明にする</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>先ほども述べた通り、<strong class="yellow-line">「形」を決めるdataプロパティに渡す配列の構成比率がドーナツチャートの比率になるので、配列の要素をx 、 100-xとすれば、「x%」と「(100-x)%」で2分割されたドーナツチャートが描画されます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>そして「100-x%」の描画色を透明にすることで、最初の「x%」の方のみ描画しているように見せています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上で載せたデモを再掲します。x=76、すなわち76%のときのデモになります。<br>残りの24%は透明になっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="PoKJeMb" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/PoKJeMb" class="broken_link">\n' +
      '  DESC_doughnut_chart</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、細かい調整ですが、ドーナツチャートの線幅を0にしてます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>線幅など各種プロパティは次の節で説明します。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">各種プロパティ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>他にも指定可能なプロパティは多くあり、見た目をカスタマイズできます。<br>そのうちの代表的なものを紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">datasets = [{\n' +
      '  hoverOffset: number, //ホバー時のオフセット\n' +
      '  borderColor: Color, //チャートを囲む線の色\n' +
      '  borderWidth: number, //チャートを囲む線の幅\n' +
      '  borderRadius: number, //チャートの角丸半径\n' +
      '  cutout: number,  //チャートの幅(%)\n' +
      '  radius: number,  //チャートの半径(canvasの親要素に対する比率)\n' +
      '  rotation: number, //開始位置(角度)\n' +
      '  circumference: number,  //終了位置(角度)\n' +
      '  animation: { //アニメーションの設定\n' +
      '    duration: number,  //アニメーションする時間(ms)\n' +
      '    easing: string, //イージング\n' +
      '    delay: number, //アニメーションのディレイ\n' +
      '    loop: boolean //アニメーションのループ\n' +
      '  },\n' +
      '}]</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ホバー時のオフセットとは、チャートにマウスホバーした際にチャートが動く大きさになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-6">応用</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>IntersectionObserverと組み合わせてスクロール連動のドーナツチャートを作りました。<br>下にスクロールしてみてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="zYdEaMx" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/zYdEaMx"'... 494 more characters,
    date: '2021-11-21T17:39:11',
    categories: { nodes: [Array] },
    title: 'JavaScriptで円グラフ(ドーナツチャート)を作る簡単な方法',
    featuredImage: { node: [Object] },
    uri: '/doughnut-chart/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-1128
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
101010101010101010 {
  post: {
    content: '\n' +
      '<p>CSSでscroll-snap-typeを指定するとスクロール量が取得できなります。これが原因で、Braba.jsにおいて「あるページから別のページに非同期遷移した後、遷移前のページの元のスクロール位置に戻る」といったコードを書く際に工夫が必要になります。この記事ではこの要件を満たしたコードを紹介します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 実現したい内容</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 完成形のデモ</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">3</span> コードの解説</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">3.1</span> ①戻るためのリンクにハッシュの指定する</a></li><li><a href="#afterEnter"><span class="toc_number toc_depth_2">3.2</span> ②afterEnter()内で、指定したハッシュへジャンプ</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">4</span> スクロール位置が取得できない理由</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">5</span> 公式ページで紹介されている方法について</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">6</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">実現したい内容</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8">Barba.jsを使って非同期遷移することを想定します。今回実現したい内容は、以下の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>実現したい内容</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>ページAでスクロールをしてセクション1→セクション2へ</li><li>セクション2からページBに非同期遷移する</li><li>ページBからページAのセクション2に戻る</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>上記の内容を画像を使って説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1.ページAでスクロールをしてセクション1→セクション2へ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01-1024x722.png" alt="" class="wp-image-486" width="512" height="361" srcset="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01-1024x722.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01-300x212.png 300w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01-768x541.png 768w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01-1536x1083.png 1536w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba01.png 2000w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>2.セクション2からページBへ非同期遷移する</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02-1024x722.png" alt="" class="wp-image-487" width="512" height="361" srcset="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02-1024x722.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02-300x212.png 300w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02-768x542.png 768w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02-1536x1083.png 1536w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba02.png 2001w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>3.ページBからページAのセクション2へ戻る</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03-1024x722.png" alt="" class="wp-image-488" width="512" height="361" srcset="https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03-1024x722.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03-300x212.png 300w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03-768x542.png 768w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03-1536x1083.png 1536w, https://tekrog.com/wp-content/uploads/2021/10/scrollsnap-barba03.png 2001w" sizes="(max-width: 512px) 100vw, 512px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><meta charset="utf-8">scroll-snap-typeを指定するとスクロール量が取得できなくなるため、工夫しないとこの要件を満たすことが出来ません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">完成形のデモ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>私個人のポートフォリオページでこの機能を実現しております。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>ポートフォリオ</p><cite><a href="https://kurokiryoh.com/" target="_blank" rel="noreferrer noopener">https://kurokiryoh.com/</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-3">コードの解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードのポイントは2点です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>2つのポイント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>戻るためのリンクにハッシュの指定する</li><li>afterEnter()内で、指定したハッシュへジャンプ</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1つずつ解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">①戻るためのリンクにハッシュの指定する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>まずはそれぞれのセクションにidを振って下さい。href属性でハッシュを指定すればそのセクションに飛べるようにします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;!-- scroll-snap-typeを指定するコンテナ -->\n' +
      '&lt;div class="snap-container">\n' +
      '  &lt;!-- 各セクションにidを振る -->\n' +
      '  &lt;section id="sec1">&lt;/section> \n' +
      '  &lt;section id="sec2">&lt;/section>\n' +
      '  &lt;section id="sec3">&lt;/section>\n' +
      '&lt;/div></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>遷移先のページから戻るリンクに、戻りたいセクションのハッシュまで指定します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;a href="前のページのURL#セクションのid"&gt;戻る&lt;/a&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これだけで前のページのセクションに戻れそうですが、<strong class="yellow-line">このままでは前のページの一番上まで戻されてしまいます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="afterEnter">②afterEnter()内で、指定したハッシュへジャンプ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ページの一番上まで戻されてしまうので、ハッシュを利用して元いたセクションにジャンプします。<br>afterEnter()内ではハッシュやURLの情報が取得できるので、これを利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-js">afterEnter(data) {\n' +
      '  const url = data.next.url.href //ハッシュ付きURL\n' +
      '  const hash = data.next.url.hash //ハッシュ\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>・location.hrefを使ってセクションへダイレクトに飛ぶ</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-js">location.href= url</code>で指定セクションにジャンプできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>・ハッシュからエレメントを取得してscrollIntoView()を利用する</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-js">document.quertSelector(`#${hash}`).scrollIntoView()</code>で指定セクションへジャンプできます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">scroll-snap-type指定時にスクロール量は取得できないため、scrollTo()は利用できません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-5">スクロール位置が取得できない理由</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この記事で紹介してます。適宜参照してください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>スクロールスナップ時にスクロール量を取得する方法</p><cite><a href="https://tekrog.com/get-scrolly-when-using-scrollsnap/" target="_blank" rel="noreferrer noopener">https://tekrog.com/get-scrolly-when-using-scrollsnap/</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-6">公式ページで紹介されている方法について</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>公式のドキュメントに<a href="https://barba.js.org/docs/advanced/recipes/#Scroll-position">スクロール位置を保存するためのレシピが乗っています</a>。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この方法は遷移前のスクロール位置を保持しておき、戻ってきた際にスクロール位置を利用するような処理になっています。繰り返しになりますが、<strong class="yellow-line">scroll-snap-type指定時はスクロール位置が取得できないのでこの方法では実現できません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>詳しくは、こちらの記事で説明しています。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>スクロールスナップ時にスクロール量を取得する方法</p><cite><a href="https://tekrog.com/get-scrolly-when-using-scrollsnap/" target="_blank" rel="noreferrer noopener">https://tekrog.com/get-scrolly-when-using-scrollsnap/</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-7">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Barba.jsとscroll-snap-typeを組み合わせた際に「非同期遷移した後、遷移前のページの遷移前のスクロール位置に戻る」方法を紹介しました。他にも方法があるかもしれませんが、ざっと思いついた2つの方法の紹介に留めております。</p>\n',
    date: '2021-11-21T17:39:40',
    categories: { nodes: [Array] },
    title: 'スクロールスナップ+Barba.jsで遷移前のページの元の位置に戻る方法',
    featuredImage: { node: [Object] },
    uri: '/scroll-snap-and-barbajs/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
203 wp-image-486
203 wp-image-487
203 wp-image-488
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p><meta charset="utf-8">この記事ではグラデーションのかかったプログレスバーの作り方を紹介します。<meta charset="utf-8">CSSのlinear-gradientを用いて作成しますが、linear-gradientの仕様をきちんと理解していないと綺麗なプログレスバーになりません。そこでCSSの<meta charset="utf-8">linear-gradientを使う際の注意点を、失敗しない作り方について説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> グラーデーションのかかったプログレスバーの完成形</a><ul><li><a href="#i-2"><span class="toc_number toc_depth_2">1.1</span> 完成形のデモ</a></li></ul></li><li><a href="#i-3"><span class="toc_number toc_depth_1">2</span> プログレスバーのコードの解説</a><ul><li><a href="#i-4"><span class="toc_number toc_depth_2">2.1</span> 作り方</a></li><li><a href="#linear-gradient"><span class="toc_number toc_depth_2">2.2</span> 注意点：linear-gradientの仕様を理解する</a></li><li><a href="#i-5"><span class="toc_number toc_depth_2">2.3</span> 必ずマスクを伸縮させる</a></li></ul></li><li><a href="#i-6"><span class="toc_number toc_depth_1">3</span> まとめ</a></li></ul></div>\n' +
      '<h2><span id="i">グラーデーションのかかったプログレスバーの完成形</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">完成形のデモ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デモを用意しました。<br>スクロールに連動してプログレスバーが伸縮します。下にスクロールしてみて下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="jOLGxJa" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/jOLGxJa" class="broken_link">\n' +
      '  Untitled</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>なお、例1(good)と例2(bad)の2つを用意しております。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning"><meta charset="utf-8">多くの場合「例1」が望ましい動作かと思います。<br>以下、例1を<strong>「良い例」</strong>、例2を<strong>「悪い例」</strong>として説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>実装の際に少し注意しないと悪い例のようになってしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-3">プログレスバーのコードの解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">作り方</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回作成した方法はdivを2つ重ねてスクリプトで幅を伸縮する方法です。<br>グラデーションはCSSのlinear-gradientを使用して描画しております。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;div class="progressbar">\n' +
      '  &lt;div>&lt;/div>\n' +
      '&lt;/div></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>片方のdivでプログレスバーの表示領域及びマスクを描画</li><li>もう片方のdivでグラデーションのプログレスバーを描画</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここで注意しなくてはならないことが、<strong class="yellow-line">どちらのdivをプログレスバーの描画に使用するか</strong>ということです。CSSのlinear-gradientの仕様をきちんと理解しないと悪い例のようなプログレスバーとなってしまいます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="linear-gradient">注意点：linear-gradientの仕様を理解する</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>linear-gradientの値は、始点から終点までの色の変化を指定しています。<br>よって、<strong class="yellow-line">伸縮させるプログレスバーにグラデーションを設定してしまうと、グラデーションも伸縮してしまいます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="291" src="https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01-1024x291.jpg" alt="" class="wp-image-328" srcset="https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01-1024x291.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01-300x85.jpg 300w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01-768x218.jpg 768w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01-1536x437.jpg 1536w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar01.jpg 2000w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>プログレスバー本体にグラデーションを設定した場合</figcaption></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>長さに関わらず、赤〜紫までグラデーションが変化してしまいます</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">必ずマスクを伸縮させる</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>グラデーションのかかった領域は予め全て描画しておきます。<br>その上にマスクをかけ、<strong class="yellow-line">マスクを伸縮させることでプログレスバーが伸縮しているように見せます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="291" src="https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02-1024x291.jpg" alt="" class="wp-image-331" srcset="https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02-1024x291.jpg 1024w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02-300x85.jpg 300w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02-768x218.jpg 768w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02-1536x437.jpg 1536w, https://tekrog.com/wp-content/uploads/2021/10/gradient-progressbar02.jpg 2000w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>グレーのマスクを伸縮させた場合</figcaption></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>上の図では説明のためグラデーションとマスクをずらして表してますが、実際はぴったり重なっています</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-6">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>グラデーションのかかったプログレスバーの作り方を紹介しました。<br>プログレスバーにlinear-gradientを指定したとき、バーが短くても長くても始点から終点まで色が変化することも説明しました。<br>今回作成したプログレスバーに限らず、このグラデーションの仕様は覚えておく必要がありそうです。</p>\n',
    date: '2021-11-21T17:38:59',
    categories: { nodes: [Array] },
    title: 'CSSでグラデーションのかかったプログレスバーを作る方法と注意点',
    featuredImage: { node: [Object] },
    uri: '/gradient-progressbar/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-328
203 wp-image-331
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue3のカスタムコンポーネントにおけるv-modelの使用方法について解説します。また、Vue2ユーザのためにVue3での仕様変更についても併せて説明しています。Vue3での仕様変更によって、<strong class="yellow-line">Vue2で動いていたコードが動かなくなります。</strong>例えばpropsのvalueがmodelValueに変わっていたり、emitの発火にupdateを記述するなど変更点が多いので、順を追って解説していきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#Vue3"><span class="toc_number toc_depth_1">1</span> Vue3での変更点一覧</a></li><li><a href="#v-model"><span class="toc_number toc_depth_1">2</span> カスタムコンポーネントにおけるv-modelの使用方法</a><ul><li><a href="#Vue3-2"><span class="toc_number toc_depth_2">2.1</span> Vue3での記述方法</a></li><li><a href="#Vue2"><span class="toc_number toc_depth_2">2.2</span> Vue2からの変更点</a></li></ul></li><li><a href="#modelValue"><span class="toc_number toc_depth_1">3</span> プロパティ名をmodelValueから変更する方法</a><ul><li><a href="#Vue3-3"><span class="toc_number toc_depth_2">3.1</span> Vue3での記述方法</a></li><li><a href="#Vue2-2"><span class="toc_number toc_depth_2">3.2</span> Vue2からの変更点</a></li></ul></li><li><a href="#1v-model"><span class="toc_number toc_depth_1">4</span> 1つのコンポーネントに複数のv-modelを使う方法</a><ul><li><a href="#Vue3-4"><span class="toc_number toc_depth_2">4.1</span> Vue3での記述方法</a></li><li><a href="#Vue2-3"><span class="toc_number toc_depth_2">4.2</span> Vue2からの変更点</a></li></ul></li><li><a href="#i"><span class="toc_number toc_depth_1">5</span> まとめ</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">6</span> 参考</a></li></ul></div>\n' +
      '<h2><span id="Vue3">Vue3での変更点一覧</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この章はVue2ユーザのみお読み下さい。<br>Vue3で始めてカスタムコンポーネントのv-modelを扱う方は、次の章へお進み下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue3における変更点は次のとおりです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>子コンポーネントに渡るデフォルトのprops名はmodelValueに変更</li><li>子コンポーネントからemitする際のイベント名の変更、決まり</li><li>modelオプションの削除</li><li>複数バインディングにv-bind.syncは使わない</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以下の章でそれぞれの変更点についても解説します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="v-model">カスタムコンポーネントにおけるv-modelの使用方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue3-2">Vue3での記述方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>カスタムコンポーネントにおけるv-modelは、modelValueプロパティを渡してupdate:modelValueイベントを発火させるのと等価です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">  &lt;Child v-model="text"/>\n' +
      '  &lt;!-- 下と同じ意味 -->\n' +
      '  &lt;Child :modelValue="text" @update:modelValue="text = $event"/></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>よって、<strong class="yellow-line">子コンポーネント(カスタムコンポーネント)側ではmodelValueプロパティを受け取る準備と、update:modelValueイベントをemitさせる処理を記述すれば良い</strong>ことになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>したがって、子カスタムコンポーネント側のコードは次のようになります。<br>(以下では簡単な例として、カスタムコンポーネントのinputフォームのinputイベントを発火させています。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・テンプレート</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-html">&lt;template&gt;\n' +
      '  &lt;input :value="modelValue" type="text" @input="onInputText" /&gt;\n' +
      '&lt;/template&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・スクリプト</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup&gt;\n' +
      'const props = defineProps&lt;{modelValue: string}&gt;()\n' +
      "const emits = defineEmits&lt;{(e: 'update:modelValue', text: string): void}&gt;()\n" +
      '\n' +
      'const onInputText = (e: Event) =&gt; {\n' +
      '  const target = e.target as HTMLInputElement\n' +
      "  emits('update:modelValue', target.value)\n" +
      '}\n' +
      '&lt;/script&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>※注意<br>この記事では上のコードのようにscript setup構文で記述しています。script setup構文について詳しく知りたい方は次の記事を参照下さい。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/vue3-script-setup"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/vue3-script-setup</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/03/thumb-script-setup-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】</div></div><div class="lkc-excerpt">Vue3.2で&lt;script setup&gt;構文が導入され、Composition APIの記述が簡単になりました。&lt;script setup&gt;構文は記述が簡単になるだけでなく、他にも多くのメリッ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue2">Vue2からの変更点</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>①propsのデフォルト名はmodelValue</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue2はデフォルトで<code class="language-javascript">value</code>という名前のpropsが子コンポーネントに渡っていましたが、Vue3では<code class="language-javascript">modelValue</code>という名前に変更されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>したがって、子コンポーネントではmodelValueというpropsを受け取る記述をします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup>\n' +
      'const props = defineProps&lt;{modelValue: string}>()\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>②inputをemitできない</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p>Vue2の子コンポーネントで<code class="language-javascript">$emit('input', event.target.value)</code>などとしてイベントを送信していましたが、Vue3でこのコードは動かなくなります。</p>\n` +
      `<p>代わりに<code class="language-javascript">emit('update:modelValue', event.target.value)</code>とします。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="modelValue">プロパティ名をmodelValueから変更する方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue3-3">Vue3での記述方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デフォルトではmodelValueがプロパティに渡っていましたが、これは変更することが出来ます。<br><strong class="yellow-line">そのためにはv-modelの引数を使います。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>その記述方法ですが、<code class="language-js">v-model:プロパティ名=値</code>のようにv-modelにコロンをつけて引数名を続けて書きます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それに伴い、発火させるemitのイベント名も<code class="language-ts">update:プロパティ名</code>のように変更します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上を踏まえて、textという名前のプロパティ名に変更する例を示します。<br>先程の例と同じではつまらないので、今回はchangeイベントを発生させています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・親コンポーネント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-html">&lt;template>\n' +
      '   &lt;MyComponent v-model:text="data"/>\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・子コンポーネントのテンプレート</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-html">&lt;template>\n' +
      '  &lt;input :value="text" type="text" @change="onChangeText" />\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・子コンポーネントのスクリプト</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup>\n' +
      'const props = defineProps&lt;{text: string}>()\n' +
      "const emits = defineEmits&lt;{(e: 'update:text', text: string): void}>()\n" +
      '\n' +
      'const onChangeText = (e: Event) => {\n' +
      '  const target = e.target as HTMLInputElement\n' +
      "  emits('update:text', target.value)\n" +
      '}\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue2-2">Vue2からの変更点</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4>プロパティ名はv-modelの引数で定義</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue2では子コンポーネントにmodelオプションを用意し、紐づくプロパティやイベントを変更していました。しかしVue3ではこのオプションは削除されました。代わりにv-modelの引数を用いることになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="1v-model">1つのコンポーネントに複数のv-modelを使う方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue3-4">Vue3での記述方法</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">前節で出てきた引数を使い分ければ、同時に複数のバインディングが可能になります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>次の例では、コンポーネントに2つv-modelを付けています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>・親コンポーネント</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template>\n' +
      '  &lt;Child \n' +
      '    v-model:text="data1" \n' +
      '    v-model="data2"\n' +
      '  />\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>子コンポーネントのテンプレート</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;template>\n' +
      '  &lt;input type="text" :value="text" @input="onInputText">\n' +
      '  &lt;input type="number" :value="modelValue" @change="onChangeNumber">\n' +
      '&lt;/template></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>子コンポーネントのスクリプト</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup>\n' +
      'const props = defineProps&lt;{\n' +
      '  text: string\n' +
      '  modelValue: number\n' +
      '  }>()\n' +
      '\n' +
      'const emits = defineEmits&lt;{\n' +
      "  (e: 'update:text', text: string): void\n" +
      "  (e: 'update:modelValue', num: number): void\n" +
      '  }>()\n' +
      '\n' +
      'const onInputText = (e: Event) => {\n' +
      '  const target = e.target as HTMLInputElement\n' +
      "  emits('update:text', target.value)\n" +
      '}\n' +
      '\n' +
      'const onChangeNumber = (e: Event) => {\n' +
      '  const target = e.target as HTMLInputElement\n' +
      "  emits('update:modelValue', Number(target.value))\n" +
      '}\n' +
      '&lt;/script></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Vue2-3">Vue2からの変更点</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Vue2では、.syncを使って記述していました。代わりにv-modelの引数を利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、Vue3でカスタムコンポーネントのv-modelの使用方法について、その使用方法と変更点を説明しました。これさえ知っておけば最低限のコードは記述できるはずです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">参考</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Vue.js公式ドキュメント</p><cite><a href="https://v3.ja.vuejs.org/guide/migration/v-model.html#%E6%A6%82%E8%A6%81" class="broken_link">https://v3.ja.vuejs.org/guide/migration/v-model.html#%E6%A6%82%E8%A6%81</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p></p>\n',
    date: '2021-11-21T17:40:05',
    categories: { nodes: [Array] },
    title: '【Vue.js3】カスタムコンポーネントでv-modelを使う方法',
    featuredImage: { node: [Object] },
    uri: '/v-model-in-vue3/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>CSSでscroll-snap-typeを指定した時、普通の方法ではスクロール量の取得ができません。<br>そこで今回は、ちょっとした工夫でスクールスナップ時にスクロール量を取得する方法を紹介します。</p>\n' +
      '\n' +
      '\n' +
      '<div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#scroll-snap"><span class="toc_number toc_depth_1">1</span> scroll-snap時にスクロール量を取得する方法</a><ul><li><a href="#i"><span class="toc_number toc_depth_2">1.1</span> 完成形のデモ</a></li><li><a href="#i-2"><span class="toc_number toc_depth_2">1.2</span> スクロール量を取得するコードの例</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">1.3</span> コードの解説</a></li></ul></li><li><a href="#scroll-snap-2"><span class="toc_number toc_depth_1">2</span> scroll-snapでスクロール量が取得できない理由</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">3</span> まとめ</a></li></ul></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="scroll-snap">scroll-snap時にスクロール量を取得する方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i">完成形のデモ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デモを用意しました。下にスクロールしてみて下さい。<br><strong>今回紹介するDの方法でスクロール量が取得できていることが分かります。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="OJjxjLL" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/OJjxjLL" class="broken_link">\n' +
      '  DESC-scroll_amount_scroll_snap</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>なお、各アルファベットの意味は以下の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group ulUI"><div class="wp-block-group__inner-container">\n' +
      '<p>デモ中の各アルファベットの説明</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul><li>A. window.screenYを使用</li><li>B. document.body.scrollTopを使用</li><li>C. document.documentElement.scrollTopを使用</li><li><strong>D. getBoundingClientRect().topを使用(今回紹介する方法)</strong></li><li>E. バブリングフェーズで行った場合、スクロールイベントは発生しない</li></ul>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">バブリングフェーズではscrollイベントが発火しません。<br>scrollイベントと組み合わせる場合はキャプチャリングフェーズで実行するようにして下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-2">スクロール量を取得するコードの例</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロールコンテナのクラスを&#8221;container&#8221;とすると、</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre><code class="language-ts">const firstChildDOM = document.querySelector&lt;HTMLElement>('.container > *:first-child')\n` +
      'const scrollPosition = firstChildDOM!.getBoundingClientRect().top * -1</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>でスクロール量が取得できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>厳密には、このコードは<strong>「ビューポートとコンテナ最初の子要素の高さ方向のずれの大きさ」</strong>を計算しています。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コンテナの最初の子要素とは、例えばHTMLが</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-html">&lt;div class="container">\n' +
      '  &lt;section>A&lt;/section>\n' +
      '  &lt;section>B&lt;/section>\n' +
      '  &lt;section>C&lt;/section>\n' +
      '&lt;/div></code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>のとき、セクション Aのことを指します。<br>つまり、<strong class="yellow-line">ビューポートとセクションAのY座標のずれの大きさをスクロール量とみなします。</strong><br>以下、分かりやすさのため最初の子要素＝セクションAとして話を進めます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">コードの解説</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><code class="language-js">DOM.getBoundingClientRect().top</code>は<strong class="yellow-line">常にビューポートの最上部から対象のDOMの最上部までの距離を返します。</strong>今回はビューポートの最上部からセクションAの最上部の距離を考えれば良いことになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1.png" alt="" class="wp-image-422" width="629" height="357" srcset="https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1.png 2516w, https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1-300x170.png 300w, https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1-1024x581.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1-768x436.png 768w, https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1-1536x871.png 1536w, https://tekrog.com/wp-content/uploads/2021/10/get-scrolly01-1-2048x1162.png 2048w" sizes="(max-width: 629px) 100vw, 629px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロール前の段階では<br><strong>セクションAの最上部のy座標 = ビューポートの最上部のy座標 = 0</strong><br>となっているはずです。<br>よって、ビューポート最上部からセクションAの最上部の距離は０となります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロールするとビューポートは下に移動するので、<br><strong>セクションAの最上部のy座標  &lt;  ビューポートの最上部のy座標</strong><br>となり、セクションAまでの距離が大きくなります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">この大きさをスクロール量とみなすことができます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>ただし、ビューポートはセクションAより下にあるので負の数になります。そこで<strong>-1 をかけることにより正の数に変換しています。</strong></p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="scroll-snap-2">scroll-snapでスクロール量が取得できない理由</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>scroll-snap-typeをスクロールコンテナに指定する時、同時に<code class="language-css">overflow-y: scroll;</code>も定義する必要があります。この<code class="language-css">overflow-y: scroll;</code>を定義すると、<strong class="yellow-line">一般的な方法でスクロール量を取得することができません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>スクロールコンテナとは、CSSでscroll-snap-typeプロパティを指定する要素のことです</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>一般的なスクロール量の取得方法とは、次に挙げるような取得方法のことです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>スクロール量の取得方法</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>window.scrollY</li><li>document.body.scrollTop</li><li>document.documentElement.scrollTop</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>しかしスクロールスナップ時はどれだけスクロールを進めても、<strong class="yellow-line">上記の方法ではスクロール量が常に0となってしまいます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-4">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ポイントは3点です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>コンテナの子要素の位置を利用する</li><li>scrollイベントで使う場合はキャプチャリングフェーズで</li><li>絶対位置が欲しい場合は -1 をかける</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上、スクロールスナップ時にスクロール量を取得する方法を紹介しました。</p>\n',
    date: '2021-11-21T17:38:47',
    categories: { nodes: [Array] },
    title: 'スクロールスナップ時にスクロール量を取得する方法',
    featuredImage: { node: [Object] },
    uri: '/get-scrolly-when-using-scrollsnap/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-422
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>インクや液体、滴のような動きをするマウスストーカーの作り方を紹介します。<br>完成形のコードのコピペするだけでも使えますが、コードの意味を理解することによって自分好みのマウスストーカーにカスタマイズできるようになるので表現の幅が広がるはずです。<br>基礎的な仕組みの説明をした後、カスタマイズした例も記載します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="error">今回紹介するマウスストーカーのアルゴリズムは、<strong>CodePenに公開されているRicardo Mendieta様(<a rel="noreferrer noopener" href="https://codepen.io/mendieta/" target="_blank" class="broken_link">@mendieta</a>)の「<a rel="noreferrer noopener" href="https://codepen.io/mendieta/pen/WgvENJ" target="_blank" class="broken_link">ink Cursor</a>」のアルゴリズムを借用させていただいております。</strong>CodePenのソースコードは<strong>MITライセンス</strong>になります。そのため、初めに掲示するソースコード全体の上部に<strong>MITライセンスを掲載しております</strong>。</p>\n' +
      '\n' +
      '\n' +
      '<div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 完成形・作りたいもの</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 液体の動きの解説</a><ul><li><a href="#2"><span class="toc_number toc_depth_2">2.1</span> 液体の2つの状態</a></li><li><a href="#i-3"><span class="toc_number toc_depth_2">2.2</span> 液体の動きの正体</a></li></ul></li><li><a href="#i-4"><span class="toc_number toc_depth_1">3</span> 液体の動きのコード</a><ul><li><a href="#i-5"><span class="toc_number toc_depth_2">3.1</span> 円の生成</a></li><li><a href="#Dot"><span class="toc_number toc_depth_2">3.2</span> Dotクラス</a></li><li><a href="#i-6"><span class="toc_number toc_depth_2">3.3</span> カーソルが止まっている時の描画</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">3.4</span> カーソルが動いている時の描画</a></li><li><a href="#SVG"><span class="toc_number toc_depth_2">3.5</span> 円を液体のようにつなげるSVGフィルタ</a></li></ul></li><li><a href="#i-8"><span class="toc_number toc_depth_1">4</span> カスタマイズ</a></li><li><a href="#i-9"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">完成形・作りたいもの</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>「液体」や「インク」と文字にしてもいまいち伝わりにくいと思うので、まずは完成形をご覧ください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="js,result" data-slug-hash="qBXMevW" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/qBXMevW" class="broken_link">\n' +
      '  インクカーソルデモ</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>繰り返しになりますが、<strong class="yellow-line">CodePenに公開されているRicardo Mendieta様(<a rel="noreferrer noopener" href="https://codepen.io/mendieta/" target="_blank" class="broken_link">@mendieta</a>)の「<a rel="noreferrer noopener" href="https://codepen.io/mendieta/pen/WgvENJ" target="_blank" class="broken_link">ink Cursor</a>」のアルゴリズムの一部分の解説が主となります</strong>。次節からプログラムの断片を掲載しますが、ここで掲載したソースコードの一部を切り取ったものの再表示となるため、MITライセンスの掲載は割愛しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">液体の動きの解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="2">液体の2つの状態</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デモを動かしてみると気づくと思いますが、このマウスストーカー は2種類の状態から成ります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p class="olUI-ttl">2つの状態</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol class="olUI"><li>カーソルが止まっている状態: ストーカーがその場でウネウネ動く</li><li>カーソルが動いている状態：カーソルの移動方向に液体が流れるような動き</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>JavaScriptでマウスの状態を検知してこの2つの状態を切り替えています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1.カーソルが止まっている状態</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/11/ink-stop-loop.gif" alt="" class="wp-image-647" width="360" height="240"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>2.カーソルが動いている状態</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full"><img decoding="async" width="360" height="240" src="https://tekrog.com/wp-content/uploads/2021/11/ink-move-loop.gif" alt="" class="wp-image-648"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">液体の動きの正体</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>液体の動きは大きく分けて2つステップで構成されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>2つのステップ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>様々な大きさの円を描画して周期的に動かす(JavaScript)</li><li>SVGでフィルタをかけて円をつなげる</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1については、SVGフィルタを外すとその挙動が分かります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full"><img decoding="async" width="360" height="240" src="https://tekrog.com/wp-content/uploads/2021/11/dot-move-loop.gif" alt="" class="wp-image-650"/></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>1の円をぼかした後、コントラストに対するフィルタをかけることによって、液体のように見せているわけです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>では、次節以降でコードの解説をします。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-4">液体の動きのコード</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-5">円の生成</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>円はDotクラスで管理し、大きい円から小さい円を順に生成して配列に格納します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers ts"><code class="language-ts">const width = 30 //球の大きさ\n' +
      'const amount = 26 //生成する球の数\n' +
      'let dots: Dot[] = [] //生成した球を格納する配列\n' +
      '\n' +
      '//円のクラス\n' +
      'class Dot {\n' +
      '  /* 後述 */\n' +
      '}\n' +
      '\n' +
      '//円の生成と格納\n' +
      'const buildDots = () =&gt; {\n' +
      '  for (let i = 0; i &lt; amount; i++) {\n' +
      '    //iが大きくなるにつれ小さい円になる(後述)\n' +
      '    let dot = new Dot(i)\n' +
      '    dots.push(dot)\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="Dot">Dotクラス</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>続いてDotクラスのプロパティについて詳しくみていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers ts"><code class="language-ts">class Dot {\n' +
      ' x = 0 // 現在のx座標\n' +
      ' y = 0 // 現在のy座標\n' +
      ' private anglespeed = 0.05 //円が動くスピード(可変)\n' +
      " private element = document.createElement('span')\n" +
      ' private lockX = this.x // カーソルが止まった時のx座標\n' +
      ' private lockY = this.y // カーソルが止まった時のy座標\n' +
      ' private scale: number // 円の大きさ\n' +
      ' private range: number // 円が動く範囲\n' +
      ' private angleX = 0  // 0 ~ 2π の乱数:(後述)\n' +
      ' private angleY = 0 // 0 ~ 2π の乱数:(後述)\n' +
      '\n' +
      '  constructor(\n' +
      '    private index: number, // 円の番号(0 ~ amount)\n' +
      '  ){\n' +
      '    // 球の大きさ(可変)\n' +
      '    // indexに反比例 = 後に生成された円ほど小さくなる\n' +
      '    this.scale = 1 - 0.04 * this.index\n' +
      '\n' +
      '    // 円が動く範囲(可変)\n' +
      '    // scaleに反比例 = indexに反比例 = 小さい円ほど広範囲を動く\n' +
      '    this.range = width / 2 - width / 2 * this.scale + 2\n' +
      '    \n' +
      '    this.element.classList.add(String(this.index))\n' +
      '    gsap.set(this.element, { scale: this.scale });\n' +
      '    cursor?.appendChild(this.element)\n' +
      '  }\n' +
      '\n' +
      '  //カーソルが止まった時に呼び出されるメソッド\n' +
      '  public lock() {\n' +
      '    /* 後述 */\n' +
      '  }\n' +
      '\n' +
      '  //止まった円の描画\n' +
      '  public draw() {\n' +
      '    /* 後述 */\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><br>可変と書いてある変数を調整するとマウスストーカーの動きに影響するので、色々と試してみてください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Dotクラスには、カーソルが静止した時の処理も含まれています。まずはlock()です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers ts"><code class="language-ts">  //カーソルが止まった時に1度だけ呼び出される\n' +
      '  public lock() {\n' +
      '    this.lockX = this.x;//とまったときのx座標の位置\n' +
      '    this.lockY = this.y;//とまったときのy座標の位置\n' +
      '    this.angleX = Math.PI * 2 * Math.random();// (0 ~ 2πの乱数)。カーソルが止まった時に乱数固定\n' +
      '    this.angleY = Math.PI * 2 * Math.random();\n' +
      '  }</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="point">カーソルが止まるたびに呼び出され、その都度止まったマウス位置を取得し、0 ~ 2πの乱数を2つ生成します</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>この2つの乱数は次の描画処理で使うことになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-6">カーソルが止まっている時の描画</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">実際に描画を行っているのがdraw()メソッドです</strong>。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers ts"><code class="language-ts">  /**\n' +
      '   * 止まった円の描画\n' +
      '   * indexがsineDots番目以降の円だけ動かす\n' +
      '   * idle: boolean // マウスが止まっている時true(グローバル変数)\n' +
      '   * sineDots: 動かす円の数(グローバル変数)\n' +
      '   */\n' +
      '  public draw() {\n' +
      '    if (!idle || this.index &lt;= sineDots) {\n' +
      '      gsap.set(this.element, {x: this.x, y: this.y})\n' +
      '    } else { // カーソルが止まっている時の円の描画\n' +
      '      this.angleX += this.anglespeed;//毎フレーム加算される\n' +
      '      this.angleY += this.anglespeed;//同上\n' +
      '      // this.lockX = 0\n' +
      '      this.y = this.lockY + Math.sin(this.angleY) * this.range; //y方向の動き\n' +
      '      this.x = this.lockX + Math.cos(this.angleX) * this.range; //x方向の動き\n' +
      '      gsap.set(this.element, { x: this.x, y: this.y });\n' +
      '    }\n' +
      '  }</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>コードの通り、全ての円を動かしているわけではありません。sineDotesで定義した数字より大きい番号の円のみ動かしています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>カーソルが止まっている時はelseブロックが実行されます。その中で周期的な動きを実現しているのがsin()とcos()で定義されている三角関数の部分です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>※三角関数については別途記事にする予定です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここでの動作を簡単に説明すると、カーソル位置(lockX, lockY)から半径rangeの範囲内を早さanglespeedで周期的に動く球を描画しています。<br>angleXとangleYは静止するたびに発生する0 ~ 2πの乱数でした。よって、静止するたびにx座標とy座標の三角関数の初期位相が変わるため毎回異なる動きを実現しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-7">カーソルが動いている時の描画</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers ts"><code class="language-ts">// 描画更新\n' +
      'const positionCursor = () =&gt; {\n' +
      '  let x = mousePosition.x\n' +
      '  let y = mousePosition.y\n' +
      '  dots.forEach((dot, index, dots) =&gt; {\n' +
      '    let nextDot = dots[index + 1] || dots[0]\n' +
      '    dot.x = x\n' +
      '    dot.y = y\n' +
      '    dot.draw()\n' +
      '    //カーソルが動いている時\n' +
      '    // 0.4は可変\n' +
      '    if (!idle || index &lt;= sineDots) {\n' +
      '      const dx = (nextDot.x - dot.x) * 0.4;\n' +
      '      const dy = (nextDot.y - dot.y) * 0.4;\n' +
      '      x += dx;\n' +
      '      y += dy;\n' +
      '  }\n' +
      '  })\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>カーソルが動いている時の処理はif文の中で行なっています。<br>小さい円になればなるほどdxが蓄積されて動きが遅れる単純な仕組みです。0.4などの係数をかけることで遅延する距離を調整できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">カーソルを早く動かしすぎると円と円の間が離れすぎるため、マウスストーカー が千切れてしまいます</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>下に載せたカスタマイズの例で千切れないようにする簡単な例を載せてます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>以上が円のアニメーションに関する説明です。次にHTML側でSVGフィルタをかける処理について簡単に説明します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="SVG">円を液体のようにつなげるSVGフィルタ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers svg"><code class="lang-svg">&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800"&gt;\n' +
      '  &lt;defs&gt;\n' +
      '    &lt;filter id="goo"&gt;\n' +
      '      &lt;!-- ぼかし --&gt;\n' +
      '      &lt;feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur" /&gt;\n' +
      '      &lt;!-- 透過度に対してコントラストをつける --&gt;\n' +
      '      &lt;feColorMatrix in="blur" mode="matrix" \n' +
      '        values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 35 -15" result="goo" /&gt;\n' +
      '      &lt;feComposite in="SourceGraphic" in2="goo" operator="atop" /&gt;\n' +
      '    &lt;/filter&gt;\n' +
      '  &lt;/defs&gt;\n' +
      '&lt;/svg&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>&lt;feGauusianBlur&gt;で円全体にガウシアンフィルターをかけてぼかす</li><li>&lt;feColorMatrix&gt;で透過度に対してコントラストをつけることで、全体をつなげて液体のように見せる</li></u'... 1153 more characters,
    date: '2021-11-21T17:37:35',
    categories: { nodes: [Array] },
    title: 'インクのようなマウスストーカーの作り方',
    featuredImage: { node: [Object] },
    uri: '/ink-cursor/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-647
203 wp-image-648
203 wp-image-650
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>Vue.jsでTypeScriptを使う方法、使う際に最低限知っておきたい事をまとめました。データや関数、算出プロパティなど、代表的な機能におけるTypeScriptの記述方法について一通り解説しています。ただし、今回説明する内容は<strong>Vue.jsのバージョン3以降に登場した「CompositionAPI」</strong>を対象にした記述方法となります。そこでVue.js3をあまり知らない方のために、CompositionAPIの使い方にも最低限触れています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#CompositionAPI"><span class="toc_number toc_depth_1">1</span> CompositionAPIとは</a></li><li><a href="#VuejsTypeScript"><span class="toc_number toc_depth_1">2</span> Vue.jsでTypeScriptを使うための事前準備</a><ul><li><a href="#Composition_APITypeScript"><span class="toc_number toc_depth_2">2.1</span> Composition APIでTypeScriptを使う準備</a></li><li><a href="#setup"><span class="toc_number toc_depth_2">2.2</span> setup関数について補足</a></li><li><a href="#ltscript_setupgt"><span class="toc_number toc_depth_2">2.3</span> 更に簡略化された書式、&lt;script setup&gt;構文</a></li></ul></li><li><a href="#i"><span class="toc_number toc_depth_1">3</span> 変数の書き方</a><ul><li><a href="#_ref"><span class="toc_number toc_depth_2">3.1</span> オブジェクト以外の型: ref</a></li><li><a href="#_reactive"><span class="toc_number toc_depth_2">3.2</span> オブジェクト: reactive</a></li></ul></li><li><a href="#i-2"><span class="toc_number toc_depth_1">4</span> 関数の書き方</a></li><li><a href="#i-3"><span class="toc_number toc_depth_1">5</span> 算出プロパティの書き方</a></li><li><a href="#i-4"><span class="toc_number toc_depth_1">6</span> ウォッチの書き方</a></li><li><a href="#i-5"><span class="toc_number toc_depth_1">7</span> ライフサイクルフックの書き方</a></li><li><a href="#props"><span class="toc_number toc_depth_1">8</span> propsの書き方</a><ul><li><a href="#props-2"><span class="toc_number toc_depth_2">8.1</span> propsプロパティ内での型付け</a></li><li><a href="#setupprops"><span class="toc_number toc_depth_2">8.2</span> setup()内でのpropsの扱い</a></li><li><a href="#ltscript_setupgt-2"><span class="toc_number toc_depth_2">8.3</span> &lt;script setup&gt;構文を利用した際の記述方法</a></li></ul></li><li><a href="#emits"><span class="toc_number toc_depth_1">9</span> emitsの書き方</a><ul><li><a href="#ltscript_setupgt-3"><span class="toc_number toc_depth_2">9.1</span> &lt;script setup&gt;構文を利用した際の記述方法</a></li></ul></li><li><a href="#ProvideInject"><span class="toc_number toc_depth_1">10</span> ProvideとInjectの書き方</a></li><li><a href="#i-6"><span class="toc_number toc_depth_1">11</span> テンプレート参照の書き方</a></li><li><a href="#Vuex"><span class="toc_number toc_depth_1">12</span> Vuexの書き方</a><ul><li><a href="#storets"><span class="toc_number toc_depth_2">12.1</span> store.tsの例</a></li></ul></li><li><a href="#Vue_Router"><span class="toc_number toc_depth_1">13</span> Vue Routerの書き方</a></li><li><a href="#i-7"><span class="toc_number toc_depth_1">14</span> まとめ</a></li></ul></div>\n' +
      '<h2 id="compositionapiとは"><span id="CompositionAPI"><meta charset="utf-8"><strong>CompositionAPI</strong>とは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Composition APIとは、Vue.js3から導入されたコンポーネントの新しい仕組みです。<br>これに対してVue2で一般的に使われていた、<br>data()、methods :{ }、computed:{ }を並べて利用したものをOptions APIと言います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>Composition APIはOptions APIよりもコードが綺麗に、よりシンプルに書けるようになります。<br>そして何より、<strong class="yellow-line">TypeScriptとの親和性が非常に高いです。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong>本記事でも軽くまとめてあります</strong>が、CompositionAPI自体について詳しく知りたい方は是非公式ドキュメントをご参照ください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<blockquote class="wp-block-quote"><p>Composition API | Vue.js</p><cite><a href="https://v3.ja.vuejs.org/api/composition-api.html#setup" target="_blank" rel="noreferrer noopener" class="broken_link">https://v3.ja.vuejs.org/api/composition-api.html#setup</a></cite></blockquote>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2 id="vue-jsでtypescriptを使うための事前準備"><span id="VuejsTypeScript">Vue.jsでTypeScriptを使うための事前準備</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3 id="基本的な書式"><span id="Composition_APITypeScript">Composition APIでTypeScriptを使う準備</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>雛形は以下のようになります。(Vue CLIやViteを使う場合、予め記述されている場合もあります。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">&lt;script lang="ts"&gt;\n' +
      'import { defineComponent } from "vue"\n' +
      '\n' +
      'export default defineComponent({\n' +
      '  setup() {}\n' +
      '})\n' +
      '\n' +
      '&lt;/script&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TypeScriptを利用する際のポイントは以下の2点です。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>scriptタグにlang属性の記述</li><li>defineComponent関数でsetup関数等を記述するオブジェクトを囲む</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>※<a href="#scriptSetup">すぐ後の説明</a>で、<strong class="yellow-line">この記述方法を簡略化した「script setup構文」の説明をします。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="setup">setup関数について補足</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>setup関数をご存じの方は読み飛ばして下さい。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>CompositionAPIでは、<strong>setup関数内にdataや関数、算出プロパティ、watchやライフライクルフック等すべてを書いていきます。</strong>これによって、コードが散らばらずに簡潔な記述ができたり、必要な処理だけを集めて外部ファイルに切り出してまとめること(コンポジション関数化)が出来る等、様々な恩恵を受けることが出来ます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、setup関数では、&lt;template>側で使いたい変数や関数をreturn文に記述する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">setup() {\n' +
      '  // 変数や関数、computedやwatchの定義はここに書く\n' +
      '  const 変数A = ...\n' +
      '  const 関数A = () => {...}\n' +
      '  return {\n' +
      '    templateで使いたい変数A, 変数B, 関数Aなど\n' +
      '  }\n' +
      '}</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>ここまでの説明でピンと来なくても、この記事内にsetup関数の使い方のサンプルを一通り掲載しているので、記事を読み進めれば言わんとしてることが分かるかと思います。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3 id="scriptSetup"><span id="ltscript_setupgt">更に簡略化された書式、&lt;script setup&gt;構文</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>前節で説明したような</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="ulOnly"><li>①defineComponent()の中で</li><li>②更にsetup()で囲って、</li><li>③templateで使いたい変数や関数をreturnする</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>&#8230;といった煩わしい記述を<strong class="yellow-line">簡略化できる書き方が導入されました。</strong><br>scriptタグにsetupを記述し<code class="language-ｔｓ">&lt;script lang="ts" setup&gt;</code>とすると、<strong class="yellow-line">①~③の記述が一切不要になります。</strong><br>\n' +
      'scriptタグ直下に変数や関数、算出プロパティ等をそのまま記述することが可能になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre><code class="language-ts">&lt;script lang="ts" setup&gt;\n' +
      '\n' +
      '//今までsetup(){}内に記述していたものをこの階層にそのまま記述できます。\n' +
      '//returnもいりません。\n' +
      '\n' +
      '//変数\n' +
      'const hoge = ~\n' +
      '\n' +
      '//関数\n' +
      'const hoge = () =&gt; {}\n' +
      ' \n' +
      '&lt;/script&gt;</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>本記事のサンプルコードでは通常のsetup関数を使った記述をしていますが、これからVue3で開発するならばscript setup構文のほうが簡単に記述できますし、メリットも多いのでおすすめです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このscript setup構文について詳しく知りたい方は、次の記事をご覧ください。</p>\n' +
      '\n' +
      '\n' +
      '<div class="linkcard"><div class="lkc-internal-wrap"><a class="lkc-link no_icon" href="https://tekrog.com/vue3-script-setup"><div class="lkc-card"><div class="lkc-info"><img class="lkc-favicon" src="https://www.google.com/s2/favicons?domain=tekrog.com" alt="" width=16 height=16 /><div class="lkc-domain">TeKRog</div>&nbsp;<div class="lkc-url-info">https://tekrog.com/vue3-script-setup</div></div><div class="lkc-content"><figure class="lkc-thumbnail"><img class="lkc-thumbnail-img" src="//tekrog.com/wp-content/uploads/2022/03/thumb-script-setup-150x150.jpg" alt="" /></figure><div class="lkc-title"><div class="lkc-title-text">【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】</div></div><div class="lkc-excerpt">Vue3.2で&lt;script setup&gt;構文が導入され、Composition APIの記述が簡単になりました。&lt;script setup&gt;構文は記述が簡単になるだけでなく、他にも多くのメリッ...</div></div><div class="clear"></div></div></a></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2 id="変数の書き方"><span id="i">変数の書き方</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>従来(Options API)のdata()に相当します。<strong class="yellow-line">変数の記法は変数の種類によって2つに分かれます。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3 id="プリミティブ型"><span id="_ref">オブジェクト以外の型: ref</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オブジェクト以外の型はrefでラップします。次のようにインポートする必要があります。<br> <code class="language-ts">import { ref } from "vue"</code></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4 id="refについて">refについて</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>普通のJavaScriptで変数を定義する時と同じように、constやletで宣言できるようになりました。<br>基本的にリテラルは<meta charset="utf-8"><code class="language-js">ref()</code>でラップする必要があり、これによってリアクティブになります。<br>(全く更新する予定のない変数はrefでラップする必要はありません。)<br>refという関数名の通り、変数は「値」では無く「参照」になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>また、refをscript内で利用する場合は.valueを付けて利用します。(下記サンプル参照)<br>template側で利用する際.valueの指定はいりません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4 id="typescriptでの書き方">TypeScriptでの書き方</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>TypeScriptでの書き方ですが、<br><strong class="yellow-line">TypeScriptが自動推論してくれる型(<strong>number型やstring型、boolean型等</strong>)には特別な記述はいりません。<br>明示的に型を付ける必要がある場合は、refにジェネリックを使います。</strong>(自動推論してくれない場合や、自動推論される型より詳細な型宣言が必要な場合等が該当します。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">export default defineComponent({\n' +
      '  setup() {\n' +
      '    //型推論\n' +
      "    const name = ref('ryo') // Ref&lt;string&gt;型\n" +
      '　　　　　　　　console.log(name.value)//.valueをつけて参照：string型になる\n' +
      '    \n' +
      '    //明示的な型付け\n' +
      '    const age = ref&lt;number | string&gt;(30) // Ref&lt;number | string&gt;型\n' +
      '\n' +
      '    //明示的な型付け\n' +
      '    const element = ref&lt;HTMLElement&gt;() // Ref&lt;HTMLElement | undefined&gt;型\n' +
      '    \n' +
      '　　　　　　　　return {\n' +
      '      name, age, element\n' +
      '    }\n' +
      '  }\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>T型の変数をrefでラップした変数の戻り値は、Ref&lt;T&gt;型になります。<br>例えば、string型の変数ならばRef&lt;string&gt;型になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>setup関数内でrefの値を参照したい場合は.valueをつけます。<br>この時、Ref&lt;T&gt;型の変数をT型として参照できます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul class="point"><li>自動的に型推論してくれる</li><li>明示的に型付けする場合はジェネリックで</li><li>Ref&lt;T&gt;型となる</li></ul>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3 id="オブジェクト"><span id="_reactive">オブジェクト: reactive</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>オブジェクトにはreactiveを使います。<br> <code class="language-ts">import { reactive } from "vue"</code></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4 id="reactiveについて">reactiveについて</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>refと同様に、普通のJavaScriptを使う要領でconst宣言(あるいはlet)します。<br>オブジェクトは<code class="language-js">reactive()</code>でラップすることでリアクティブになります。<br>refの使い方とあまり変わりませんが、値を参照する際に.valueの指定は必要ありません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h4 id="typescriptでの書き方">TypeScriptでの書き方</h4>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>明示的に型を付けたい場合は、初めにオブジェクトの型をtypeやinterfaceで定義します。<br>その型を変数宣言の際にreactiveと一緒に使うのですが、方法は3つあります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>reactiveでTypeScriptを使う3つの方法</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>ジェネリックを使う</li><li>明示的に型付けする</li><li>型アサーションを使う</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="line-numbers"><code class="language-ts">//インターフェースの定義\n' +
      'interface Person {\n' +
      '  name: string\n' +
      '  age?: number\n' +
      '}\n' +
      '\n' +
      'export default defineComponent({\n' +
      '  setup() {\n' +
      '    //方法1\n' +
      '    const person1 = reactive&lt;Per'... 15253 more characters,
    date: '2021-11-21T17:38:07',
    categories: { nodes: [Array] },
    title: 'Vue3でTypeScriptを使う方法【CompositionAPI】',
    featuredImage: { node: [Object] },
    uri: '/vue3-ts-quickmanual/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
203 lkc-favicon
203 lkc-thumbnail-img
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: 'ProvideとInjectをComposition APIとTypeScriptで解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/05/thumb-provide-inject.jpg'
  },
  {
    title: '【Vue3】watch系関数の違いと使い方(watchSyncEffect・watchPostEffect含)',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vue-watch.jpg'
  },
  {
    title: 'Vue3+Laravel+Pythonでスクレイピング',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-scraping.jpg'
  },
  {
    title: '【Vue3】script setup構文の使用方法とメリット【propsとemitsも解説】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-script-setup.jpg'
  },
  {
    title: 'Vueのライブラリ「VueUse」とは？',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/03/thumb-vueuse.jpg'
  },
  {
    title: '【Laravel】BladeファイルでVue3のコンポーネントを利用する方法【Vue3】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/02/thumb-vuexblade.jpg'
  }
]
101010101010101010 {
  post: {
    content: '\n' +
      '<p>この記事では、ページの一番上からHTML要素までの大きさ、要素の位置の取得方法を説明します。ただし、JavaScriptのコードの記述場所に注意しないと取得した値がずれてしまいます。そこで、コードの記述位置に関して陥りがちなミスも伏せて説明します。</p>\n' +
      '\n' +
      '\n' +
      '<div id="toc_container" class="toc_white no_bullets"><p class="toc_title">目次</p><ul class="toc_list"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 今回説明する要素の位置とは</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 要素の絶対位置の取得方法</a><ul><li><a href="#i-3"><span class="toc_number toc_depth_2">2.1</span> 完成形のデモ</a></li><li><a href="#i-4"><span class="toc_number toc_depth_2">2.2</span> 絶対位置を取得するコード</a></li></ul></li><li><a href="#i-5"><span class="toc_number toc_depth_1">3</span> コードの解説</a><ul><li><a href="#i-6"><span class="toc_number toc_depth_2">3.1</span> ビューポートを基準としたの位置取得</a></li><li><a href="#i-7"><span class="toc_number toc_depth_2">3.2</span> すでにスクロールされている場合を考慮</a></li></ul></li><li><a href="#i-8"><span class="toc_number toc_depth_1">4</span> 注意点！取得した位置がずれる場合</a><ul><li><a href="#DOM"><span class="toc_number toc_depth_2">4.1</span> 絶対位置を求めるのはDOM構築後</a></li></ul></li><li><a href="#i-9"><span class="toc_number toc_depth_1">5</span> まとめ</a></li></ul></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i">今回説明する要素の位置とは</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>今回説明する位置は、<strong class="yellow-line">スクロールできる領域全てを含めた、ページ全体における要素の位置を表します。</strong>ページトップからターゲットまでの距離(px)と言ったほうが分かりやすいかもしれません。他の場所からの位置と区別するため、<strong class="yellow-line">以下、この記事では絶対位置と呼びます</strong>。また、ターゲットの要素はビューポートの外にあっても構いません。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1.png" alt="" class="wp-image-387" width="1000" height="540" srcset="https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1.png 2000w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1-300x162.png 300w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1-1024x553.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1-768x415.png 768w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position01-1-1536x829.png 1536w" sizes="(max-width: 1000px) 100vw, 1000px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>位置には横方向と縦方向がありますが、以下、話を簡単にするため縦方向(y方向)についてのみ考えます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>横方向(x方向)も同じ考え方です。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-2">要素の絶対位置の取得方法</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-3">完成形のデモ</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>デモを用意しました。<br>取得した要素の絶対位置は右上の赤字で表示しております。<br>比較のため、現在のスクロール位置も同時に表示しました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="zYdEZey" data-user="ryoh96" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">\n' +
      '  <span>See the Pen <a href="https://codepen.io/ryoh96/pen/zYdEZey" class="broken_link">\n' +
      '  DEMO-get_absolute_position</a> by Ryoh96 (<a href="https://codepen.io/ryoh96" class="broken_link">@ryoh96</a>)\n' +
      '  on <a href="https://codepen.io" class="broken_link">CodePen</a>.</span>\n' +
      '</p>\n' +
      '<script async="" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>現在のスクロール位置の基準線をページの上端に青線で表示しています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>現在のスクロール位置である「青い線」がターゲット要素の上端の「赤い線」と重なった時、<strong>「絶対位置 = 現在のスクロール位置」</strong>となり、確かに絶対位置が得られていることがわかります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>それではコードの解説をしていきます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-4">絶対位置を取得するコード</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>絶対位置を取得するコードの例です。heightの値が絶対位置になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<pre class="js"><code class="language-js">window.addEventListener('DOMContentLoaded', () =&gt; {\n` +
      '  height = element.getBoundingClientRect().top + window.scrollY\n' +
      '})</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このコードは3つのステップで構成されています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>3つのステップ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>ビューポートからの位置を取得</li><li>すでにスクロールされている場合を考慮</li><li>【重要】これらの位置の取得をDOM構築後に行う</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '\n' +
      '<!-- banner1 -->\n' +
      '<div class="ad-hidden">\n' +
      '<ins class="adsbygoogle"\n' +
      'style="display:block"\n' +
      'data-ad-client="ca-pub-5954645555619996"\n' +
      'data-ad-slot="1703027587"\n' +
      'data-ad-format="auto"\n' +
      'data-full-width-responsive="false"></ins>\n' +
      '<script>\n' +
      'window.onload = () => {\n' +
      '  (adsbygoogle = window.adsbygoogle || []).push({});\n' +
      '}\n' +
      '</script>\n' +
      '</div><h2><span id="i-5">コードの解説</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-6">ビューポートを基準としたの位置取得</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>絶対位置を取得する前に、ビューポートの左上を原点とした要素の位置を取得する必要があります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">ビューポートの左上を原点とした要素の位置を取得するには getBoundingClientRect()を使います。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="js"><code class="language-js">const rect = element.getBoundingClientRect()</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="wp-block-liquid-speech-balloon liquid-speech-balloon-wrap liquid-speech-balloon-00"><div class="liquid-speech-balloon-avatar"></div><div class="liquid-speech-balloon-text"><p>elementは対象要素です。</p><div class="liquid-speech-balloon-arrow"></div></div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>getBoundingClientRect()の主なプロパティは以下の通りです。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group ulUI"><div class="wp-block-group__inner-container">\n' +
      '<p>主なプロパティ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ul><li>top:   要素の上までの長さ</li><li>left:   要素の左までの長さ</li><li>right:   要素の右までの長さ</li><li>bottom: 要素の下までの長さ</li><li>height:   要素の高さ</li><li>width:   要素の幅</li></ul>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>詳しくは<a href="https://developer.mozilla.org/ja/docs/Web/API/Element/getBoundingClientRect">こちらのドキュメント</a>をご覧ください。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>高さ方向で関係するのはtopやbottomです。今回は要素の上部までの距離が知りたいので、topを利用します。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="js"><code class="language-js">let top = element.getBoundingClientRect().top</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1.png" alt="" class="wp-image-391" width="1000" height="540" srcset="https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1.png 2000w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1-300x162.png 300w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1-1024x553.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1-768x415.png 768w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position02-1-1536x829.png 1536w" sizes="(max-width: 1000px) 100vw, 1000px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>これでtopの大きさが求まりました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="i-7">すでにスクロールされている場合を考慮</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>スクロール量を取得するコードは以下のようになります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<pre class="js"><code class="language-js">let scrolled = window.scrollY</code></pre>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="warning">window.pageYOffsetでもスクロール量が取得できますが、これはscrollYのエイリアスです。ただし、VS Codeで開発していると<strong>「pageYOffsetはレガシー(時代遅れ)なエイリアス」</strong>と表示され、打ち消し線が付き非推奨となっています。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>このスクロール量(scrolled)とビューポートからの位置(top)を足すことで絶対位置を取得することができます。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://tekrog.com/wp-content/uploads/2021/10/get-element-position03.png" alt="" class="wp-image-392" width="1000" height="540" srcset="https://tekrog.com/wp-content/uploads/2021/10/get-element-position03.png 2000w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position03-300x162.png 300w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position03-1024x553.png 1024w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position03-768x415.png 768w, https://tekrog.com/wp-content/uploads/2021/10/get-element-position03-1536x829.png 1536w" sizes="(max-width: 1000px) 100vw, 1000px" /></figure>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>scrolled + topが絶対位置になります。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-8">注意点！取得した位置がずれる場合</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h3><span id="DOM">絶対位置を求めるのはDOM構築後</span></h3>\n' +
      '\n' +
      '\n' +
      '\n' +
      `<p>注意すべきなのが、高さの取得はDOM構築後に行う必要があるところです。<br>つまり<code class="language-js">window.addEventListener('DOMContentLoaded', () =&gt; {})</code>内で実行します。</p>\n` +
      '\n' +
      '\n' +
      '\n' +
      '<p><strong class="yellow-line">DOM構築前に取得すると正しい位置が得られません。</strong></p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p class="comment">また、imgタグにheightやwidthを指定して、画像の高さもあらかじめ定義しておいて下さい。(レイアウトシフト対策にもなります。)</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<h2><span id="i-9">まとめ</span></h2>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>要素の絶対位置を取得する方法を紹介し、3つのステップに分けて見てきました。</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<div class="is-layout-flow wp-block-group olUI"><div class="wp-block-group__inner-container">\n' +
      '<p>3つのステップ</p>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<ol><li>ビューポートからの位置を取得</li><li>すでにスクロールされている場合を考慮</li><li>これらの位置の取得をDOM構築後に行う</li></ol>\n' +
      '</div></div>\n' +
      '\n' +
      '\n' +
      '\n' +
      '<p>特に3点目が重要で、DOM構築前に位置を取得するとズレてしまうので注意しましょう。<br>要素の位置が取得できれば、ページをどれだけ読み進めたか分かるプログレスバーなどに応用できます。</p>\n',
    date: '2021-11-21T17:38:20',
    categories: { nodes: [Array] },
    title: 'HTML要素の位置を取得する方法とズレた場合の対処法',
    featuredImage: { node: [Object] },
    uri: '/get-absolute-position/'
  },
  nextPost: { nodes: [ [Object] ] },
  prevPost: { nodes: [ [Object] ] },
  recentPost: { nodes: [ [Object], [Object], [Object], [Object], [Object] ] },
  categories: {
    nodes: [
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object], [Object],
      [Object]
    ]
  },
  archivePosts: {
    edges: [
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object],
      [Object], [Object], [Object], [Object]
    ]
  }
}
203 wp-image-387
203 wp-image-391
203 wp-image-392
10 {
  nodes: [
    {
      title: '【PHP8.1】列挙型(Enum)について徹底解説',
      featuredImage: [Object],
      uri: '/how-to-use-enum-in-php8-1/'
    }
  ]
}
[
  {
    title: '【TypeScript】allとraceだけじゃない！4つのPromise並列処理の違い【JavaScript】',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/03/thumb-promise-cocurrency.png'
  },
  {
    title: '【Promise】thenとasync/awaitの違い, 使い分けと同時利用法',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-await.png'
  },
  {
    title: '【es2022-2019】最近のJavaScriptの新機能を振り返る【まとめ】',
    categories: [ [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2023/02/thumb-ecma2022.png'
  },
  {
    title: 'JavaScript、TypeScriptで簡単画像処理【画像処理の知識不要】',
    categories: [ [Object], [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/04/thumb-easy-image-processing-by-ts.jpg'
  },
  {
    title: '追従＆ハイライト、自動スクロールする目次の作り方',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2022/01/fy.jpg'
  },
  {
    title: 'TypeScriptで学ぶ！asyncとawait、Promiseの分かりやすい解説',
    categories: [ [Object], [Object] ],
    imgUrl: 'https://tekrog.com/wp-content/uploads/2021/12/thumb-async.jpg'
  }
]
info  - Generating static pages (59/59)
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
